{"version":3,"sources":["../../../utils/error.ts","../../../node_modules/safe-buffer/index.js","../../../lib/stripe.ts","../../../lib/ai-voice-agent.ts","../../../app/api/collections/ai-call/send-payment-link/route.ts","../../../node_modules/next/src/build/templates/app-route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport { ZodError } from 'zod';\n\n// Custom error classes\nexport class ApiError extends Error {\n  constructor(\n    public statusCode: number,\n    message: string,\n    public code?: string\n  ) {\n    super(message);\n    this.name = 'ApiError';\n  }\n}\n\nexport class ValidationError extends ApiError {\n  constructor(message: string, public details?: any) {\n    super(400, message, 'VALIDATION_ERROR');\n  }\n}\n\nexport class UnauthorizedError extends ApiError {\n  constructor(message: string = 'Unauthorized') {\n    super(401, message, 'UNAUTHORIZED');\n  }\n}\n\nexport class ForbiddenError extends ApiError {\n  constructor(message: string = 'Forbidden') {\n    super(403, message, 'FORBIDDEN');\n  }\n}\n\nexport class NotFoundError extends ApiError {\n  constructor(message: string = 'Not found') {\n    super(404, message, 'NOT_FOUND');\n  }\n}\n\nexport class RateLimitError extends ApiError {\n  constructor(message: string = 'Rate limit exceeded', public retryAfter?: number) {\n    super(429, message, 'RATE_LIMIT');\n  }\n}\n\nexport class InternalError extends ApiError {\n  constructor(message: string = 'Internal server error') {\n    super(500, message, 'INTERNAL_ERROR');\n  }\n}\n\n// Common error constructors\nexport const errors = {\n  unauthorized: (message = 'Unauthorized') => new UnauthorizedError(message),\n  forbidden: (message = 'Forbidden') => new ForbiddenError(message),\n  notFound: (message = 'Not found') => new NotFoundError(message),\n  badRequest: (message: string) => new ValidationError(message),\n  internal: (message = 'Internal server error') => new InternalError(message),\n  rateLimit: (message = 'Rate limit exceeded', retryAfter?: number) =>\n    new RateLimitError(message, retryAfter),\n};\n\n// Error handler function\nexport function handleApiError(error: unknown): NextResponse {\n  // Handle custom API errors\n  if (error instanceof ApiError) {\n    const response: any = {\n      error: error.code,\n      message: error.message,\n    };\n\n    if (error instanceof ValidationError && error.details) {\n      response.details = error.details;\n    }\n\n    if (error instanceof RateLimitError && error.retryAfter) {\n      return NextResponse.json(response, {\n        status: error.statusCode,\n        headers: {\n          'Retry-After': error.retryAfter.toString(),\n        },\n      });\n    }\n\n    return NextResponse.json(response, { status: error.statusCode });\n  }\n\n  // Handle Zod validation errors\n  if (error instanceof ZodError) {\n    return NextResponse.json(\n      {\n        error: 'VALIDATION_ERROR',\n        message: 'Invalid request data',\n        details: error.issues,\n      },\n      { status: 400 }\n    );\n  }\n\n  // Handle unknown errors\n  console.error('Unhandled error:', error);\n\n  return NextResponse.json(\n    {\n      error: 'INTERNAL_ERROR',\n      message: 'An unexpected error occurred',\n    },\n    { status: 500 }\n  );\n}\n\n// Async error wrapper for API routes\nexport function withErrorHandling(\n  handler: (req: Request, context?: any) => Promise<NextResponse>\n) {\n  return async (req: Request, context?: any): Promise<NextResponse> => {\n    try {\n      return await handler(req, context);\n    } catch (error) {\n      return handleApiError(error);\n    }\n  };\n}\n","/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","import Stripe from 'stripe';\n\n// Lazy initialization to avoid build-time errors\nlet stripeInstance: Stripe | null = null;\n\nfunction getStripe(): Stripe {\n  if (!stripeInstance) {\n    const apiKey = process.env.STRIPE_SECRET_KEY;\n    if (!apiKey) {\n      throw new Error('STRIPE_SECRET_KEY is not configured');\n    }\n    stripeInstance = new Stripe(apiKey, {\n      // Using latest stable API version - Stripe will default to account version if omitted\n      // Specify explicit version only when needed for compatibility\n      typescript: true,\n    });\n  }\n  return stripeInstance;\n}\n\n// Export for backward compatibility\nexport const stripe = new Proxy({} as Stripe, {\n  get(target, prop) {\n    return (getStripe() as any)[prop];\n  }\n});\n\n// Create payment link for invoice\nexport async function createStripePaymentLink(params: {\n  amount: number;\n  invoiceReference: string;\n  clientEmail: string;\n  freelancerId: string;\n  currency?: string;\n}): Promise<string> {\n  try {\n    const paymentLink = await stripe.paymentLinks.create({\n      line_items: [\n        {\n          price_data: {\n            currency: (params.currency || 'GBP').toLowerCase(),\n            unit_amount: Math.round(params.amount * 100), // Convert to pence\n            product_data: {\n              name: `Invoice ${params.invoiceReference}`,\n              description: `Payment for ${params.invoiceReference}`,\n            },\n          },\n          quantity: 1,\n        },\n      ],\n      after_completion: {\n        type: 'redirect',\n        redirect: {\n          url: `${process.env.NEXT_PUBLIC_APP_URL}/payment-success?invoice=${params.invoiceReference}`,\n        },\n      },\n      metadata: {\n        invoiceReference: params.invoiceReference,\n        freelancerId: params.freelancerId,\n        clientEmail: params.clientEmail,\n      },\n      // Allow promotion codes\n      allow_promotion_codes: true,\n    });\n\n    return paymentLink.url;\n  } catch (error) {\n    console.error('Stripe payment link creation error:', error);\n    throw new Error('Failed to create payment link');\n  }\n}\n\n// Verify webhook signature (CRITICAL for security)\nexport function verifyWebhookSignature(\n  payload: string,\n  signature: string,\n  secret: string\n): Stripe.Event {\n  try {\n    return stripe.webhooks.constructEvent(payload, signature, secret);\n  } catch (error) {\n    console.error('Webhook signature verification failed:', error);\n    throw new Error('Invalid webhook signature');\n  }\n}\n\n// Get payment intent details\nexport async function getPaymentIntent(paymentIntentId: string) {\n  try {\n    return await stripe.paymentIntents.retrieve(paymentIntentId);\n  } catch (error) {\n    console.error('Stripe payment intent retrieval error:', error);\n    throw new Error('Failed to retrieve payment intent');\n  }\n}\n\n// Create customer (for subscription management later)\nexport async function createCustomer(params: {\n  email: string;\n  name: string;\n  metadata?: Record<string, string>;\n}) {\n  try {\n    return await stripe.customers.create({\n      email: params.email,\n      name: params.name,\n      metadata: params.metadata,\n    });\n  } catch (error) {\n    console.error('Stripe customer creation error:', error);\n    throw new Error('Failed to create customer');\n  }\n}\n","/**\n * PREMIUM FEATURE: AI Voice Agent for Collections Calls\n *\n * Integrates OpenAI Realtime API with Twilio for automated collection calls.\n * The AI agent conducts empathetic debt collection conversations, negotiates\n * payment arrangements, and can accept payments via IVR/SMS during the call.\n *\n * Architecture:\n * 1. Twilio initiates outbound call to debtor\n * 2. Call connects to our webhook endpoint\n * 3. Webhook establishes WebSocket to OpenAI Realtime API\n * 4. Audio streams bidirectionally: Twilio <-> Our Server <-> OpenAI\n * 5. AI agent conducts conversation following UK regulations\n * 6. Payment can be collected via Twilio IVR or SMS link\n * 7. Call transcript and outcome stored in Firestore\n *\n * Setup Instructions:\n * 1. Twilio Setup:\n *    - Account SID and Auth Token in .env\n *    - Phone number with Voice capabilities\n *    - Configure webhook: https://your-domain/api/webhooks/twilio/voice\n *\n * 2. OpenAI Setup:\n *    - Realtime API access (gpt-4o-realtime-preview model)\n *    - API key in .env\n *    - WebSocket endpoint: wss://api.openai.com/v1/realtime\n *\n * 3. Environment Variables:\n *    TWILIO_ACCOUNT_SID=ACxxxxx\n *    TWILIO_AUTH_TOKEN=xxxxx\n *    TWILIO_PHONE_NUMBER=+44xxxxx\n *    OPENAI_API_KEY=sk-xxxxx\n *    STRIPE_SECRET_KEY=sk_xxxxx (for payment links)\n *\n * 4. Install packages:\n *    npm install twilio ws openai\n *\n * UK Debt Collection Call Regulations:\n * - Must identify caller and purpose immediately\n * - Must not be threatening, abusive, or harassing\n * - Must respect request to stop calling\n * - Must not call at unreasonable hours (typically 21:00-08:00)\n * - Must allow debtor to dispute the debt\n * - Must offer payment arrangements for financial hardship\n * - Must record call with consent (or notify of recording)\n * - Comply with FCA debt collection rules\n * - GDPR: Store recordings securely, provide data access on request\n */\n\nimport { logError, logExternalApiCall, logInfo } from '@/utils/logger';\nimport { createStripePaymentLink } from './stripe';\n\n// AUDIT TASK #2: Packages are installed (twilio@5.10.5, ws@8.18.3)\nimport twilio from 'twilio';\nimport { WebSocket } from 'ws';\n\n/**\n * Call outcome types\n */\nexport type CallOutcome =\n  | 'paid' // Payment completed during call\n  | 'promise' // Debtor promised to pay by date\n  | 'partial' // Partial payment agreed\n  | 'refused' // Debtor refused to pay\n  | 'no_answer' // No answer\n  | 'voicemail' // Reached voicemail\n  | 'dispute' // Debtor disputes the debt\n  | 'financial_hardship' // Debtor claims financial hardship\n  | 'error'; // Technical error\n\n/**\n * AI Agent system prompt for debt collection\n * Configured for empathetic, regulation-compliant conversations\n */\nconst AI_AGENT_SYSTEM_PROMPT = `You are an AI collections agent calling on behalf of a freelancer to request payment for an overdue invoice.\n\nCRITICAL RULES (UK Debt Collection Regulations):\n1. Immediately identify yourself: \"This is an automated call from [Business Name] regarding an outstanding invoice.\"\n2. Ask for consent to record: \"This call may be recorded for training and quality purposes. Do you consent to continue?\"\n3. If they say NO to recording, end call politely immediately.\n4. Be professional, empathetic, and non-threatening at all times.\n5. NEVER be aggressive, threatening, or harassing.\n6. If they request to stop calling, agree immediately and end call.\n7. If they dispute the debt, note it and offer to send details in writing.\n8. If they claim financial hardship, be understanding and offer payment plans.\n9. Respect quiet hours - this call should only happen 08:00-21:00 UK time.\n10. Keep call under 10 minutes unless debtor is actively engaging.\n\nYOUR GOALS (in priority order):\n1. BEST: Collect full payment immediately via card payment link\n2. GOOD: Negotiate payment plan with first payment today\n3. ACCEPTABLE: Get promise to pay by specific date\n4. MINIMUM: Understand their situation and document for follow-up\n\nCONVERSATION FLOW:\n1. Opening & Consent (30 seconds)\n   - Identify yourself and purpose\n   - Request recording consent\n   - Confirm you're speaking to the right person\n\n2. Invoice Details (30 seconds)\n   - State invoice number, amount, and due date\n   - Mention how many days overdue\n   - Ask if they recall this invoice\n\n3. Payment Request (1 minute)\n   - Ask for immediate payment\n   - If hesitant, explain consequences (not threats - just facts)\n   - Offer to send secure payment link via SMS during call\n\n4. Negotiation (2-5 minutes if needed)\n   - If can't pay in full, ask what they CAN pay\n   - Offer payment plan (50% today, 50% in 14 days)\n   - If financial hardship, show empathy and reduce pressure\n   - Document any promises or commitments\n\n5. Payment Collection (if agreed)\n   - Confirm amount to be paid\n   - Send SMS payment link (tell them to expect text)\n   - Wait on call while they complete payment\n   - Confirm receipt and thank them\n\n6. Closing (30 seconds)\n   - Summarize agreed action\n   - Confirm any follow-up date\n   - Thank them for their time\n   - End politely\n\nHANDLING OBJECTIONS:\n- \"I don't have the money\": Offer smaller amount or payment plan\n- \"I never got the invoice\": Offer to resend, but payment still due\n- \"The work was poor\": Note dispute, but this doesn't cancel debt\n- \"I'll pay next week\": Get specific date and commitment\n- \"Stop calling me\": Apologize, agree immediately, end call\n- Abusive language: Stay calm, warn once, end call if continues\n\nPAYMENT LINK:\nWhen debtor agrees to pay, say:\n\"I'm sending you a secure payment link by text message right now. You can complete the payment while we're on the call. Please check your phone for a text from [Business Name].\"\n\nWait 30-60 seconds for them to receive and open SMS.\n\nVOICE TONE:\n- Friendly but professional\n- Empathetic and understanding\n- Patient but persistent\n- Clear and concise\n- NO aggressive or threatening tone\n\nREMEMBER: Your goal is to collect payment while maintaining the freelancer's reputation. A harsh call might get payment but lose future business. Be firm but fair.`;\n\n/**\n * Initialize Twilio client\n * AUDIT TASK #2: Twilio is installed and configured\n */\nfunction getTwilioClient() {\n  return twilio(\n    process.env.TWILIO_ACCOUNT_SID!,\n    process.env.TWILIO_AUTH_TOKEN!\n  );\n}\n\n/**\n * Initiate AI-powered collection call\n *\n * @param params Call parameters\n * @returns Call SID and status\n */\nexport async function initiateAICollectionCall(params: {\n  recipientPhone: string; // E.164: +44xxxxxxxxxx\n  recipientName: string;\n  invoiceReference: string;\n  amount: number;\n  dueDate: string;\n  daysPastDue: number;\n  businessName: string;\n  // Internal tracking\n  invoiceId: string;\n  freelancerId: string;\n  // Payment options\n  enablePaymentDuringCall?: boolean;\n}): Promise<{\n  success: boolean;\n  callSid?: string;\n  error?: string;\n}> {\n  const startTime = Date.now();\n\n  try {\n    // 1. Validate phone number\n    if (!params.recipientPhone.startsWith('+44')) {\n      throw new Error('Only UK phone numbers supported');\n    }\n\n    // 2. Check quiet hours (21:00 - 08:00)\n    const hour = new Date().getHours();\n    if (hour >= 21 || hour < 8) {\n      throw new Error('Cannot call during quiet hours (21:00-08:00)');\n    }\n\n    // 3. Create context for AI agent\n    const callContext = {\n      recipientName: params.recipientName,\n      invoiceReference: params.invoiceReference,\n      amount: params.amount,\n      dueDate: params.dueDate,\n      daysPastDue: params.daysPastDue,\n      businessName: params.businessName,\n      invoiceId: params.invoiceId,\n      freelancerId: params.freelancerId,\n    };\n\n    // 4. Initiate call via Twilio\n    // AUDIT TASK #2: Twilio is configured and ready for production use\n    const client = getTwilioClient();\n    const call = await client.calls.create({\n      to: params.recipientPhone,\n      from: process.env.TWILIO_PHONE_NUMBER!,\n      url: `${process.env.NEXT_PUBLIC_APP_URL}/api/webhooks/twilio/voice-ai?context=${encodeURIComponent(JSON.stringify(callContext))}`,\n      statusCallback: `${process.env.NEXT_PUBLIC_APP_URL}/api/webhooks/twilio/call-status`,\n      statusCallbackEvent: ['initiated', 'ringing', 'answered', 'completed'],\n      record: true,\n      recordingStatusCallback: `${process.env.NEXT_PUBLIC_APP_URL}/api/webhooks/twilio/recording-status`,\n    });\n\n    const duration = Date.now() - startTime;\n    logExternalApiCall('Twilio Voice AI', 'initiate', duration);\n\n    return {\n      success: true,\n      callSid: call.sid,\n    };\n\n  } catch (error) {\n    const duration = Date.now() - startTime;\n    logExternalApiCall('Twilio Voice AI', 'initiate', duration, error as Error);\n\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error',\n    };\n  }\n}\n\n/**\n * Handle OpenAI Realtime API WebSocket connection\n * This runs during the active call to stream audio\n *\n * WebSocket Server Implementation\n *\n * The full WebSocket handler is deployed separately for scalability.\n * Vercel doesn't support persistent WebSocket connections, so we use\n * a dedicated Fastify server on Render.com.\n *\n * Implementation Location:\n * - Server: render-server/src/index.ts\n * - OpenAI Integration: render-server/src/services/openai-realtime.ts\n * - Twilio Handler: render-server/src/services/twilio-handler.ts\n * - FCA Prompts: render-server/src/prompts/fca-compliant-prompts.ts\n *\n * Deployment:\n * - Platform: Render.com (Web Service)\n * - Config: render-server/render.yaml\n * - Guide: render-server/README.md\n *\n * WebSocket Endpoint: wss://[your-app].onrender.com/voice-stream\n * Webhook Callback: POST /api/webhooks/voice-call (this app)\n *\n * Environment Variables Required:\n * - OPENAI_API_KEY\n * - TWILIO_ACCOUNT_SID\n * - TWILIO_AUTH_TOKEN\n * - RELAY_WEBHOOK_URL (this app's URL)\n * - VOICE_SERVER_WEBHOOK_SECRET\n */\nexport async function handleRealtimeAICall(params: {\n  twilioStreamSid: string;\n  callContext: {\n    recipientName: string;\n    invoiceReference: string;\n    amount: number;\n    dueDate: string;\n    daysPastDue: number;\n    businessName: string;\n  };\n}): Promise<void> {\n  // TODO: Implement WebSocket connection to OpenAI Realtime API\n  /*\n  const openaiWs = new WebSocket('wss://api.openai.com/v1/realtime', {\n    headers: {\n      'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,\n      'OpenAI-Beta': 'realtime=v1',\n    },\n  });\n\n  // Configure session\n  openaiWs.on('open', () => {\n    openaiWs.send(JSON.stringify({\n      type: 'session.update',\n      session: {\n        modalities: ['text', 'audio'],\n        instructions: AI_AGENT_SYSTEM_PROMPT,\n        voice: 'alloy', // Professional female voice\n        input_audio_format: 'g711_ulaw', // Twilio format\n        output_audio_format: 'g711_ulaw',\n        turn_detection: {\n          type: 'server_vad', // Voice Activity Detection\n          threshold: 0.5,\n          prefix_padding_ms: 300,\n          silence_duration_ms: 500,\n        },\n      },\n    }));\n\n    // Send initial context\n    openaiWs.send(JSON.stringify({\n      type: 'conversation.item.create',\n      item: {\n        type: 'message',\n        role: 'system',\n        content: [{\n          type: 'input_text',\n          text: `You are calling ${params.callContext.recipientName} about invoice ${params.callContext.invoiceReference} for £${params.callContext.amount}, which is ${params.callContext.daysPastDue} days overdue.`,\n        }],\n      },\n    }));\n  });\n\n  // Handle audio from OpenAI -> Twilio\n  openaiWs.on('message', (data) => {\n    const message = JSON.parse(data.toString());\n\n    if (message.type === 'response.audio.delta') {\n      // Forward audio chunk to Twilio\n      // twilioWs.send(message.delta);\n    }\n\n    if (message.type === 'response.done') {\n      // Save transcript\n      console.log('[AI Transcript]', message.output);\n    }\n  });\n  */\n\n  logInfo('AI call handler scaffold - implement WebSocket streaming');\n}\n\n/**\n * Send payment link via SMS during active call\n *\n * This function is called by the AI agent during an active call\n * when the debtor agrees to pay immediately.\n * \n * The AI agent will say:\n * \"I'm sending you a secure payment link by text message right now.\n * You can complete the payment while we're on the call.\"\n * \n * CRITICAL: UK PECR Compliance\n * - SMS can only be sent if user has given SMS consent\n * - This consent is captured during onboarding or settings\n * - If no consent, fall back to email payment link\n *\n * @param params Payment link parameters\n * @returns SMS send result\n */\nexport async function sendPaymentLinkDuringCall(params: {\n  recipientPhone: string;\n  amount: number;\n  invoiceReference: string;\n  freelancerId: string;\n  invoiceId: string;\n}): Promise<{\n  success: boolean;\n  paymentLink?: string;\n  messageSid?: string;\n  error?: string;\n}> {\n  const startTime = Date.now();\n\n  try {\n    // 1. Create Stripe payment link with metadata\n    const paymentLink = await createStripePaymentLink({\n      amount: params.amount,\n      invoiceReference: params.invoiceReference,\n      clientEmail: 'payment-via-call@relay.app', // Temporary placeholder\n      freelancerId: params.freelancerId,\n      currency: 'GBP',\n    });\n\n    // 2. Send via Twilio SMS\n    // AUDIT TASK #2: Twilio SMS is configured and ready\n    const client = getTwilioClient();\n    const message = await client.messages.create({\n      to: params.recipientPhone,\n      from: process.env.TWILIO_PHONE_NUMBER,\n      body: `Payment link for invoice ${params.invoiceReference}: Pay £${params.amount.toFixed(2)} securely at ${paymentLink}. This link expires in 24 hours.`,\n      statusCallback: `${process.env.NEXT_PUBLIC_APP_URL}/api/webhooks/twilio/sms-status`,\n    });\n\n    const duration = Date.now() - startTime;\n    logExternalApiCall('Twilio SMS', 'send_payment_link', duration);\n\n    logInfo('Payment SMS sent during AI call', {\n      invoiceReference: params.invoiceReference,\n      recipientPhone: params.recipientPhone.substring(0, 7) + '***', // Privacy\n      messageSid: message.sid,\n    });\n\n    return {\n      success: true,\n      paymentLink,\n      messageSid: message.sid,\n    };\n\n  } catch (error) {\n    const duration = Date.now() - startTime;\n    logExternalApiCall('Twilio SMS', 'send_payment_link', duration, error as Error);\n\n    logError('Failed to send payment link during call', error);\n\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error',\n    };\n  }\n}\n\n/**\n * Process call outcome and extract structured data from transcript\n *\n * Uses OpenAI to analyze the call transcript and extract:\n * - Payment outcome\n * - Payment promises\n * - Dispute details\n * - Next actions\n *\n * @param callTranscript Full call transcript\n * @returns Structured call outcome\n */\nexport async function processCallOutcome(params: {\n  callTranscript: string;\n  callSid: string;\n  invoiceId: string;\n}): Promise<{\n  outcome: CallOutcome;\n  summary: string;\n  nextAction?: 'accept_partial' | 'schedule_followup' | 'escalate' | 'pause' | 'complete' | 'agency_handoff';\n  scheduledFollowupDate?: string;\n  partialAmountAgreed?: number;\n  clientProposedDate?: string;\n  disputeDetails?: string;\n  paymentMethod?: 'sms_link' | 'ivr' | 'bank_transfer';\n}> {\n  try {\n    // AUDIT TASK #8: Use OpenAI GPT-4 to analyze transcript\n    const { openai } = await import('@/lib/openai');\n\n    const response = await openai.chat.completions.create({\n      model: 'gpt-4o-mini',\n      messages: [\n        {\n          role: 'system',\n          content: `Analyze this debt collection call transcript and extract structured data.\nReturn JSON with:\n- outcome: 'paid' | 'promise' | 'partial' | 'refused' | 'no_answer' | 'voicemail' | 'dispute' | 'financial_hardship' | 'error'\n- summary: 2-3 sentence summary of call\n- nextAction: recommended next action ('accept_partial' | 'schedule_followup' | 'escalate' | 'pause' | 'complete' | 'agency_handoff')\n- scheduledFollowupDate: if debtor promised to pay by date (YYYY-MM-DD)\n- partialAmountAgreed: if partial payment agreed (number)\n- clientProposedDate: if client suggested payment date (YYYY-MM-DD)\n- disputeDetails: if debt was disputed, what are the details\n- paymentMethod: how payment was arranged ('sms_link' | 'ivr' | 'bank_transfer')\n\nBe objective and factual. Extract specific commitments and dates mentioned.`,\n        },\n        {\n          role: 'user',\n          content: params.callTranscript,\n        },\n      ],\n      response_format: { type: 'json_object' },\n      temperature: 0.1, // Low temperature for consistency\n    });\n\n    const content = response.choices[0]?.message?.content;\n    if (!content) {\n      throw new Error('No response from OpenAI');\n    }\n\n    const analysis = JSON.parse(content);\n\n    logInfo('Call transcript analyzed successfully', {\n      callSid: params.callSid,\n      invoiceId: params.invoiceId,\n      outcome: analysis.outcome,\n    });\n\n    return analysis;\n\n  } catch (error) {\n    logError('Failed to process call outcome', error);\n\n    return {\n      outcome: 'error',\n      summary: 'Failed to analyze call transcript',\n    };\n  }\n}\n\n/**\n * Get call recording URL from Twilio\n *\n * @param callSid Twilio call SID\n * @returns Recording URL\n */\nexport async function getCallRecording(callSid: string): Promise<{\n  recordingUrl?: string;\n  duration?: number;\n  error?: string;\n}> {\n  try {\n    // AUDIT TASK #2: Twilio is configured for production\n    const client = getTwilioClient();\n    const recordings = await client.recordings.list({ callSid, limit: 1 });\n\n    if (recordings.length > 0) {\n      const recording = recordings[0];\n      return {\n        recordingUrl: `https://api.twilio.com${recording.uri.replace('.json', '.mp3')}`,\n        duration: parseInt(recording.duration || '0', 10),\n      };\n    }\n\n    return {\n      error: 'No recording found for this call',\n    };\n\n  } catch (error) {\n    return {\n      error: error instanceof Error ? error.message : 'Unknown error',\n    };\n  }\n}\n\n/**\n * Estimate AI call cost\n * Breakdown of costs per call:\n * - Twilio outbound call: ~£0.02/min to UK mobiles\n * - OpenAI Realtime API: ~$0.06/min for audio input, ~$0.24/min for audio output\n * - Average 5-minute call: ~£0.10 Twilio + ~$1.50 OpenAI = ~£1.30 total\n * - SMS payment link: +£0.04\n * - Recording storage: ~£0.01\n *\n * Total per call: ~£1.35 for 5-minute call with payment link\n */\nexport function estimateAICallCost(params: {\n  estimatedDurationMinutes: number;\n  includeSMS?: boolean;\n  includeRecording?: boolean;\n}): {\n  twilioVoice: number;\n  openaiRealtime: number;\n  sms: number;\n  recording: number;\n  total: number;\n} {\n  const { estimatedDurationMinutes, includeSMS = false, includeRecording = true } = params;\n\n  const twilioVoice = estimatedDurationMinutes * 0.02; // £0.02/min\n  const openaiRealtime = estimatedDurationMinutes * 0.30; // ~£0.30/min ($0.06 input + $0.24 output)\n  const sms = includeSMS ? 0.04 : 0;\n  const recording = includeRecording ? 0.01 : 0;\n\n  return {\n    twilioVoice,\n    openaiRealtime,\n    sms,\n    recording,\n    total: twilioVoice + openaiRealtime + sms + recording,\n  };\n}\n\n/**\n * Check if user has given consent for AI calls\n * Required by UK law before making automated calls\n * AUDIT TASK #2: Implemented consent check (LOW priority item #11)\n */\nexport async function checkCallConsent(userId: string): Promise<boolean> {\n  try {\n    // Note: This requires Firebase to be imported\n    // Lazy import to avoid circular dependencies\n    const { db } = await import('@/lib/firebase');\n\n    const userDoc = await db.collection('users').doc(userId).get();\n    const user = userDoc.data();\n\n    return user?.collectionsConsent?.callConsent === true &&\n           user?.collectionsConsent?.callRecordingConsent === true;\n  } catch (error) {\n    logError('Failed to check call consent', error);\n    // Fail closed - no consent if we can't verify\n    return false;\n  }\n}\n","/**\r\n * AI Call Payment Link Endpoint\r\n * POST /api/collections/ai-call/send-payment-link\r\n *\r\n * Called by the WebSocket server when AI agent determines\r\n * the debtor wants to pay immediately during the call.\r\n *\r\n * This endpoint:\r\n * 1. Creates a Stripe payment link\r\n * 2. Sends it via SMS to the debtor\r\n * 3. Returns the link to the AI agent\r\n * 4. Records the action in Firestore\r\n *\r\n * Security: This endpoint is internal-only (called by WebSocket server)\r\n * Requires authentication and validation\r\n */\r\n\r\nimport { NextRequest, NextResponse } from 'next/server';\r\nimport { auth } from '@clerk/nextjs/server';\r\nimport { db, FieldValue } from '@/lib/firebase';\r\nimport { sendPaymentLinkDuringCall } from '@/lib/ai-voice-agent';\r\nimport { errors, handleApiError } from '@/utils/error';\r\nimport { logApiRequest, logApiResponse, logInfo } from '@/utils/logger';\r\n\r\nexport const dynamic = 'force-dynamic';\r\n\r\n/**\r\n * Send payment link during active AI call\r\n * POST /api/collections/ai-call/send-payment-link\r\n */\r\nexport async function POST(req: NextRequest): Promise<NextResponse> {\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n        // 1. Authenticate (this should be called by WebSocket server with valid session)\r\n        const { userId } = await auth();\r\n        if (!userId) {\r\n            throw errors.unauthorized();\r\n        }\r\n\r\n        logApiRequest('POST', '/api/collections/ai-call/send-payment-link', userId);\r\n\r\n        // 2. Parse request body\r\n        const body = await req.json();\r\n        const {\r\n            invoiceId,\r\n            callSid,\r\n            recipientPhone,\r\n            amount,\r\n        }: {\r\n            invoiceId: string;\r\n            callSid: string;\r\n            recipientPhone: string;\r\n            amount?: number; // Optional - if not provided, use invoice amount\r\n        } = body;\r\n\r\n        if (!invoiceId || !callSid || !recipientPhone) {\r\n            throw errors.badRequest('Missing required fields: invoiceId, callSid, recipientPhone');\r\n        }\r\n\r\n        // 3. Get invoice to verify ownership and get details\r\n        const invoiceDoc = await db.collection('invoices').doc(invoiceId).get();\r\n        if (!invoiceDoc.exists) {\r\n            throw errors.notFound('Invoice not found');\r\n        }\r\n\r\n        const invoice = invoiceDoc.data();\r\n\r\n        // 4. Verify ownership\r\n        if (invoice?.freelancerId !== userId) {\r\n            throw errors.forbidden('You do not have access to this invoice');\r\n        }\r\n\r\n        // 5. Determine payment amount (partial payment allowed during negotiation)\r\n        const paymentAmount = amount || invoice?.amount;\r\n\r\n        if (!paymentAmount || paymentAmount <= 0) {\r\n            throw errors.badRequest('Invalid payment amount');\r\n        }\r\n\r\n        // 6. Validate partial payment (must be at least 25% of invoice)\r\n        if (paymentAmount < (invoice?.amount * 0.25)) {\r\n            throw errors.badRequest('Partial payment must be at least 25% of invoice amount');\r\n        }\r\n\r\n        // 7. Send payment link via SMS\r\n        const result = await sendPaymentLinkDuringCall({\r\n            recipientPhone,\r\n            amount: paymentAmount,\r\n            invoiceReference: invoice?.reference,\r\n            freelancerId: userId,\r\n            invoiceId,\r\n        });\r\n\r\n        if (!result.success) {\r\n            throw new Error(result.error || 'Failed to send payment link');\r\n        }\r\n\r\n        // 8. Record payment link sent in collection attempt\r\n        const attemptsSnapshot = await db\r\n            .collection('collection_attempts')\r\n            .where('callSID', '==', callSid)\r\n            .limit(1)\r\n            .get();\r\n\r\n        if (!attemptsSnapshot.empty) {\r\n            const attemptDoc = attemptsSnapshot.docs[0];\r\n            await attemptDoc.ref.update({\r\n                paymentLinkSentInCall: true,\r\n                paymentMethod: 'sms_link',\r\n                partialAmountAgreed: paymentAmount < invoice?.amount ? paymentAmount : null,\r\n                updatedAt: FieldValue.serverTimestamp(),\r\n            });\r\n        }\r\n\r\n        logInfo('Payment link sent during AI call', {\r\n            invoiceId,\r\n            callSid,\r\n            amount: paymentAmount,\r\n            isPartialPayment: paymentAmount < invoice?.amount,\r\n        });\r\n\r\n        const duration = Date.now() - startTime;\r\n        logApiResponse('POST', '/api/collections/ai-call/send-payment-link', 200, duration, userId);\r\n\r\n        return NextResponse.json({\r\n            success: true,\r\n            message: 'Payment link sent via SMS',\r\n            paymentLink: result.paymentLink,\r\n            amount: paymentAmount,\r\n            isPartialPayment: paymentAmount < invoice?.amount,\r\n            messageSid: result.messageSid,\r\n        });\r\n\r\n    } catch (error: any) {\r\n        const duration = Date.now() - startTime;\r\n        logApiResponse('POST', '/api/collections/ai-call/send-payment-link', error.statusCode || 500, duration);\r\n        return handleApiError(error);\r\n    }\r\n}\r\n","import {\n  AppRouteRouteModule,\n  type AppRouteRouteHandlerContext,\n  type AppRouteRouteModuleOptions,\n} from '../../server/route-modules/app-route/module.compiled'\nimport { RouteKind } from '../../server/route-kind'\nimport { patchFetch as _patchFetch } from '../../server/lib/patch-fetch'\nimport type { IncomingMessage, ServerResponse } from 'node:http'\nimport { addRequestMeta, getRequestMeta } from '../../server/request-meta'\nimport { getTracer, type Span, SpanKind } from '../../server/lib/trace/tracer'\nimport { setReferenceManifestsSingleton } from '../../server/app-render/encryption-utils'\nimport { createServerModuleMap } from '../../server/app-render/action-utils'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { NodeNextRequest, NodeNextResponse } from '../../server/base-http/node'\nimport {\n  NextRequestAdapter,\n  signalFromNodeResponse,\n} from '../../server/web/spec-extension/adapters/next-request'\nimport { BaseServerSpan } from '../../server/lib/trace/constants'\nimport { getRevalidateReason } from '../../server/instrumentation/utils'\nimport { sendResponse } from '../../server/send-response'\nimport {\n  fromNodeOutgoingHttpHeaders,\n  toNodeOutgoingHttpHeaders,\n} from '../../server/web/utils'\nimport { getCacheControlHeader } from '../../server/lib/cache-control'\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from '../../lib/constants'\nimport { NoFallbackError } from '../../shared/lib/no-fallback-error.external'\nimport {\n  CachedRouteKind,\n  type ResponseCacheEntry,\n  type ResponseGenerator,\n} from '../../server/response-cache'\n\nimport * as userland from 'VAR_USERLAND'\n\n// These are injected by the loader afterwards. This is injected as a variable\n// instead of a replacement because this could also be `undefined` instead of\n// an empty string.\ndeclare const nextConfigOutput: AppRouteRouteModuleOptions['nextConfigOutput']\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\n// INJECT:nextConfigOutput\n\nconst routeModule = new AppRouteRouteModule({\n  definition: {\n    kind: RouteKind.APP_ROUTE,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    filename: 'VAR_DEFINITION_FILENAME',\n    bundlePath: 'VAR_DEFINITION_BUNDLE_PATH',\n  },\n  distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n  relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n  resolvedPagePath: 'VAR_RESOLVED_PAGE_PATH',\n  nextConfigOutput,\n  userland,\n})\n\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule\n\nfunction patchFetch() {\n  return _patchFetch({\n    workAsyncStorage,\n    workUnitAsyncStorage,\n  })\n}\n\nexport {\n  routeModule,\n  workAsyncStorage,\n  workUnitAsyncStorage,\n  serverHooks,\n  patchFetch,\n}\n\nexport async function handler(\n  req: IncomingMessage,\n  res: ServerResponse,\n  ctx: {\n    waitUntil: (prom: Promise<void>) => void\n  }\n) {\n  if (routeModule.isDev) {\n    addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint())\n  }\n  let srcPage = 'VAR_DEFINITION_PAGE'\n\n  // turbopack doesn't normalize `/index` in the page name\n  // so we need to to process dynamic routes properly\n  // TODO: fix turbopack providing differing value from webpack\n  if (process.env.TURBOPACK) {\n    srcPage = srcPage.replace(/\\/index$/, '') || '/'\n  } else if (srcPage === '/index') {\n    // we always normalize /index specifically\n    srcPage = '/'\n  }\n  const multiZoneDraftMode = process.env\n    .__NEXT_MULTI_ZONE_DRAFT_MODE as any as boolean\n\n  const prepareResult = await routeModule.prepare(req, res, {\n    srcPage,\n    multiZoneDraftMode,\n  })\n\n  if (!prepareResult) {\n    res.statusCode = 400\n    res.end('Bad Request')\n    ctx.waitUntil?.(Promise.resolve())\n    return null\n  }\n\n  const {\n    buildId,\n    params,\n    nextConfig,\n    parsedUrl,\n    isDraftMode,\n    prerenderManifest,\n    routerServerContext,\n    isOnDemandRevalidate,\n    revalidateOnlyGenerated,\n    resolvedPathname,\n    clientReferenceManifest,\n    serverActionsManifest,\n  } = prepareResult\n\n  const normalizedSrcPage = normalizeAppPath(srcPage)\n\n  let isIsr = Boolean(\n    prerenderManifest.dynamicRoutes[normalizedSrcPage] ||\n      prerenderManifest.routes[resolvedPathname]\n  )\n\n  const render404 = async () => {\n    // TODO: should route-module itself handle rendering the 404\n    if (routerServerContext?.render404) {\n      await routerServerContext.render404(req, res, parsedUrl, false)\n    } else {\n      res.end('This page could not be found')\n    }\n    return null\n  }\n\n  if (isIsr && !isDraftMode) {\n    const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname])\n    const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage]\n\n    if (prerenderInfo) {\n      if (prerenderInfo.fallback === false && !isPrerendered) {\n        if (nextConfig.experimental.adapterPath) {\n          return await render404()\n        }\n        throw new NoFallbackError()\n      }\n    }\n  }\n\n  let cacheKey: string | null = null\n\n  if (isIsr && !routeModule.isDev && !isDraftMode) {\n    cacheKey = resolvedPathname\n    // ensure /index and / is normalized to one key\n    cacheKey = cacheKey === '/index' ? '/' : cacheKey\n  }\n\n  const supportsDynamicResponse: boolean =\n    // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true ||\n    // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr\n\n  // This is a revalidation request if the request is for a static\n  // page and it is not being resumed from a postponed render and\n  // it is not a dynamic RSC request then it is a revalidation\n  // request.\n  const isStaticGeneration = isIsr && !supportsDynamicResponse\n\n  // Before rendering (which initializes component tree modules), we have to\n  // set the reference manifests to our global store so Server Action's\n  // encryption util can access to them at the top level of the page module.\n  if (serverActionsManifest && clientReferenceManifest) {\n    setReferenceManifestsSingleton({\n      page: srcPage,\n      clientReferenceManifest,\n      serverActionsManifest,\n      serverModuleMap: createServerModuleMap({\n        serverActionsManifest,\n      }),\n    })\n  }\n\n  const method = req.method || 'GET'\n  const tracer = getTracer()\n  const activeSpan = tracer.getActiveScopeSpan()\n\n  const context: AppRouteRouteHandlerContext = {\n    params,\n    prerenderManifest,\n    renderOpts: {\n      experimental: {\n        authInterrupts: Boolean(nextConfig.experimental.authInterrupts),\n      },\n      cacheComponents: Boolean(nextConfig.cacheComponents),\n      supportsDynamicResponse,\n      incrementalCache: getRequestMeta(req, 'incrementalCache'),\n      cacheLifeProfiles: nextConfig.cacheLife,\n      waitUntil: ctx.waitUntil,\n      onClose: (cb) => {\n        res.on('close', cb)\n      },\n      onAfterTaskError: undefined,\n      onInstrumentationRequestError: (error, _request, errorContext) =>\n        routeModule.onRequestError(\n          req,\n          error,\n          errorContext,\n          routerServerContext\n        ),\n    },\n    sharedContext: {\n      buildId,\n    },\n  }\n  const nodeNextReq = new NodeNextRequest(req)\n  const nodeNextRes = new NodeNextResponse(res)\n\n  const nextReq = NextRequestAdapter.fromNodeNextRequest(\n    nodeNextReq,\n    signalFromNodeResponse(res)\n  )\n\n  try {\n    const invokeRouteModule = async (span?: Span) => {\n      return routeModule.handle(nextReq, context).finally(() => {\n        if (!span) return\n\n        span.setAttributes({\n          'http.status_code': res.statusCode,\n          'next.rsc': false,\n        })\n\n        const rootSpanAttributes = tracer.getRootSpanAttributes()\n        // We were unable to get attributes, probably OTEL is not enabled\n        if (!rootSpanAttributes) {\n          return\n        }\n\n        if (\n          rootSpanAttributes.get('next.span_type') !==\n          BaseServerSpan.handleRequest\n        ) {\n          console.warn(\n            `Unexpected root span type '${rootSpanAttributes.get(\n              'next.span_type'\n            )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n          )\n          return\n        }\n\n        const route = rootSpanAttributes.get('next.route')\n        if (route) {\n          const name = `${method} ${route}`\n\n          span.setAttributes({\n            'next.route': route,\n            'http.route': route,\n            'next.span_name': name,\n          })\n          span.updateName(name)\n        } else {\n          span.updateName(`${method} ${srcPage}`)\n        }\n      })\n    }\n    const isMinimalMode = Boolean(\n      process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode')\n    )\n\n    const handleResponse = async (currentSpan?: Span) => {\n      const responseGenerator: ResponseGenerator = async ({\n        previousCacheEntry,\n      }) => {\n        try {\n          if (\n            !isMinimalMode &&\n            isOnDemandRevalidate &&\n            revalidateOnlyGenerated &&\n            !previousCacheEntry\n          ) {\n            res.statusCode = 404\n            // on-demand revalidate always sets this header\n            res.setHeader('x-nextjs-cache', 'REVALIDATED')\n            res.end('This page could not be found')\n            return null\n          }\n\n          const response = await invokeRouteModule(currentSpan)\n\n          ;(req as any).fetchMetrics = (context.renderOpts as any).fetchMetrics\n          let pendingWaitUntil = context.renderOpts.pendingWaitUntil\n\n          // Attempt using provided waitUntil if available\n          // if it's not we fallback to sendResponse's handling\n          if (pendingWaitUntil) {\n            if (ctx.waitUntil) {\n              ctx.waitUntil(pendingWaitUntil)\n              pendingWaitUntil = undefined\n            }\n          }\n          const cacheTags = context.renderOpts.collectedTags\n\n          // If the request is for a static response, we can cache it so long\n          // as it's not edge.\n          if (isIsr) {\n            const blob = await response.blob()\n\n            // Copy the headers from the response.\n            const headers = toNodeOutgoingHttpHeaders(response.headers)\n\n            if (cacheTags) {\n              headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n            }\n\n            if (!headers['content-type'] && blob.type) {\n              headers['content-type'] = blob.type\n            }\n\n            const revalidate =\n              typeof context.renderOpts.collectedRevalidate === 'undefined' ||\n              context.renderOpts.collectedRevalidate >= INFINITE_CACHE\n                ? false\n                : context.renderOpts.collectedRevalidate\n\n            const expire =\n              typeof context.renderOpts.collectedExpire === 'undefined' ||\n              context.renderOpts.collectedExpire >= INFINITE_CACHE\n                ? undefined\n                : context.renderOpts.collectedExpire\n\n            // Create the cache entry for the response.\n            const cacheEntry: ResponseCacheEntry = {\n              value: {\n                kind: CachedRouteKind.APP_ROUTE,\n                status: response.status,\n                body: Buffer.from(await blob.arrayBuffer()),\n                headers,\n              },\n              cacheControl: { revalidate, expire },\n            }\n\n            return cacheEntry\n          } else {\n            // send response without caching if not ISR\n            await sendResponse(\n              nodeNextReq,\n              nodeNextRes,\n              response,\n              context.renderOpts.pendingWaitUntil\n            )\n            return null\n          }\n        } catch (err) {\n          // if this is a background revalidate we need to report\n          // the request error here as it won't be bubbled\n          if (previousCacheEntry?.isStale) {\n            await routeModule.onRequestError(\n              req,\n              err,\n              {\n                routerKind: 'App Router',\n                routePath: srcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                  isStaticGeneration,\n                  isOnDemandRevalidate,\n                }),\n              },\n              routerServerContext\n            )\n          }\n          throw err\n        }\n      }\n\n      const cacheEntry = await routeModule.handleResponse({\n        req,\n        nextConfig,\n        cacheKey,\n        routeKind: RouteKind.APP_ROUTE,\n        isFallback: false,\n        prerenderManifest,\n        isRoutePPREnabled: false,\n        isOnDemandRevalidate,\n        revalidateOnlyGenerated,\n        responseGenerator,\n        waitUntil: ctx.waitUntil,\n        isMinimalMode,\n      })\n\n      // we don't create a cacheEntry for ISR\n      if (!isIsr) {\n        return null\n      }\n\n      if (cacheEntry?.value?.kind !== CachedRouteKind.APP_ROUTE) {\n        throw new Error(\n          `Invariant: app-route received invalid cache entry ${cacheEntry?.value?.kind}`\n        )\n      }\n\n      if (!isMinimalMode) {\n        res.setHeader(\n          'x-nextjs-cache',\n          isOnDemandRevalidate\n            ? 'REVALIDATED'\n            : cacheEntry.isMiss\n              ? 'MISS'\n              : cacheEntry.isStale\n                ? 'STALE'\n                : 'HIT'\n        )\n      }\n\n      // Draft mode should never be cached\n      if (isDraftMode) {\n        res.setHeader(\n          'Cache-Control',\n          'private, no-cache, no-store, max-age=0, must-revalidate'\n        )\n      }\n\n      const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers)\n\n      if (!(isMinimalMode && isIsr)) {\n        headers.delete(NEXT_CACHE_TAGS_HEADER)\n      }\n\n      // If cache control is already set on the response we don't\n      // override it to allow users to customize it via next.config\n      if (\n        cacheEntry.cacheControl &&\n        !res.getHeader('Cache-Control') &&\n        !headers.get('Cache-Control')\n      ) {\n        headers.set(\n          'Cache-Control',\n          getCacheControlHeader(cacheEntry.cacheControl)\n        )\n      }\n\n      await sendResponse(\n        nodeNextReq,\n        nodeNextRes,\n        // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n        new Response(cacheEntry.value.body, {\n          headers,\n          status: cacheEntry.value.status || 200,\n        })\n      )\n      return null\n    }\n\n    // TODO: activeSpan code path is for when wrapped by\n    // next-server can be removed when this is no longer used\n    if (activeSpan) {\n      await handleResponse(activeSpan)\n    } else {\n      await tracer.withPropagatedContext(req.headers, () =>\n        tracer.trace(\n          BaseServerSpan.handleRequest,\n          {\n            spanName: `${method} ${srcPage}`,\n            kind: SpanKind.SERVER,\n            attributes: {\n              'http.method': method,\n              'http.target': req.url,\n            },\n          },\n          handleResponse\n        )\n      )\n    }\n  } catch (err) {\n    if (!(err instanceof NoFallbackError)) {\n      await routeModule.onRequestError(req, err, {\n        routerKind: 'App Router',\n        routePath: normalizedSrcPage,\n        routeType: 'route',\n        revalidateReason: getRevalidateReason({\n          isStaticGeneration,\n          isOnDemandRevalidate,\n        }),\n      })\n    }\n\n    // rethrow so that we can handle serving error page\n\n    // If this is during static generation, throw the error again.\n    if (isIsr) throw err\n\n    // Otherwise, send a 500 response.\n    await sendResponse(\n      nodeNextReq,\n      nodeNextRes,\n      new Response(null, { status: 500 })\n    )\n    return null\n  }\n}\n"],"names":["AppRouteRouteModule","RouteKind","patchFetch","_patchFetch","addRequestMeta","getRequestMeta","getTracer","SpanKind","setReferenceManifestsSingleton","createServerModuleMap","normalizeAppPath","NodeNextRequest","NodeNextResponse","NextRequestAdapter","signalFromNodeResponse","BaseServerSpan","getRevalidateReason","sendResponse","fromNodeOutgoingHttpHeaders","toNodeOutgoingHttpHeaders","getCacheControlHeader","INFINITE_CACHE","NEXT_CACHE_TAGS_HEADER","NoFallbackError","CachedRouteKind","userland","routeModule","definition","kind","APP_ROUTE","page","pathname","filename","bundlePath","distDir","process","env","__NEXT_RELATIVE_DIST_DIR","relativeProjectDir","__NEXT_RELATIVE_PROJECT_DIR","resolvedPagePath","nextConfigOutput","workAsyncStorage","workUnitAsyncStorage","serverHooks","handler","req","res","ctx","isDev","hrtime","bigint","srcPage","TURBOPACK","replace","multiZoneDraftMode","__NEXT_MULTI_ZONE_DRAFT_MODE","prepareResult","prepare","statusCode","end","waitUntil","Promise","resolve","buildId","params","nextConfig","parsedUrl","isDraftMode","prerenderManifest","routerServerContext","isOnDemandRevalidate","revalidateOnlyGenerated","resolvedPathname","clientReferenceManifest","serverActionsManifest","normalizedSrcPage","isIsr","Boolean","dynamicRoutes","routes","render404","isPrerendered","prerenderInfo","fallback","experimental","adapterPath","cacheKey","supportsDynamicResponse","isStaticGeneration","serverModuleMap","method","tracer","activeSpan","getActiveScopeSpan","context","renderOpts","authInterrupts","cacheComponents","incrementalCache","cacheLifeProfiles","cacheLife","onClose","cb","on","onAfterTaskError","undefined","onInstrumentationRequestError","error","_request","errorContext","onRequestError","sharedContext","nodeNextReq","nodeNextRes","nextReq","fromNodeNextRequest","invokeRouteModule","span","handle","finally","setAttributes","rootSpanAttributes","getRootSpanAttributes","get","handleRequest","console","warn","route","name","updateName","isMinimalMode","MINIMAL_MODE","handleResponse","currentSpan","cacheEntry","responseGenerator","previousCacheEntry","setHeader","response","fetchMetrics","pendingWaitUntil","cacheTags","collectedTags","blob","headers","type","revalidate","collectedRevalidate","expire","collectedExpire","value","status","body","Buffer","from","arrayBuffer","cacheControl","err","isStale","routerKind","routePath","routeType","revalidateReason","routeKind","isFallback","isRoutePPREnabled","Error","isMiss","delete","getHeader","set","Response","withPropagatedContext","trace","spanName","SERVER","attributes","url"],"mappings":"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","ignoreList":[1,5]}