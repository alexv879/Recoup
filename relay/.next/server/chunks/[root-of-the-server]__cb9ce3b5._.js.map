{"version":3,"sources":["../../../services/transactionService.ts","../../../lib/firebase-storage.ts","../../../services/agencyHandoffService.ts"],"sourcesContent":["/**\n * Transaction Service\n * AUDIT TASK #6: Payment transaction tracking for agency recoveries\n *\n * Manages financial transactions including:\n * - Agency commission calculations\n * - Net payments to freelancers\n * - Transaction history and audit trail\n * - Payment reconciliation\n *\n * Transaction Types:\n * - agency_recovery: Payment recovered by collection agency\n * - direct_payment: Direct payment from client to freelancer\n * - refund: Payment reversal\n */\n\nimport { db, Timestamp, FieldValue } from '@/lib/firebase';\nimport { logInfo, logError, logDbOperation } from '@/utils/logger';\nimport { nanoid } from 'nanoid';\n\n/**\n * Agency Recovery Transaction\n * Tracks commission split and net payment\n */\nexport interface AgencyRecoveryTransaction {\n  transactionId: string;\n  transactionType: 'agency_recovery';\n\n  // References\n  invoiceId: string;\n  freelancerId: string;\n  agencyHandoffId: string;\n  agencyId: string;\n\n  // Amounts (in GBP)\n  grossAmount: number; // Total amount recovered\n  agencyCommissionRate: number; // e.g., 0.25 for 25%\n  agencyCommissionAmount: number; // Calculated commission\n  netToFreelancer: number; // Amount after commission\n\n  // Status\n  status: 'pending' | 'processing' | 'completed' | 'failed';\n\n  // Payment Details\n  paymentMethod?: 'bank_transfer' | 'check' | 'stripe';\n  expectedPaymentDate?: Timestamp;\n  actualPaymentDate?: Timestamp;\n\n  // Banking/Transfer Info\n  transferReference?: string;\n  bankTransactionId?: string;\n\n  // Metadata\n  notes?: string;\n  processedBy?: string; // Admin user who processed\n\n  // Timestamps\n  createdAt: Timestamp;\n  updatedAt?: Timestamp;\n  completedAt?: Timestamp;\n}\n\n/**\n * Create transaction record for agency recovery\n *\n * @param params Transaction parameters\n * @returns Transaction ID\n */\nexport async function createAgencyRecoveryTransaction(params: {\n  invoiceId: string;\n  freelancerId: string;\n  agencyHandoffId: string;\n  agencyId: string;\n  grossAmount: number;\n  agencyCommissionRate: number;\n  notes?: string;\n}): Promise<{\n  success: boolean;\n  transactionId?: string;\n  error?: string;\n}> {\n  const startTime = Date.now();\n\n  try {\n    // Calculate commission and net amount\n    const agencyCommissionAmount = params.grossAmount * params.agencyCommissionRate;\n    const netToFreelancer = params.grossAmount - agencyCommissionAmount;\n\n    // Create transaction document\n    const transactionRef = db.collection('payment_transactions').doc();\n    const transaction: AgencyRecoveryTransaction = {\n      transactionId: transactionRef.id,\n      transactionType: 'agency_recovery',\n\n      invoiceId: params.invoiceId,\n      freelancerId: params.freelancerId,\n      agencyHandoffId: params.agencyHandoffId,\n      agencyId: params.agencyId,\n\n      grossAmount: params.grossAmount,\n      agencyCommissionRate: params.agencyCommissionRate,\n      agencyCommissionAmount,\n      netToFreelancer,\n\n      status: 'pending',\n      notes: params.notes,\n\n      createdAt: Timestamp.now(),\n    };\n\n    await transactionRef.set(transaction);\n\n    logDbOperation('create_agency_recovery_transaction', 'payment_transactions', transactionRef.id, Date.now() - startTime);\n\n    logInfo('Agency recovery transaction created', {\n      transactionId: transactionRef.id,\n      invoiceId: params.invoiceId,\n      grossAmount: params.grossAmount,\n      netToFreelancer,\n    });\n\n    return {\n      success: true,\n      transactionId: transactionRef.id,\n    };\n\n  } catch (error) {\n    logError('Failed to create agency recovery transaction', error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error',\n    };\n  }\n}\n\n/**\n * Update transaction status\n *\n * @param transactionId Transaction ID\n * @param status New status\n * @param metadata Additional metadata to update\n */\nexport async function updateTransactionStatus(\n  transactionId: string,\n  status: 'pending' | 'processing' | 'completed' | 'failed',\n  metadata?: {\n    transferReference?: string;\n    bankTransactionId?: string;\n    actualPaymentDate?: Date;\n    processedBy?: string;\n    notes?: string;\n  }\n): Promise<{\n  success: boolean;\n  error?: string;\n}> {\n  const startTime = Date.now();\n\n  try {\n    const updateData: any = {\n      status,\n      updatedAt: Timestamp.now(),\n    };\n\n    if (metadata) {\n      if (metadata.transferReference) updateData.transferReference = metadata.transferReference;\n      if (metadata.bankTransactionId) updateData.bankTransactionId = metadata.bankTransactionId;\n      if (metadata.actualPaymentDate) updateData.actualPaymentDate = Timestamp.fromDate(metadata.actualPaymentDate);\n      if (metadata.processedBy) updateData.processedBy = metadata.processedBy;\n      if (metadata.notes) updateData.notes = metadata.notes;\n    }\n\n    if (status === 'completed') {\n      updateData.completedAt = Timestamp.now();\n    }\n\n    await db.collection('payment_transactions').doc(transactionId).update(updateData);\n\n    logDbOperation('update_transaction_status', 'payment_transactions', transactionId, Date.now() - startTime);\n\n    logInfo('Transaction status updated', {\n      transactionId,\n      status,\n    });\n\n    return { success: true };\n\n  } catch (error) {\n    logError('Failed to update transaction status', error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error',\n    };\n  }\n}\n\n/**\n * Get transaction details\n *\n * @param transactionId Transaction ID\n */\nexport async function getTransaction(\n  transactionId: string\n): Promise<AgencyRecoveryTransaction | null> {\n  const startTime = Date.now();\n\n  try {\n    const doc = await db.collection('payment_transactions').doc(transactionId).get();\n\n    logDbOperation('get_transaction', 'payment_transactions', transactionId, Date.now() - startTime);\n\n    if (!doc.exists) {\n      return null;\n    }\n\n    return doc.data() as AgencyRecoveryTransaction;\n\n  } catch (error) {\n    logError('Failed to get transaction', error);\n    return null;\n  }\n}\n\n/**\n * Get all transactions for a freelancer\n *\n * @param freelancerId Freelancer user ID\n * @param limit Maximum number of transactions to return\n */\nexport async function getFreelancerTransactions(\n  freelancerId: string,\n  limit = 50\n): Promise<AgencyRecoveryTransaction[]> {\n  const startTime = Date.now();\n\n  try {\n    const snapshot = await db\n      .collection('payment_transactions')\n      .where('freelancerId', '==', freelancerId)\n      .orderBy('createdAt', 'desc')\n      .limit(limit)\n      .get();\n\n    logDbOperation('get_freelancer_transactions', 'payment_transactions', undefined, Date.now() - startTime);\n\n    return snapshot.docs.map(doc => doc.data() as AgencyRecoveryTransaction);\n\n  } catch (error) {\n    logError('Failed to get freelancer transactions', error);\n    return [];\n  }\n}\n\n/**\n * Get transactions for an agency handoff\n *\n * @param agencyHandoffId Agency handoff ID\n */\nexport async function getHandoffTransactions(\n  agencyHandoffId: string\n): Promise<AgencyRecoveryTransaction[]> {\n  const startTime = Date.now();\n\n  try {\n    const snapshot = await db\n      .collection('payment_transactions')\n      .where('agencyHandoffId', '==', agencyHandoffId)\n      .orderBy('createdAt', 'desc')\n      .get();\n\n    logDbOperation('get_handoff_transactions', 'payment_transactions', undefined, Date.now() - startTime);\n\n    return snapshot.docs.map(doc => doc.data() as AgencyRecoveryTransaction);\n\n  } catch (error) {\n    logError('Failed to get handoff transactions', error);\n    return [];\n  }\n}\n\n/**\n * Calculate total recovered amount for a freelancer\n *\n * @param freelancerId Freelancer user ID\n */\nexport async function calculateFreelancerRecoveries(\n  freelancerId: string\n): Promise<{\n  totalRecovered: number;\n  totalCommission: number;\n  totalNet: number;\n  transactionCount: number;\n}> {\n  try {\n    const transactions = await getFreelancerTransactions(freelancerId, 1000);\n\n    const completed = transactions.filter(t => t.status === 'completed');\n\n    const totalRecovered = completed.reduce((sum, t) => sum + t.grossAmount, 0);\n    const totalCommission = completed.reduce((sum, t) => sum + t.agencyCommissionAmount, 0);\n    const totalNet = completed.reduce((sum, t) => sum + t.netToFreelancer, 0);\n\n    return {\n      totalRecovered,\n      totalCommission,\n      totalNet,\n      transactionCount: completed.length,\n    };\n\n  } catch (error) {\n    logError('Failed to calculate freelancer recoveries', error);\n    return {\n      totalRecovered: 0,\n      totalCommission: 0,\n      totalNet: 0,\n      transactionCount: 0,\n    };\n  }\n}\n","/**\n * Firebase Storage Service\n * AUDIT TASK #5: Cloud document storage for agency handoff cases\n *\n * Handles upload and retrieval of:\n * - Invoice PDFs\n * - Communication history documents\n * - Supporting evidence for collection cases\n *\n * Security:\n * - All uploads are scoped to userId/handoffId for isolation\n * - Signed URLs expire after configurable time (default: 1 hour)\n * - Only authorized users (freelancer, agency, admin) can access\n */\n\nimport { getStorage } from 'firebase-admin/storage';\nimport { getApps } from 'firebase-admin/app';\nimport { logInfo, logError } from '@/utils/logger';\n\n/**\n * Get Firebase Storage bucket\n * Uses default bucket from Firebase project\n */\nfunction getStorageBucket() {\n  if (!getApps().length) {\n    throw new Error('Firebase is not initialized');\n  }\n\n  const storage = getStorage();\n  const bucketName = process.env.FIREBASE_STORAGE_BUCKET || `${process.env.FIREBASE_PROJECT_ID}.appspot.com`;\n  return storage.bucket(bucketName);\n}\n\n/**\n * Upload document to Firebase Storage\n *\n * @param params Upload parameters\n * @returns Public URL and storage path\n */\nexport async function uploadDocument(params: {\n  fileBuffer: Buffer;\n  fileName: string;\n  contentType: string;\n  handoffId: string;\n  freelancerId: string;\n  documentType: 'invoice' | 'communication' | 'evidence';\n}): Promise<{\n  success: boolean;\n  storagePath?: string;\n  publicUrl?: string;\n  error?: string;\n}> {\n  try {\n    const { fileBuffer, fileName, contentType, handoffId, freelancerId, documentType } = params;\n\n    // Construct storage path: documents/{freelancerId}/{handoffId}/{documentType}/{fileName}\n    const storagePath = `documents/${freelancerId}/${handoffId}/${documentType}/${fileName}`;\n\n    const bucket = getStorageBucket();\n    const file = bucket.file(storagePath);\n\n    // Upload file with metadata\n    await file.save(fileBuffer, {\n      contentType,\n      metadata: {\n        handoffId,\n        freelancerId,\n        documentType,\n        uploadedAt: new Date().toISOString(),\n      },\n    });\n\n    logInfo('Document uploaded to Firebase Storage', {\n      storagePath,\n      fileName,\n      handoffId,\n      documentType,\n    });\n\n    // Make file publicly readable (could be restricted with Firebase rules)\n    await file.makePublic();\n\n    const publicUrl = `https://storage.googleapis.com/${bucket.name}/${storagePath}`;\n\n    return {\n      success: true,\n      storagePath,\n      publicUrl,\n    };\n\n  } catch (error) {\n    logError('Failed to upload document to Firebase Storage', error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error',\n    };\n  }\n}\n\n/**\n * Generate signed URL for secure document access\n *\n * Use this instead of public URLs for sensitive documents\n *\n * @param storagePath Path to file in storage\n * @param expiresInMinutes How long the URL should be valid (default: 60 minutes)\n * @returns Signed URL\n */\nexport async function getSignedUrl(\n  storagePath: string,\n  expiresInMinutes = 60\n): Promise<{\n  success: boolean;\n  signedUrl?: string;\n  expiresAt?: Date;\n  error?: string;\n}> {\n  try {\n    const bucket = getStorageBucket();\n    const file = bucket.file(storagePath);\n\n    // Check if file exists\n    const [exists] = await file.exists();\n    if (!exists) {\n      return {\n        success: false,\n        error: 'File not found',\n      };\n    }\n\n    const expiresAt = new Date();\n    expiresAt.setMinutes(expiresAt.getMinutes() + expiresInMinutes);\n\n    // Generate signed URL\n    const [signedUrl] = await file.getSignedUrl({\n      action: 'read',\n      expires: expiresAt,\n    });\n\n    logInfo('Generated signed URL', {\n      storagePath,\n      expiresAt: expiresAt.toISOString(),\n    });\n\n    return {\n      success: true,\n      signedUrl,\n      expiresAt,\n    };\n\n  } catch (error) {\n    logError('Failed to generate signed URL', error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error',\n    };\n  }\n}\n\n/**\n * Delete document from storage\n * Used for GDPR compliance and cleanup\n *\n * @param storagePath Path to file in storage\n */\nexport async function deleteDocument(storagePath: string): Promise<{\n  success: boolean;\n  error?: string;\n}> {\n  try {\n    const bucket = getStorageBucket();\n    const file = bucket.file(storagePath);\n\n    // Check if file exists before deleting\n    const [exists] = await file.exists();\n    if (!exists) {\n      logInfo('Document already deleted or does not exist', { storagePath });\n      return { success: true };\n    }\n\n    await file.delete();\n\n    logInfo('Document deleted from Firebase Storage', { storagePath });\n\n    return { success: true };\n\n  } catch (error) {\n    logError('Failed to delete document from Firebase Storage', error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error',\n    };\n  }\n}\n\n/**\n * List all documents for a handoff case\n *\n * @param handoffId Agency handoff ID\n * @param freelancerId Freelancer user ID\n */\nexport async function listHandoffDocuments(\n  handoffId: string,\n  freelancerId: string\n): Promise<{\n  success: boolean;\n  documents?: Array<{\n    name: string;\n    storagePath: string;\n    contentType: string;\n    size: number;\n    uploadedAt: Date;\n    documentType: string;\n  }>;\n  error?: string;\n}> {\n  try {\n    const bucket = getStorageBucket();\n    const prefix = `documents/${freelancerId}/${handoffId}/`;\n\n    const [files] = await bucket.getFiles({ prefix });\n\n    const documents = files.map((file) => ({\n      name: file.name.split('/').pop() || file.name,\n      storagePath: file.name,\n      contentType: file.metadata.contentType || 'application/octet-stream',\n      size: parseInt(String(file.metadata.size || '0'), 10),\n      uploadedAt: new Date(file.metadata.timeCreated || Date.now()),\n      documentType: String(file.metadata.metadata?.documentType || 'unknown'),\n    }));\n\n    logInfo('Listed handoff documents', {\n      handoffId,\n      freelancerId,\n      documentCount: documents.length,\n    });\n\n    return {\n      success: true,\n      documents,\n    };\n\n  } catch (error) {\n    logError('Failed to list handoff documents', error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error',\n    };\n  }\n}\n\n/**\n * Upload invoice PDF for handoff case\n * Convenience wrapper for invoice uploads\n */\nexport async function uploadInvoicePDF(params: {\n  pdfBuffer: Buffer;\n  invoiceReference: string;\n  handoffId: string;\n  freelancerId: string;\n}): Promise<{\n  success: boolean;\n  storagePath?: string;\n  publicUrl?: string;\n  error?: string;\n}> {\n  const fileName = `invoice-${params.invoiceReference}.pdf`;\n\n  return uploadDocument({\n    fileBuffer: params.pdfBuffer,\n    fileName,\n    contentType: 'application/pdf',\n    handoffId: params.handoffId,\n    freelancerId: params.freelancerId,\n    documentType: 'invoice',\n  });\n}\n\n/**\n * Upload communication history document\n * Can be PDF, text, or JSON format\n */\nexport async function uploadCommunicationHistory(params: {\n  contentBuffer: Buffer;\n  fileName: string;\n  contentType: string;\n  handoffId: string;\n  freelancerId: string;\n}): Promise<{\n  success: boolean;\n  storagePath?: string;\n  publicUrl?: string;\n  error?: string;\n}> {\n  return uploadDocument({\n    fileBuffer: params.contentBuffer,\n    fileName: params.fileName,\n    contentType: params.contentType,\n    handoffId: params.handoffId,\n    freelancerId: params.freelancerId,\n    documentType: 'communication',\n  });\n}\n","/**\n * PREMIUM FEATURE: Agency Hand-off Service\n *\n * Manages escalation of difficult collections to third-party agencies.\n * When internal collection attempts fail, freelancers can escalate to\n * professional collection agencies with established agreements.\n *\n * Flow:\n * 1. Freelancer decides to escalate after X failed attempts\n * 2. System packages all evidence (invoices, communications, proofs)\n * 3. Creates handoff record with agency\n * 4. Agency receives case and begins their process\n * 5. System tracks agency progress and outcomes\n * 6. If recovered, commission is calculated and paid\n *\n * UK Collection Agency Regulations:\n * - Agencies must be licensed by FCA (Financial Conduct Authority)\n * - Must comply with Consumer Credit Act\n * - Must follow FCA debt collection rules\n * - Cannot harass or threaten debtors\n * - Must verify debt before collection\n * - Typical commission: 10-40% depending on age and amount\n */\n\nimport { db, FieldValue, Timestamp } from '@/lib/firebase';\nimport { AgencyHandoff, Invoice, CollectionAttempt } from '@/types/models';\nimport { logError, logInfo } from '@/utils/logger';\nimport { sendNotificationEmail } from '@/lib/sendgrid';\nimport { nanoid } from 'nanoid';\nimport { uploadCommunicationHistory } from '@/lib/firebase-storage';\nimport { createAgencyRecoveryTransaction } from './transactionService';\n\n/**\n * Registered collection agencies\n * In production, maintain database of vetted agencies\n */\nconst REGISTERED_AGENCIES = [\n  {\n    agencyId: 'agency_lowell_uk',\n    agencyName: 'Lowell Financial Ltd',\n    agencyContactEmail: 'handoffs@lowellfinancial.co.uk',\n    agencyContactPhone: '+44 113 281 8820',\n    commissionPercentage: 25, // 25%\n    minimumDebtAmount: 100, // £100 minimum\n    specialties: ['consumer', 'small_business'],\n  },\n  {\n    agencyId: 'agency_cabot_uk',\n    agencyName: 'Cabot Credit Management',\n    agencyContactEmail: 'newcases@cabotcm.co.uk',\n    agencyContactPhone: '+44 113 234 5678',\n    commissionPercentage: 30, // 30%\n    minimumDebtAmount: 250,\n    specialties: ['consumer', 'high_value'],\n  },\n  {\n    agencyId: 'agency_intrum_uk',\n    agencyName: 'Intrum UK',\n    agencyContactEmail: 'uk.handoffs@intrum.com',\n    agencyContactPhone: '+44 161 923 4000',\n    commissionPercentage: 20, // 20% (lower but high volume)\n    minimumDebtAmount: 50,\n    specialties: ['consumer', 'small_business', 'international'],\n  },\n];\n\n/**\n * Check if invoice is eligible for agency escalation\n */\nexport async function checkEscalationEligibility(invoiceId: string): Promise<{\n  eligible: boolean;\n  reason?: string;\n  recommendedAgency?: string;\n}> {\n  try {\n    // 1. Get invoice\n    const invoiceDoc = await db.collection('invoices').doc(invoiceId).get();\n    if (!invoiceDoc.exists) {\n      return { eligible: false, reason: 'Invoice not found' };\n    }\n\n    const invoice = invoiceDoc.data() as Invoice;\n\n    // 2. Check status\n    if (invoice.status === 'paid') {\n      return { eligible: false, reason: 'Invoice already paid' };\n    }\n\n    if (invoice.status === 'in_collections') {\n      // Check if already escalated\n      const existingHandoff = await db\n        .collection('agency_handoffs')\n        .where('invoiceId', '==', invoiceId)\n        .where('handoffStatus', 'in', ['pending', 'in_progress'])\n        .get();\n\n      if (!existingHandoff.empty) {\n        return { eligible: false, reason: 'Already escalated to agency' };\n      }\n    }\n\n    // 3. Check minimum amount\n    if (invoice.amount < 50) {\n      return { eligible: false, reason: 'Amount too low for agency escalation (minimum £50)' };\n    }\n\n    // 4. Check collection attempts\n    const attempts = await db\n      .collection('collection_attempts')\n      .where('invoiceId', '==', invoiceId)\n      .orderBy('createdAt', 'desc')\n      .get();\n\n    if (attempts.size < 3) {\n      return { eligible: false, reason: 'Insufficient collection attempts (minimum 3 required)' };\n    }\n\n    // 5. Check days past due\n    const daysPastDue = Math.floor(\n      (Date.now() - invoice.dueDate.toMillis()) / (1000 * 60 * 60 * 24)\n    );\n\n    if (daysPastDue < 60) {\n      return { eligible: false, reason: 'Not enough time passed (minimum 60 days overdue)' };\n    }\n\n    // 6. Recommend agency based on amount\n    let recommendedAgency = 'agency_intrum_uk'; // Default\n\n    if (invoice.amount >= 250) {\n      recommendedAgency = 'agency_cabot_uk'; // Higher value\n    } else if (invoice.amount >= 100) {\n      recommendedAgency = 'agency_lowell_uk'; // Medium value\n    }\n\n    return {\n      eligible: true,\n      recommendedAgency,\n    };\n\n  } catch (error) {\n    logError('Failed to check escalation eligibility', error);\n    return { eligible: false, reason: 'System error' };\n  }\n}\n\n/**\n * Create agency handoff\n */\nexport async function createAgencyHandoff(params: {\n  invoiceId: string;\n  freelancerId: string;\n  agencyId: string;\n  notes?: string;\n}): Promise<{\n  success: boolean;\n  handoffId?: string;\n  error?: string;\n}> {\n  try {\n    // 1. Validate eligibility\n    const eligibility = await checkEscalationEligibility(params.invoiceId);\n    if (!eligibility.eligible) {\n      return {\n        success: false,\n        error: eligibility.reason || 'Not eligible for escalation',\n      };\n    }\n\n    // 2. Get invoice and collection history\n    const invoiceDoc = await db.collection('invoices').doc(params.invoiceId).get();\n    const invoice = invoiceDoc.data() as Invoice;\n\n    const attemptsSnapshot = await db\n      .collection('collection_attempts')\n      .where('invoiceId', '==', params.invoiceId)\n      .orderBy('createdAt', 'desc')\n      .get();\n\n    const attempts = attemptsSnapshot.docs.map(doc => doc.data() as CollectionAttempt);\n\n    // 3. Get agency details\n    const agency = REGISTERED_AGENCIES.find(a => a.agencyId === params.agencyId);\n    if (!agency) {\n      return { success: false, error: 'Agency not found' };\n    }\n\n    // 4. Check minimum amount\n    if (invoice.amount < agency.minimumDebtAmount) {\n      return {\n        success: false,\n        error: `Amount below agency minimum (£${agency.minimumDebtAmount})`,\n      };\n    }\n\n    // 5. Calculate days past due\n    const daysPastDue = Math.floor(\n      (Date.now() - invoice.dueDate.toMillis()) / (1000 * 60 * 60 * 24)\n    );\n\n    // 6. Build communication history for agency\n    // Map attemptType to simplified communication type\n    const communicationHistory = attempts.map(attempt => {\n      let commType: 'email' | 'sms' | 'call' | 'letter' = 'email';\n\n      if (attempt.attemptType === 'sms_reminder') commType = 'sms';\n      else if (attempt.attemptType === 'physical_letter') commType = 'letter';\n      else if (attempt.attemptType === 'ai_call') commType = 'call';\n      else commType = 'email'; // email_reminder, manual_contact, payment_received default to email\n\n      return {\n        date: attempt.createdAt,\n        type: commType,\n        summary: `${attempt.attemptType}: ${attempt.result}${attempt.resultDetails ? ' - ' + attempt.resultDetails : ''}`,\n      };\n    });\n\n    // 7. Create handoff document\n    const handoffRef = db.collection('agency_handoffs').doc();\n    const handoff: AgencyHandoff = {\n      handoffId: handoffRef.id,\n      invoiceId: params.invoiceId,\n      freelancerId: params.freelancerId,\n      agencyId: params.agencyId,\n      handoffDate: FieldValue.serverTimestamp() as any,\n      handoffStatus: 'pending',\n\n      // Agency info\n      agencyName: agency.agencyName,\n      agencyContactEmail: agency.agencyContactEmail,\n      agencyContactPhone: agency.agencyContactPhone,\n\n      // Invoice details\n      originalAmount: invoice.amount,\n      outstandingAmount: invoice.amount, // Assuming no partial payments yet\n      daysPastDue,\n\n      // Documents & Evidence\n      documents: [], // TODO: Upload invoice PDFs, comms to cloud storage\n      communicationHistory,\n\n      // Financial terms\n      commissionPercentage: agency.commissionPercentage,\n\n      // Notes\n      notes: params.notes,\n\n      // Status updates\n      agencyUpdates: [],\n\n      // Timestamps\n      createdAt: FieldValue.serverTimestamp() as any,\n    };\n\n    await handoffRef.set(handoff);\n\n    // 8. Update invoice status\n    await db.collection('invoices').doc(params.invoiceId).update({\n      status: 'in_collections',\n      updatedAt: FieldValue.serverTimestamp(),\n    });\n\n    // 9. Create collection attempt record\n    const attemptRef = db.collection('collection_attempts').doc();\n    await attemptRef.set({\n      attemptId: attemptRef.id,\n      invoiceId: params.invoiceId,\n      freelancerId: params.freelancerId,\n      attemptType: 'manual_contact',\n      attemptDate: FieldValue.serverTimestamp(),\n      attemptNumber: attempts.length + 1,\n      result: 'pending',\n      resultDetails: `Escalated to ${agency.agencyName}`,\n      escalatedToAgency: true,\n      agencyHandoffId: handoffRef.id,\n      escalationDate: FieldValue.serverTimestamp(),\n      isPremiumFeature: true,\n      createdAt: FieldValue.serverTimestamp(),\n    });\n\n    // AUDIT TASK #4: Send notifications for agency handoff\n    try {\n      // 1. Notify agency via email\n      await sendNotificationEmail({\n        toEmail: agency.agencyContactEmail,\n        subject: `New Collection Case: ${invoice.reference} - £${invoice.amount.toFixed(2)}`,\n        message: `A new collection case has been assigned to ${agency.agencyName}.\n\n**Invoice Details:**\n- Invoice Number: ${invoice.reference}\n- Client: ${invoice.clientName}\n- Amount: £${invoice.amount.toFixed(2)}\n- Days Past Due: ${daysPastDue}\n- Original Invoice Date: ${invoice.invoiceDate.toDate().toLocaleDateString()}\n\n**Case Summary:**\n${communicationHistory.length} collection attempts have been made:\n${communicationHistory.slice(0, 5).map((comm: any) => `- ${comm.type}: ${comm.summary}`).join('\\n')}\n\n**Next Steps:**\n1. Review the case details in your agency portal\n2. Download supporting documents (invoice PDFs, communication history)\n3. Begin collection process per your standard procedures\n\nCommission: ${agency.commissionPercentage}% of recovered amount\n\nCase ID: ${handoffRef.id}`,\n        actionUrl: `${process.env.NEXT_PUBLIC_APP_URL}/agency/cases/${handoffRef.id}`,\n      });\n\n      logInfo('Agency notification email sent', {\n        handoffId: handoffRef.id,\n        agencyEmail: agency.agencyContactEmail,\n      });\n\n    } catch (emailError) {\n      logError('Failed to send agency notification email', emailError);\n      // Continue - don't fail the handoff if email fails\n    }\n\n    try {\n      // 2. Notify freelancer with in-app notification and email\n      const freelancerDoc = await db.collection('users').doc(params.freelancerId).get();\n      const freelancer = freelancerDoc.data();\n\n      if (freelancer) {\n        // Create in-app notification\n        const notification = {\n          notificationId: nanoid(),\n          userId: params.freelancerId,\n          type: 'agency_handoff',\n          title: 'Invoice escalated to collection agency',\n          message: `Invoice ${invoice.reference} (${invoice.clientName}) has been escalated to ${agency.agencyName} for professional collection. You'll be notified of any updates.`,\n          read: false,\n          actionUrl: `${process.env.NEXT_PUBLIC_APP_URL}/dashboard/collections/agency/${handoffRef.id}`,\n          metadata: {\n            handoffId: handoffRef.id,\n            invoiceId: params.invoiceId,\n            agencyName: agency.agencyName,\n          },\n          createdAt: Timestamp.now(),\n        };\n\n        await db.collection('notifications').add(notification);\n\n        // Send email if enabled\n        if (freelancer.notificationPreferences?.emailNotifications && freelancer.email) {\n          await sendNotificationEmail({\n            toEmail: freelancer.email,\n            subject: 'Invoice Escalated to Collection Agency',\n            message: `Your invoice ${invoice.reference} for ${invoice.clientName} (£${invoice.amount.toFixed(2)}) has been escalated to ${agency.agencyName}.\n\n**What happens next:**\n1. ${agency.agencyName} will take over the collection process\n2. You'll receive updates on their progress\n3. If payment is recovered, the commission (${agency.commissionPercentage}%) will be automatically deducted\n\n**You don't need to do anything** - the agency will handle all communication with the client.\n\nWe'll notify you of any developments.`,\n            actionUrl: notification.actionUrl,\n          });\n        }\n\n        logInfo('Freelancer notification sent', {\n          handoffId: handoffRef.id,\n          freelancerId: params.freelancerId,\n        });\n      }\n\n    } catch (notificationError) {\n      logError('Failed to send freelancer notification', notificationError);\n      // Continue - don't fail the handoff if notification fails\n    }\n\n    // AUDIT TASK #5: Upload supporting documents to Firebase Storage\n    try {\n      const uploadedDocuments: string[] = [];\n\n      // 1. Create communication history document as JSON\n      const communicationHistoryJson = {\n        handoffId: handoffRef.id,\n        invoiceId: params.invoiceId,\n        generatedAt: new Date().toISOString(),\n        attempts: communicationHistory,\n        summary: {\n          totalAttempts: communicationHistory.length,\n          attemptTypes: {\n            email: communicationHistory.filter((c: any) => c.type === 'email').length,\n            sms: communicationHistory.filter((c: any) => c.type === 'sms').length,\n            call: communicationHistory.filter((c: any) => c.type === 'call').length,\n            letter: communicationHistory.filter((c: any) => c.type === 'letter').length,\n          },\n          daysPastDue,\n          originalAmount: invoice.amount,\n        },\n      };\n\n      const historyBuffer = Buffer.from(JSON.stringify(communicationHistoryJson, null, 2), 'utf-8');\n\n      const uploadResult = await uploadCommunicationHistory({\n        contentBuffer: historyBuffer,\n        fileName: `communication-history-${Date.now()}.json`,\n        contentType: 'application/json',\n        handoffId: handoffRef.id,\n        freelancerId: params.freelancerId,\n      });\n\n      if (uploadResult.success && uploadResult.storagePath) {\n        uploadedDocuments.push(uploadResult.storagePath);\n\n        // Update handoff with document references\n        await handoffRef.update({\n          documents: uploadedDocuments,\n          documentUrls: uploadedDocuments.map(path => ({\n            storagePath: path,\n            uploadedAt: Timestamp.now(),\n            documentType: 'communication_history',\n          })),\n        });\n\n        logInfo('Communication history uploaded to storage', {\n          handoffId: handoffRef.id,\n          storagePath: uploadResult.storagePath,\n        });\n      }\n\n      // Note: Invoice PDF upload would require the actual PDF file\n      // This can be added when invoice generation is implemented\n      // For now, we store the communication history which is the most critical\n\n    } catch (uploadError) {\n      logError('Failed to upload documents to storage', uploadError);\n      // Continue - document upload failure shouldn't block handoff creation\n      // Documents can be uploaded manually later if needed\n    }\n\n    logInfo('Agency handoff created', {\n      handoffId: handoffRef.id,\n      invoiceId: params.invoiceId,\n      agencyId: params.agencyId,\n    });\n\n    return {\n      success: true,\n      handoffId: handoffRef.id,\n    };\n\n  } catch (error) {\n    logError('Failed to create agency handoff', error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error',\n    };\n  }\n}\n\n/**\n * Update handoff status from agency\n */\nexport async function updateHandoffStatus(\n  handoffId: string,\n  update: {\n    status?: AgencyHandoff['handoffStatus'];\n    notes?: string;\n    actionTaken?: string;\n    recoveryAmount?: number;\n    recoveryOutcome?: AgencyHandoff['recoveryOutcome'];\n  }\n): Promise<{ success: boolean; error?: string }> {\n  try {\n    const handoffRef = db.collection('agency_handoffs').doc(handoffId);\n    const handoffDoc = await handoffRef.get();\n\n    if (!handoffDoc.exists) {\n      return { success: false, error: 'Handoff not found' };\n    }\n\n    const updateData: any = {\n      lastUpdate: FieldValue.serverTimestamp(),\n      updatedAt: FieldValue.serverTimestamp(),\n    };\n\n    // Update status if provided\n    if (update.status) {\n      updateData.handoffStatus = update.status;\n\n      if (update.status === 'closed') {\n        updateData.closedAt = FieldValue.serverTimestamp();\n      }\n    }\n\n    // Add recovery details if provided\n    if (update.recoveryAmount !== undefined) {\n      updateData.recoveryAmount = update.recoveryAmount;\n      updateData.recoveryDate = FieldValue.serverTimestamp();\n\n      // Calculate commission\n      const handoff = handoffDoc.data() as AgencyHandoff;\n      updateData.commissionAmount = (update.recoveryAmount * handoff.commissionPercentage) / 100;\n    }\n\n    if (update.recoveryOutcome) {\n      updateData.recoveryOutcome = update.recoveryOutcome;\n    }\n\n    // Add to agency updates log\n    if (update.notes || update.actionTaken) {\n      updateData.agencyUpdates = FieldValue.arrayUnion({\n        date: FieldValue.serverTimestamp(),\n        status: update.status || 'in_progress',\n        notes: update.notes || '',\n        actionTaken: update.actionTaken,\n      });\n    }\n\n    await handoffRef.update(updateData);\n\n    // If paid, update invoice\n    if (update.status === 'collected' && update.recoveryAmount) {\n      const handoff = handoffDoc.data() as AgencyHandoff;\n      await db.collection('invoices').doc(handoff.invoiceId).update({\n        status: 'paid',\n        paidAt: FieldValue.serverTimestamp(),\n        updatedAt: FieldValue.serverTimestamp(),\n      });\n\n      // AUDIT TASK #4 & #6: Notify freelancer of successful recovery\n      try {\n        const freelancerDoc = await db.collection('users').doc(handoff.freelancerId).get();\n        const freelancer = freelancerDoc.data();\n\n        if (freelancer) {\n          // Calculate net amount after commission\n          const commissionAmount = update.recoveryAmount * (handoff.commissionPercentage / 100);\n          const netAmount = update.recoveryAmount - commissionAmount;\n\n          // Create in-app notification\n          const notification = {\n            notificationId: nanoid(),\n            userId: handoff.freelancerId,\n            type: 'payment_recovered',\n            title: `Payment recovered by ${handoff.agencyName}!`,\n            message: `Great news! ${handoff.agencyName} has successfully collected £${update.recoveryAmount.toFixed(2)} for invoice ${handoff.invoiceId}. After ${handoff.commissionPercentage}% commission, you'll receive £${netAmount.toFixed(2)}.`,\n            read: false,\n            actionUrl: `${process.env.NEXT_PUBLIC_APP_URL}/dashboard/collections/agency/${handoffId}`,\n            metadata: {\n              handoffId,\n              invoiceId: handoff.invoiceId,\n              recoveryAmount: update.recoveryAmount,\n              commissionAmount,\n              netAmount,\n            },\n            createdAt: Timestamp.now(),\n          };\n\n          await db.collection('notifications').add(notification);\n\n          // Send email if enabled\n          if (freelancer.notificationPreferences?.emailNotifications && freelancer.email) {\n            await sendNotificationEmail({\n              toEmail: freelancer.email,\n              subject: 'Payment Successfully Recovered!',\n              message: `Excellent news! ${handoff.agencyName} has successfully recovered payment for your invoice.\n\n**Recovery Details:**\n- Invoice: ${handoff.invoiceId}\n- Amount Recovered: £${update.recoveryAmount.toFixed(2)}\n- Agency Commission (${handoff.commissionPercentage}%): £${commissionAmount.toFixed(2)}\n- Net Amount to You: £${netAmount.toFixed(2)}\n\nThe net amount will be transferred to your account within 5-7 business days.\n\nThank you for using Relay's collection services!`,\n              actionUrl: notification.actionUrl,\n            });\n          }\n\n          logInfo('Recovery notification sent to freelancer', {\n            handoffId,\n            freelancerId: handoff.freelancerId,\n            recoveryAmount: update.recoveryAmount,\n          });\n        }\n\n      } catch (notificationError) {\n        logError('Failed to send recovery notification', notificationError);\n        // Continue - notification failure shouldn't block the update\n      }\n\n      // AUDIT TASK #6: Create transaction record for payment tracking\n      try {\n        const transactionResult = await createAgencyRecoveryTransaction({\n          invoiceId: handoff.invoiceId,\n          freelancerId: handoff.freelancerId,\n          agencyHandoffId: handoffId,\n          agencyId: handoff.agencyId,\n          grossAmount: update.recoveryAmount,\n          agencyCommissionRate: handoff.commissionPercentage / 100,\n          notes: `Recovery by ${handoff.agencyName}. ${update.recoveryOutcome || 'full_recovery'}`,\n        });\n\n        if (transactionResult.success) {\n          // Link transaction to handoff\n          await handoffRef.update({\n            transactionId: transactionResult.transactionId,\n            transactionCreatedAt: Timestamp.now(),\n          });\n\n          logInfo('Agency recovery transaction created', {\n            handoffId,\n            transactionId: transactionResult.transactionId,\n            grossAmount: update.recoveryAmount,\n          });\n        } else {\n          logError('Failed to create recovery transaction', new Error(transactionResult.error));\n        }\n\n      } catch (transactionError) {\n        logError('Failed to create recovery transaction', transactionError);\n        // Continue - transaction creation failure shouldn't block the update\n        // Transactions can be created manually later if needed\n      }\n    }\n\n    return { success: true };\n\n  } catch (error) {\n    logError('Failed to update handoff status', error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error',\n    };\n  }\n}\n\n/**\n * Get handoff details\n */\nexport async function getHandoffDetails(handoffId: string): Promise<AgencyHandoff | null> {\n  try {\n    const doc = await db.collection('agency_handoffs').doc(handoffId).get();\n\n    if (!doc.exists) {\n      return null;\n    }\n\n    return doc.data() as AgencyHandoff;\n\n  } catch (error) {\n    logError('Failed to get handoff details', error);\n    return null;\n  }\n}\n\n/**\n * List handoffs for freelancer\n */\nexport async function listFreelancerHandoffs(\n  freelancerId: string,\n  options?: {\n    status?: AgencyHandoff['handoffStatus'];\n    limit?: number;\n  }\n): Promise<AgencyHandoff[]> {\n  try {\n    let query = db\n      .collection('agency_handoffs')\n      .where('freelancerId', '==', freelancerId)\n      .orderBy('createdAt', 'desc');\n\n    if (options?.status) {\n      query = query.where('handoffStatus', '==', options.status) as any;\n    }\n\n    if (options?.limit) {\n      query = query.limit(options.limit) as any;\n    }\n\n    const snapshot = await query.get();\n    return snapshot.docs.map(doc => doc.data() as AgencyHandoff);\n\n  } catch (error) {\n    logError('Failed to list handoffs', error);\n    return [];\n  }\n}\n\n/**\n * Calculate potential commission for agency escalation\n */\nexport function calculateAgencyCommission(params: {\n  amount: number;\n  agencyId: string;\n}): {\n  commissionPercentage: number;\n  commissionAmount: number;\n  freelancerReceives: number;\n  agencyReceives: number;\n} | null {\n  const agency = REGISTERED_AGENCIES.find(a => a.agencyId === params.agencyId);\n\n  if (!agency) {\n    return null;\n  }\n\n  const commissionAmount = (params.amount * agency.commissionPercentage) / 100;\n  const freelancerReceives = params.amount - commissionAmount;\n\n  return {\n    commissionPercentage: agency.commissionPercentage,\n    commissionAmount,\n    freelancerReceives,\n    agencyReceives: commissionAmount,\n  };\n}\n\n/**\n * Get list of available agencies for freelancer\n */\nexport function getAvailableAgencies(params: {\n  amount: number;\n}): Array<{\n  agencyId: string;\n  agencyName: string;\n  commissionPercentage: number;\n  commissionAmount: number;\n  freelancerReceives: number;\n  minimumDebtAmount: number;\n  eligible: boolean;\n}> {\n  return REGISTERED_AGENCIES.map(agency => {\n    const eligible = params.amount >= agency.minimumDebtAmount;\n    const commissionAmount = (params.amount * agency.commissionPercentage) / 100;\n    const freelancerReceives = params.amount - commissionAmount;\n\n    return {\n      agencyId: agency.agencyId,\n      agencyName: agency.agencyName,\n      commissionPercentage: agency.commissionPercentage,\n      commissionAmount,\n      freelancerReceives,\n      minimumDebtAmount: agency.minimumDebtAmount,\n      eligible,\n    };\n  }).sort((a, b) => a.commissionPercentage - b.commissionPercentage); // Lowest commission first\n}\n"],"names":[],"mappings":"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"}