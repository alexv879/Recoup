module.exports=[640,e=>e.a(async(t,n)=>{try{var o=e.i(89171),s=e.i(7218),a=e.i(68253),l=e.i(55742),r=e.i(15776),i=e.i(69907),c=t([a,l]);async function u(e){try{let{userId:e}=await (0,s.auth)();if(!e)throw r.errors.unauthorized();(0,i.logApiRequest)("GET","/api/users/me/collections-consent",e);let t=await a.db.collection("users").doc(e).get();if(!t.exists)throw r.errors.notFound("User not found");let n=t.data(),l=n?.collectionsConsent||{smsConsent:!1,callConsent:!1,callRecordingConsent:!1,physicalMailConsent:!1,dataStorageConsent:!1,smsOptedOut:!1,callOptedOut:!1,physicalMailOptedOut:!1};return(0,i.logApiResponse)("GET","/api/users/me/collections-consent",200,0,e),o.NextResponse.json({success:!0,consent:l})}catch(e){return(0,r.handleApiError)(e)}}async function d(e){let t=Date.now();try{let{userId:n}=await (0,s.auth)();if(!n)throw r.errors.unauthorized();(0,i.logApiRequest)("POST","/api/users/me/collections-consent",n);let{smsConsent:c,callConsent:u,callRecordingConsent:d,physicalMailConsent:p,dataStorageConsent:h,ipAddress:C}=await e.json();if(void 0===c&&void 0===u&&void 0===d&&void 0===p&&void 0===h)throw r.errors.badRequest("At least one consent field must be provided");let R={"collectionsConsent.consentDate":l.Timestamp.now(),"collectionsConsent.consentVersion":"1.0"};if(C&&(R["collectionsConsent.ipAddress"]=C),void 0!==c&&(R["collectionsConsent.smsConsent"]=c,c&&(R["collectionsConsent.smsOptedOut"]=!1,R["collectionsConsent.smsOptOutDate"]=null)),void 0!==u){if(R["collectionsConsent.callConsent"]=u,u&&!d)throw r.errors.badRequest("Call recording consent is required for AI voice calls");u&&(R["collectionsConsent.callOptedOut"]=!1,R["collectionsConsent.callOptOutDate"]=null)}if(void 0!==d&&(R["collectionsConsent.callRecordingConsent"]=d),void 0!==p&&(R["collectionsConsent.physicalMailConsent"]=p,p&&(R["collectionsConsent.physicalMailOptedOut"]=!1,R["collectionsConsent.physicalMailOptOutDate"]=null)),void 0!==h&&(R["collectionsConsent.dataStorageConsent"]=h,d&&!h))throw r.errors.badRequest("Data storage consent is required for call recordings");await a.db.collection("users").doc(n).update(R),(0,i.logInfo)("Collections consent updated",{userId:n,smsConsent:c,callConsent:u,callRecordingConsent:d,physicalMailConsent:p,dataStorageConsent:h});let m=Date.now()-t;return(0,i.logApiResponse)("POST","/api/users/me/collections-consent",200,m,n),o.NextResponse.json({success:!0,message:"Consent preferences updated successfully"})}catch(n){let e=Date.now()-t;return(0,i.logApiResponse)("POST","/api/users/me/collections-consent",n.statusCode||500,e),(0,r.handleApiError)(n)}}async function p(e){let t=Date.now();try{let{userId:e}=await (0,s.auth)();if(!e)throw r.errors.unauthorized();(0,i.logApiRequest)("DELETE","/api/users/me/collections-consent",e),await a.db.collection("users").doc(e).update({"collectionsConsent.smsConsent":!1,"collectionsConsent.callConsent":!1,"collectionsConsent.callRecordingConsent":!1,"collectionsConsent.physicalMailConsent":!1,"collectionsConsent.dataStorageConsent":!1,"collectionsConsent.smsOptedOut":!0,"collectionsConsent.callOptedOut":!0,"collectionsConsent.physicalMailOptedOut":!0,"collectionsConsent.smsOptOutDate":l.Timestamp.now(),"collectionsConsent.callOptOutDate":l.Timestamp.now(),"collectionsConsent.physicalMailOptOutDate":l.Timestamp.now(),"collectionsConsent.consentDate":l.Timestamp.now()}),(0,i.logInfo)("All collections consent revoked",{userId:e});let n=Date.now()-t;return(0,i.logApiResponse)("DELETE","/api/users/me/collections-consent",200,n,e),o.NextResponse.json({success:!0,message:"All collections consent has been revoked. You will not receive any automated collection communications."})}catch(n){let e=Date.now()-t;return(0,i.logApiResponse)("DELETE","/api/users/me/collections-consent",n.statusCode||500,e),(0,r.handleApiError)(n)}}[a,l]=c.then?(await c)():c,e.s(["DELETE",()=>p,"GET",()=>u,"POST",()=>d,"dynamic",0,"force-dynamic"]),n()}catch(e){n(e)}},!1),83822,e=>e.a(async(t,n)=>{try{var o=e.i(47909),s=e.i(74017),a=e.i(96250),l=e.i(84243),r=e.i(61916),i=e.i(14444),c=e.i(37092),u=e.i(69741),d=e.i(16795),p=e.i(87718),h=e.i(95169),C=e.i(47587),R=e.i(66012),m=e.i(70101),w=e.i(26937),v=e.i(10372),f=e.i(93695);e.i(52474);var g=e.i(220),E=e.i(640),O=t([E]);[E]=O.then?(await O)():O;let T=new o.AppRouteRouteModule({definition:{kind:s.RouteKind.APP_ROUTE,page:"/api/users/me/collections-consent/route",pathname:"/api/users/me/collections-consent",filename:"route",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/app/api/users/me/collections-consent/route.ts",nextConfigOutput:"",userland:E}),{workAsyncStorage:x,workUnitAsyncStorage:D,serverHooks:b}=T;function y(){return(0,a.patchFetch)({workAsyncStorage:x,workUnitAsyncStorage:D})}async function A(e,t,n){T.isDev&&(0,l.addRequestMeta)(e,"devRequestTimingInternalsEnd",process.hrtime.bigint());let o="/api/users/me/collections-consent/route";o=o.replace(/\/index$/,"")||"/";let a=await T.prepare(e,t,{srcPage:o,multiZoneDraftMode:!1});if(!a)return t.statusCode=400,t.end("Bad Request"),null==n.waitUntil||n.waitUntil.call(n,Promise.resolve()),null;let{buildId:E,params:O,nextConfig:y,parsedUrl:A,isDraftMode:x,prerenderManifest:D,routerServerContext:b,isOnDemandRevalidate:P,revalidateOnlyGenerated:S,resolvedPathname:N,clientReferenceManifest:M,serverActionsManifest:q}=a,_=(0,u.normalizeAppPath)(o),I=!!(D.dynamicRoutes[_]||D.routes[N]),H=async()=>((null==b?void 0:b.render404)?await b.render404(e,t,A,!1):t.end("This page could not be found"),null);if(I&&!x){let e=!!D.routes[N],t=D.dynamicRoutes[_];if(t&&!1===t.fallback&&!e){if(y.experimental.adapterPath)return await H();throw new f.NoFallbackError}}let U=null;!I||T.isDev||x||(U=N,U="/index"===U?"/":U);let k=!0===T.isDev||!I,j=I&&!k;q&&M&&(0,i.setReferenceManifestsSingleton)({page:o,clientReferenceManifest:M,serverActionsManifest:q,serverModuleMap:(0,c.createServerModuleMap)({serverActionsManifest:q})});let F=e.method||"GET",L=(0,r.getTracer)(),$=L.getActiveScopeSpan(),K={params:O,prerenderManifest:D,renderOpts:{experimental:{authInterrupts:!!y.experimental.authInterrupts},cacheComponents:!!y.cacheComponents,supportsDynamicResponse:k,incrementalCache:(0,l.getRequestMeta)(e,"incrementalCache"),cacheLifeProfiles:y.cacheLife,waitUntil:n.waitUntil,onClose:e=>{t.on("close",e)},onAfterTaskError:void 0,onInstrumentationRequestError:(t,n,o)=>T.onRequestError(e,t,o,b)},sharedContext:{buildId:E}},G=new d.NodeNextRequest(e),B=new d.NodeNextResponse(t),z=p.NextRequestAdapter.fromNodeNextRequest(G,(0,p.signalFromNodeResponse)(t));try{let a=async e=>T.handle(z,K).finally(()=>{if(!e)return;e.setAttributes({"http.status_code":t.statusCode,"next.rsc":!1});let n=L.getRootSpanAttributes();if(!n)return;if(n.get("next.span_type")!==h.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${n.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let s=n.get("next.route");if(s){let t=`${F} ${s}`;e.setAttributes({"next.route":s,"http.route":s,"next.span_name":t}),e.updateName(t)}else e.updateName(`${F} ${o}`)}),i=!!(0,l.getRequestMeta)(e,"minimalMode"),c=async l=>{var r,c;let u=async({previousCacheEntry:s})=>{try{if(!i&&P&&S&&!s)return t.statusCode=404,t.setHeader("x-nextjs-cache","REVALIDATED"),t.end("This page could not be found"),null;let o=await a(l);e.fetchMetrics=K.renderOpts.fetchMetrics;let r=K.renderOpts.pendingWaitUntil;r&&n.waitUntil&&(n.waitUntil(r),r=void 0);let c=K.renderOpts.collectedTags;if(!I)return await (0,R.sendResponse)(G,B,o,K.renderOpts.pendingWaitUntil),null;{let e=await o.blob(),t=(0,m.toNodeOutgoingHttpHeaders)(o.headers);c&&(t[v.NEXT_CACHE_TAGS_HEADER]=c),!t["content-type"]&&e.type&&(t["content-type"]=e.type);let n=void 0!==K.renderOpts.collectedRevalidate&&!(K.renderOpts.collectedRevalidate>=v.INFINITE_CACHE)&&K.renderOpts.collectedRevalidate,s=void 0===K.renderOpts.collectedExpire||K.renderOpts.collectedExpire>=v.INFINITE_CACHE?void 0:K.renderOpts.collectedExpire;return{value:{kind:g.CachedRouteKind.APP_ROUTE,status:o.status,body:Buffer.from(await e.arrayBuffer()),headers:t},cacheControl:{revalidate:n,expire:s}}}}catch(t){throw(null==s?void 0:s.isStale)&&await T.onRequestError(e,t,{routerKind:"App Router",routePath:o,routeType:"route",revalidateReason:(0,C.getRevalidateReason)({isStaticGeneration:j,isOnDemandRevalidate:P})},b),t}},d=await T.handleResponse({req:e,nextConfig:y,cacheKey:U,routeKind:s.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:D,isRoutePPREnabled:!1,isOnDemandRevalidate:P,revalidateOnlyGenerated:S,responseGenerator:u,waitUntil:n.waitUntil,isMinimalMode:i});if(!I)return null;if((null==d||null==(r=d.value)?void 0:r.kind)!==g.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==d||null==(c=d.value)?void 0:c.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});i||t.setHeader("x-nextjs-cache",P?"REVALIDATED":d.isMiss?"MISS":d.isStale?"STALE":"HIT"),x&&t.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let p=(0,m.fromNodeOutgoingHttpHeaders)(d.value.headers);return i&&I||p.delete(v.NEXT_CACHE_TAGS_HEADER),!d.cacheControl||t.getHeader("Cache-Control")||p.get("Cache-Control")||p.set("Cache-Control",(0,w.getCacheControlHeader)(d.cacheControl)),await (0,R.sendResponse)(G,B,new Response(d.value.body,{headers:p,status:d.value.status||200})),null};$?await c($):await L.withPropagatedContext(e.headers,()=>L.trace(h.BaseServerSpan.handleRequest,{spanName:`${F} ${o}`,kind:r.SpanKind.SERVER,attributes:{"http.method":F,"http.target":e.url}},c))}catch(t){if(t instanceof f.NoFallbackError||await T.onRequestError(e,t,{routerKind:"App Router",routePath:_,routeType:"route",revalidateReason:(0,C.getRevalidateReason)({isStaticGeneration:j,isOnDemandRevalidate:P})}),I)throw t;return await (0,R.sendResponse)(G,B,new Response(null,{status:500})),null}}e.s(["handler",()=>A,"patchFetch",()=>y,"routeModule",()=>T,"serverHooks",()=>b,"workAsyncStorage",()=>x,"workUnitAsyncStorage",()=>D]),n()}catch(e){n(e)}},!1)];

//# sourceMappingURL=_edbbf980._.js.map