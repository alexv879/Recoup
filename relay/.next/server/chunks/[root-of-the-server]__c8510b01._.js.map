{"version":3,"sources":["../../../utils/error.ts","../../../node_modules/safe-buffer/index.js","../../../middleware/premiumGating.ts","../../../services/consentService.ts","../../../lib/stripe.ts","../../../lib/ai-voice-agent.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport { ZodError } from 'zod';\n\n// Custom error classes\nexport class ApiError extends Error {\n  constructor(\n    public statusCode: number,\n    message: string,\n    public code?: string\n  ) {\n    super(message);\n    this.name = 'ApiError';\n  }\n}\n\nexport class ValidationError extends ApiError {\n  constructor(message: string, public details?: any) {\n    super(400, message, 'VALIDATION_ERROR');\n  }\n}\n\nexport class UnauthorizedError extends ApiError {\n  constructor(message: string = 'Unauthorized') {\n    super(401, message, 'UNAUTHORIZED');\n  }\n}\n\nexport class ForbiddenError extends ApiError {\n  constructor(message: string = 'Forbidden') {\n    super(403, message, 'FORBIDDEN');\n  }\n}\n\nexport class NotFoundError extends ApiError {\n  constructor(message: string = 'Not found') {\n    super(404, message, 'NOT_FOUND');\n  }\n}\n\nexport class RateLimitError extends ApiError {\n  constructor(message: string = 'Rate limit exceeded', public retryAfter?: number) {\n    super(429, message, 'RATE_LIMIT');\n  }\n}\n\nexport class InternalError extends ApiError {\n  constructor(message: string = 'Internal server error') {\n    super(500, message, 'INTERNAL_ERROR');\n  }\n}\n\n// Common error constructors\nexport const errors = {\n  unauthorized: (message = 'Unauthorized') => new UnauthorizedError(message),\n  forbidden: (message = 'Forbidden') => new ForbiddenError(message),\n  notFound: (message = 'Not found') => new NotFoundError(message),\n  badRequest: (message: string) => new ValidationError(message),\n  internal: (message = 'Internal server error') => new InternalError(message),\n  rateLimit: (message = 'Rate limit exceeded', retryAfter?: number) =>\n    new RateLimitError(message, retryAfter),\n};\n\n// Error handler function\nexport function handleApiError(error: unknown): NextResponse {\n  // Handle custom API errors\n  if (error instanceof ApiError) {\n    const response: any = {\n      error: error.code,\n      message: error.message,\n    };\n\n    if (error instanceof ValidationError && error.details) {\n      response.details = error.details;\n    }\n\n    if (error instanceof RateLimitError && error.retryAfter) {\n      return NextResponse.json(response, {\n        status: error.statusCode,\n        headers: {\n          'Retry-After': error.retryAfter.toString(),\n        },\n      });\n    }\n\n    return NextResponse.json(response, { status: error.statusCode });\n  }\n\n  // Handle Zod validation errors\n  if (error instanceof ZodError) {\n    return NextResponse.json(\n      {\n        error: 'VALIDATION_ERROR',\n        message: 'Invalid request data',\n        details: error.issues,\n      },\n      { status: 400 }\n    );\n  }\n\n  // Handle unknown errors\n  console.error('Unhandled error:', error);\n\n  return NextResponse.json(\n    {\n      error: 'INTERNAL_ERROR',\n      message: 'An unexpected error occurred',\n    },\n    { status: 500 }\n  );\n}\n\n// Async error wrapper for API routes\nexport function withErrorHandling(\n  handler: (req: Request, context?: any) => Promise<NextResponse>\n) {\n  return async (req: Request, context?: any): Promise<NextResponse> => {\n    try {\n      return await handler(req, context);\n    } catch (error) {\n      return handleApiError(error);\n    }\n  };\n}\n","/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","/**\n * PREMIUM GATING MIDDLEWARE\n *\n * Ensures users have appropriate subscription tier before accessing premium features.\n *\n * Subscription Tiers:\n * - FREE: Basic invoicing, email reminders (2 per month demo)\n * - PAID: All premium features (SMS, Letters, AI Calls, Agency Handoff)\n *\n * Premium Features:\n * - Twilio SMS reminders\n * - Physical letters via Lob\n * - AI voice collection calls\n * - Agency escalation\n * - Advanced analytics\n * - Priority support\n */\n\nimport { db } from '@/lib/firebase';\nimport { User } from '@/types/models';\nimport { logWarn } from '@/utils/logger';\n\n/**\n * Premium feature types\n */\nexport type PremiumFeature =\n  | 'sms_reminders'\n  | 'physical_letters'\n  | 'ai_voice_calls'\n  | 'agency_handoff'\n  | 'advanced_analytics'\n  | 'priority_support'\n  | 'unlimited_collections';\n\n/**\n * Feature to tier mapping\n */\nconst FEATURE_TIER_REQUIREMENTS: Record<PremiumFeature, 'free' | 'paid'> = {\n  sms_reminders: 'paid',\n  physical_letters: 'paid',\n  ai_voice_calls: 'paid',\n  agency_handoff: 'paid',\n  advanced_analytics: 'paid',\n  priority_support: 'paid',\n  unlimited_collections: 'paid',\n};\n\n/**\n * Feature cost estimates (for display to users)\n */\nconst FEATURE_COSTS: Record<PremiumFeature, { perUse: number; description: string }> = {\n  sms_reminders: {\n    perUse: 0.04,\n    description: 'SMS reminder sent to client',\n  },\n  physical_letters: {\n    perUse: 1.20,\n    description: 'Physical letter sent by post',\n  },\n  ai_voice_calls: {\n    perUse: 1.50,\n    description: '5-minute AI collection call',\n  },\n  agency_handoff: {\n    perUse: 0, // Commission-based\n    description: 'Escalation to collection agency',\n  },\n  advanced_analytics: {\n    perUse: 0,\n    description: 'Access to advanced analytics dashboard',\n  },\n  priority_support: {\n    perUse: 0,\n    description: '24/7 priority email support',\n  },\n  unlimited_collections: {\n    perUse: 0,\n    description: 'Unlimited automated collection reminders',\n  },\n};\n\n/**\n * Check if user has access to premium feature\n */\nexport async function checkPremiumAccess(\n  userId: string,\n  feature: PremiumFeature\n): Promise<{\n  hasAccess: boolean;\n  reason?: string;\n  upgradeRequired?: boolean;\n}> {\n  try {\n    // 1. Get user\n    const userDoc = await db.collection('users').doc(userId).get();\n\n    if (!userDoc.exists) {\n      return {\n        hasAccess: false,\n        reason: 'User not found',\n      };\n    }\n\n    const user = userDoc.data() as User;\n\n    // 2. Check subscription tier\n    const requiredTier = FEATURE_TIER_REQUIREMENTS[feature];\n\n    if (requiredTier === 'paid' && user.subscriptionTier === 'free') {\n      return {\n        hasAccess: false,\n        reason: 'This feature requires a paid subscription',\n        upgradeRequired: true,\n      };\n    }\n\n    // 3. Check if collections are enabled\n    if (!user.collectionsEnabled) {\n      return {\n        hasAccess: false,\n        reason: 'Collections features are disabled for your account',\n      };\n    }\n\n    // 4. Special handling for free tier demo\n    if (user.subscriptionTier === 'free' && feature === 'unlimited_collections') {\n      // Check demo usage\n      const currentMonth = new Date().getMonth();\n      const lastResetMonth = user.lastDemoResetDate?.toDate().getMonth();\n\n      // Reset counter if new month\n      if (lastResetMonth !== currentMonth) {\n        await db.collection('users').doc(userId).update({\n          collectionsDemoUsedThisMonth: 0,\n          lastDemoResetDate: new Date(),\n        });\n      }\n\n      // Check if demo limit reached\n      if (user.collectionsDemoUsedThisMonth >= 2) {\n        return {\n          hasAccess: false,\n          reason: 'Free tier demo limit reached (2 per month)',\n          upgradeRequired: true,\n        };\n      }\n    }\n\n    return {\n      hasAccess: true,\n    };\n\n  } catch (error) {\n    logWarn('Premium access check failed', { userId, feature, error });\n    return {\n      hasAccess: false,\n      reason: 'Unable to verify subscription status',\n    };\n  }\n}\n\n/**\n * Validate premium access or throw error\n * Use this in API routes to enforce premium gating\n */\nexport async function requirePremiumAccess(\n  userId: string,\n  feature: PremiumFeature\n): Promise<void> {\n  const result = await checkPremiumAccess(userId, feature);\n\n  if (!result.hasAccess) {\n    const error: any = new Error(result.reason || 'Access denied');\n    error.statusCode = 402; // Payment Required\n    error.upgradeRequired = result.upgradeRequired;\n    throw error;\n  }\n}\n\n/**\n * Increment demo usage counter for free tier\n */\nexport async function incrementDemoUsage(userId: string): Promise<void> {\n  try {\n    const userDoc = await db.collection('users').doc(userId).get();\n    const user = userDoc.data() as User;\n\n    if (user.subscriptionTier === 'free') {\n      const currentMonth = new Date().getMonth();\n      const lastResetMonth = user.lastDemoResetDate?.toDate().getMonth();\n\n      // Reset if new month\n      if (lastResetMonth !== currentMonth) {\n        await db.collection('users').doc(userId).update({\n          collectionsDemoUsedThisMonth: 1,\n          lastDemoResetDate: new Date(),\n        });\n      } else {\n        await db.collection('users').doc(userId).update({\n          collectionsDemoUsedThisMonth: (user.collectionsDemoUsedThisMonth || 0) + 1,\n        });\n      }\n    }\n  } catch (error) {\n    logWarn('Failed to increment demo usage', { userId, error });\n  }\n}\n\n/**\n * Get feature details for UI display\n */\nexport function getFeatureInfo(feature: PremiumFeature): {\n  name: string;\n  description: string;\n  requiredTier: 'free' | 'paid';\n  costPerUse: number;\n  costDescription: string;\n} {\n  const names: Record<PremiumFeature, string> = {\n    sms_reminders: 'SMS Reminders',\n    physical_letters: 'Physical Letters',\n    ai_voice_calls: 'AI Voice Calls',\n    agency_handoff: 'Agency Escalation',\n    advanced_analytics: 'Advanced Analytics',\n    priority_support: 'Priority Support',\n    unlimited_collections: 'Unlimited Collections',\n  };\n\n  const descriptions: Record<PremiumFeature, string> = {\n    sms_reminders: 'Send automated SMS text reminders to clients for overdue invoices',\n    physical_letters: 'Send professional collection letters via postal mail',\n    ai_voice_calls: 'AI-powered phone calls to collect overdue payments',\n    agency_handoff: 'Escalate difficult cases to professional collection agencies',\n    advanced_analytics: 'Detailed insights into payment patterns and client behavior',\n    priority_support: '24/7 priority email support with faster response times',\n    unlimited_collections: 'Unlimited automated email collection reminders',\n  };\n\n  const cost = FEATURE_COSTS[feature];\n\n  return {\n    name: names[feature],\n    description: descriptions[feature],\n    requiredTier: FEATURE_TIER_REQUIREMENTS[feature],\n    costPerUse: cost.perUse,\n    costDescription: cost.description,\n  };\n}\n\n/**\n * Get all premium features with access status for user\n */\nexport async function getUserFeatureAccess(userId: string): Promise<\n  Array<{\n    feature: PremiumFeature;\n    name: string;\n    hasAccess: boolean;\n    requiredTier: 'free' | 'paid';\n    costPerUse: number;\n  }>\n> {\n  const features: PremiumFeature[] = [\n    'sms_reminders',\n    'physical_letters',\n    'ai_voice_calls',\n    'agency_handoff',\n    'advanced_analytics',\n    'priority_support',\n    'unlimited_collections',\n  ];\n\n  const results = await Promise.all(\n    features.map(async (feature) => {\n      const access = await checkPremiumAccess(userId, feature);\n      const info = getFeatureInfo(feature);\n\n      return {\n        feature,\n        name: info.name,\n        hasAccess: access.hasAccess,\n        requiredTier: info.requiredTier,\n        costPerUse: info.costPerUse,\n      };\n    })\n  );\n\n  return results;\n}\n\n/**\n * Get upgrade CTA message for feature\n */\nexport function getUpgradeMessage(feature: PremiumFeature): {\n  title: string;\n  message: string;\n  ctaText: string;\n  ctaUrl: string;\n} {\n  const info = getFeatureInfo(feature);\n\n  return {\n    title: `Upgrade to use ${info.name}`,\n    message: `${info.description}. This feature is available on our paid plan.`,\n    ctaText: 'Upgrade to Paid Plan',\n    ctaUrl: '/settings/billing/upgrade',\n  };\n}\n\n/**\n * Check if user can perform action based on subscription\n * Returns true if allowed, false if blocked\n */\nexport async function canPerformAction(params: {\n  userId: string;\n  action: 'send_sms' | 'send_letter' | 'make_ai_call' | 'escalate_agency';\n}): Promise<{\n  allowed: boolean;\n  reason?: string;\n  requiresUpgrade?: boolean;\n}> {\n  const featureMap = {\n    send_sms: 'sms_reminders' as PremiumFeature,\n    send_letter: 'physical_letters' as PremiumFeature,\n    make_ai_call: 'ai_voice_calls' as PremiumFeature,\n    escalate_agency: 'agency_handoff' as PremiumFeature,\n  };\n\n  const feature = featureMap[params.action];\n  const access = await checkPremiumAccess(params.userId, feature);\n\n  return {\n    allowed: access.hasAccess,\n    reason: access.reason,\n    requiresUpgrade: access.upgradeRequired,\n  };\n}\n\n/**\n * Log premium feature usage for billing/analytics\n */\nexport async function logPremiumFeatureUsage(params: {\n  userId: string;\n  feature: PremiumFeature;\n  invoiceId?: string;\n  cost?: number;\n}): Promise<void> {\n  try {\n    await db.collection('premium_feature_usage').add({\n      userId: params.userId,\n      feature: params.feature,\n      invoiceId: params.invoiceId,\n      cost: params.cost || FEATURE_COSTS[params.feature].perUse,\n      timestamp: new Date(),\n    });\n  } catch (error) {\n    logWarn('Failed to log premium feature usage', params);\n  }\n}\n","/**\n * CONSENT MANAGEMENT SERVICE\n *\n * Handles user consent for premium collections features.\n * Ensures GDPR and UK Communications Law compliance.\n *\n * UK Legal Requirements:\n * - GDPR: Explicit consent required for processing personal data\n * - Privacy and Electronic Communications Regulations (PECR): Consent for SMS/calls\n * - Recording calls: Must inform and get consent\n * - Data retention: Must honor data deletion requests\n * - Opt-out: Must honor immediately\n *\n * Consent Types:\n * 1. SMS Consent: Receiving SMS collection reminders\n * 2. Call Consent: Receiving AI voice collection calls\n * 3. Call Recording Consent: Recording and storing call audio\n * 4. Physical Mail Consent: Sending physical letters\n * 5. Data Storage Consent: Storing transcripts/recordings\n */\n\nimport { db, FieldValue } from '@/lib/firebase';\nimport { User } from '@/types/models';\nimport { logError, logInfo } from '@/utils/logger';\n\n/**\n * Consent types\n */\nexport type ConsentType =\n  | 'sms'\n  | 'call'\n  | 'call_recording'\n  | 'physical_mail'\n  | 'data_storage';\n\n/**\n * Current consent version\n * Increment when terms change to require re-consent\n */\nconst CURRENT_CONSENT_VERSION = 'v1.0.0';\n\n/**\n * Get user's current consent status\n */\nexport async function getUserConsent(userId: string): Promise<{\n  smsConsent: boolean;\n  callConsent: boolean;\n  callRecordingConsent: boolean;\n  physicalMailConsent: boolean;\n  dataStorageConsent: boolean;\n  consentDate?: Date;\n  consentVersion?: string;\n  needsUpdate: boolean;\n} | null> {\n  try {\n    const userDoc = await db.collection('users').doc(userId).get();\n\n    if (!userDoc.exists) {\n      return null;\n    }\n\n    const user = userDoc.data() as User;\n    const consent = user.collectionsConsent;\n\n    // Check if consent exists and is current version\n    const needsUpdate = !consent ||\n      !consent.consentVersion ||\n      consent.consentVersion !== CURRENT_CONSENT_VERSION;\n\n    return {\n      smsConsent: consent?.smsConsent || false,\n      callConsent: consent?.callConsent || false,\n      callRecordingConsent: consent?.callRecordingConsent || false,\n      physicalMailConsent: consent?.physicalMailConsent || false,\n      dataStorageConsent: consent?.dataStorageConsent || false,\n      consentDate: consent?.consentDate?.toDate(),\n      consentVersion: consent?.consentVersion,\n      needsUpdate,\n    };\n\n  } catch (error) {\n    logError('Failed to get user consent', error);\n    return null;\n  }\n}\n\n/**\n * Update user consent\n */\nexport async function updateUserConsent(params: {\n  userId: string;\n  smsConsent: boolean;\n  callConsent: boolean;\n  callRecordingConsent: boolean;\n  physicalMailConsent: boolean;\n  dataStorageConsent: boolean;\n  ipAddress?: string;\n}): Promise<{ success: boolean; error?: string }> {\n  try {\n    const userRef = db.collection('users').doc(params.userId);\n    const userDoc = await userRef.get();\n\n    if (!userDoc.exists) {\n      return { success: false, error: 'User not found' };\n    }\n\n    // Update consent\n    await userRef.update({\n      'collectionsConsent.smsConsent': params.smsConsent,\n      'collectionsConsent.callConsent': params.callConsent,\n      'collectionsConsent.callRecordingConsent': params.callRecordingConsent,\n      'collectionsConsent.physicalMailConsent': params.physicalMailConsent,\n      'collectionsConsent.dataStorageConsent': params.dataStorageConsent,\n      'collectionsConsent.consentDate': FieldValue.serverTimestamp(),\n      'collectionsConsent.consentVersion': CURRENT_CONSENT_VERSION,\n      'collectionsConsent.ipAddress': params.ipAddress,\n      updatedAt: FieldValue.serverTimestamp(),\n    });\n\n    // Log consent change for audit trail\n    await db.collection('consent_audit_log').add({\n      userId: params.userId,\n      smsConsent: params.smsConsent,\n      callConsent: params.callConsent,\n      callRecordingConsent: params.callRecordingConsent,\n      physicalMailConsent: params.physicalMailConsent,\n      dataStorageConsent: params.dataStorageConsent,\n      consentVersion: CURRENT_CONSENT_VERSION,\n      ipAddress: params.ipAddress,\n      timestamp: FieldValue.serverTimestamp(),\n    });\n\n    logInfo('User consent updated', { userId: params.userId });\n\n    return { success: true };\n\n  } catch (error) {\n    logError('Failed to update user consent', error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error',\n    };\n  }\n}\n\n/**\n * Check if user has given specific consent\n */\nexport async function checkConsent(\n  userId: string,\n  consentType: ConsentType\n): Promise<boolean> {\n  try {\n    const consent = await getUserConsent(userId);\n\n    if (!consent) {\n      return false;\n    }\n\n    // Map consent type to field\n    switch (consentType) {\n      case 'sms':\n        return consent.smsConsent;\n      case 'call':\n        return consent.callConsent;\n      case 'call_recording':\n        return consent.callRecordingConsent;\n      case 'physical_mail':\n        return consent.physicalMailConsent;\n      case 'data_storage':\n        return consent.dataStorageConsent;\n      default:\n        return false;\n    }\n\n  } catch (error) {\n    logError('Failed to check consent', error);\n    return false;\n  }\n}\n\n/**\n * Revoke specific consent (opt-out)\n */\nexport async function revokeConsent(\n  userId: string,\n  consentType: ConsentType\n): Promise<{ success: boolean; error?: string }> {\n  try {\n    const userRef = db.collection('users').doc(userId);\n\n    const updateField = `collectionsConsent.${getConsentFieldName(consentType)}`;\n\n    await userRef.update({\n      [updateField]: false,\n      updatedAt: FieldValue.serverTimestamp(),\n    });\n\n    // Log revocation\n    await db.collection('consent_audit_log').add({\n      userId,\n      action: 'revoke',\n      consentType,\n      timestamp: FieldValue.serverTimestamp(),\n    });\n\n    logInfo('Consent revoked', { userId, consentType });\n\n    return { success: true };\n\n  } catch (error) {\n    logError('Failed to revoke consent', error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error',\n    };\n  }\n}\n\n/**\n * Request data deletion (GDPR Right to Erasure)\n * Deletes all recordings, transcripts, and personal data\n */\nexport async function requestDataDeletion(userId: string): Promise<{\n  success: boolean;\n  error?: string;\n}> {\n  try {\n    // 1. Revoke all consents\n    await db.collection('users').doc(userId).update({\n      'collectionsConsent.smsConsent': false,\n      'collectionsConsent.callConsent': false,\n      'collectionsConsent.callRecordingConsent': false,\n      'collectionsConsent.physicalMailConsent': false,\n      'collectionsConsent.dataStorageConsent': false,\n      updatedAt: FieldValue.serverTimestamp(),\n    });\n\n    // 2. Mark collection attempts for deletion\n    const attempts = await db\n      .collection('collection_attempts')\n      .where('freelancerId', '==', userId)\n      .get();\n\n    const batch = db.batch();\n\n    attempts.docs.forEach(doc => {\n      // Delete recording URLs and transcripts\n      batch.update(doc.ref, {\n        callRecordingUrl: FieldValue.delete(),\n        callTranscript: FieldValue.delete(),\n        callNotes: FieldValue.delete(),\n        updatedAt: FieldValue.serverTimestamp(),\n      });\n    });\n\n    await batch.commit();\n\n    // 3. Log deletion request\n    await db.collection('data_deletion_requests').add({\n      userId,\n      requestDate: FieldValue.serverTimestamp(),\n      status: 'completed',\n      itemsDeleted: attempts.size,\n    });\n\n    // AUDIT TASK #7: Delete files from Firebase Storage (GDPR compliance)\n    try {\n      // Import storage utilities\n      const { listHandoffDocuments, deleteDocument } = await import('@/lib/firebase-storage');\n\n      // Find all handoffs for this user to get document references\n      const handoffsSnapshot = await db\n        .collection('agency_handoffs')\n        .where('freelancerId', '==', userId)\n        .get();\n\n      let filesDeleted = 0;\n\n      for (const handoffDoc of handoffsSnapshot.docs) {\n        const handoffId = handoffDoc.id;\n\n        // List all documents for this handoff\n        const docsResult = await listHandoffDocuments(handoffId, userId);\n\n        if (docsResult.success && docsResult.documents) {\n          // Delete each document\n          for (const doc of docsResult.documents) {\n            const deleteResult = await deleteDocument(doc.storagePath);\n            if (deleteResult.success) {\n              filesDeleted++;\n            }\n          }\n        }\n      }\n\n      logInfo('Cloud storage files deleted', {\n        userId,\n        filesDeleted,\n        handoffsProcessed: handoffsSnapshot.size,\n      });\n\n    } catch (storageError) {\n      logError('Failed to delete cloud storage files', storageError);\n      // Continue - file deletion failure shouldn't block the consent removal\n      // Files will have 30-day TTL and be automatically cleaned up\n    }\n\n    logInfo('Data deletion completed', { userId, itemsDeleted: attempts.size });\n\n    return { success: true };\n\n  } catch (error) {\n    logError('Failed to delete user data', error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error',\n    };\n  }\n}\n\n/**\n * Export user data (GDPR Right to Data Portability)\n */\nexport async function exportUserData(userId: string): Promise<{\n  success: boolean;\n  data?: any;\n  error?: string;\n}> {\n  try {\n    // 1. Get user profile\n    const userDoc = await db.collection('users').doc(userId).get();\n    const user = userDoc.data();\n\n    // 2. Get collection attempts\n    const attemptsSnapshot = await db\n      .collection('collection_attempts')\n      .where('freelancerId', '==', userId)\n      .get();\n\n    const attempts = attemptsSnapshot.docs.map(doc => doc.data());\n\n    // 3. Get agency handoffs\n    const handoffsSnapshot = await db\n      .collection('agency_handoffs')\n      .where('freelancerId', '==', userId)\n      .get();\n\n    const handoffs = handoffsSnapshot.docs.map(doc => doc.data());\n\n    // 4. Package data\n    const exportData = {\n      exportDate: new Date().toISOString(),\n      user: {\n        email: user?.email,\n        name: user?.name,\n        businessName: user?.businessName,\n        collectionsConsent: user?.collectionsConsent,\n      },\n      collectionAttempts: attempts.map(a => ({\n        date: a.attemptDate,\n        type: a.attemptType,\n        result: a.result,\n        // Exclude sensitive data like full transcripts\n        summary: a.callNotes || a.resultDetails,\n      })),\n      agencyHandoffs: handoffs.map(h => ({\n        agencyName: h.agencyName,\n        handoffDate: h.handoffDate,\n        status: h.handoffStatus,\n        recoveryAmount: h.recoveryAmount,\n      })),\n    };\n\n    logInfo('User data exported', { userId });\n\n    return {\n      success: true,\n      data: exportData,\n    };\n\n  } catch (error) {\n    logError('Failed to export user data', error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error',\n    };\n  }\n}\n\n/**\n * Generate consent dialogue text for UI\n */\nexport function getConsentDialogue(consentType: ConsentType): {\n  title: string;\n  description: string;\n  legalBasis: string;\n} {\n  const dialogues = {\n    sms: {\n      title: 'SMS Collection Reminders',\n      description: 'Allow Relay to send SMS text messages to your clients for invoice collection reminders. Messages will only be sent during reasonable hours (08:00-21:00) and clients can opt out at any time.',\n      legalBasis: 'Privacy and Electronic Communications Regulations (PECR) 2003. You can withdraw consent at any time.',\n    },\n    call: {\n      title: 'AI Voice Collection Calls',\n      description: 'Allow Relay to make automated AI-powered phone calls to your clients for invoice collections. Calls are professional, empathetic, and UK-regulation compliant. Calls only occur during reasonable hours (08:00-21:00).',\n      legalBasis: 'Privacy and Electronic Communications Regulations (PECR) 2003 and FCA Debt Collection Rules. You can withdraw consent at any time.',\n    },\n    call_recording: {\n      title: 'Call Recording',\n      description: 'Allow Relay to record collection calls for quality assurance, training, and dispute resolution. Recordings are stored securely and can be deleted upon request.',\n      legalBasis: 'GDPR Article 6(1)(a) - Consent. Recordings are kept for 6 months unless required for disputes. You can request deletion at any time.',\n    },\n    physical_mail: {\n      title: 'Physical Mail Collection Letters',\n      description: 'Allow Relay to send physical collection letters via postal mail on your behalf. Letters follow UK debt collection regulations and escalate from gentle reminders to formal notices.',\n      legalBasis: 'Legitimate interest under GDPR Article 6(1)(f) for debt collection. Letters comply with Consumer Credit Act 1974 and FCA rules.',\n    },\n    data_storage: {\n      title: 'Call Transcript and Recording Storage',\n      description: 'Allow Relay to store call transcripts, recordings, and related data for your records and analytics. All data is encrypted and stored securely in UK/EU data centers.',\n      legalBasis: 'GDPR Article 6(1)(a) - Consent and Article 6(1)(f) - Legitimate interest for contract performance. Data retention: 6 months, or upon request for deletion.',\n    },\n  };\n\n  return dialogues[consentType];\n}\n\n/**\n * Helper: Map consent type to field name\n */\nfunction getConsentFieldName(consentType: ConsentType): string {\n  const mapping = {\n    sms: 'smsConsent',\n    call: 'callConsent',\n    call_recording: 'callRecordingConsent',\n    physical_mail: 'physicalMailConsent',\n    data_storage: 'dataStorageConsent',\n  };\n\n  return mapping[consentType];\n}\n\n/**\n * Validate consent before premium action\n * Throws error if consent not given\n */\nexport async function validateConsentOrThrow(\n  userId: string,\n  requiredConsents: ConsentType[]\n): Promise<void> {\n  const consent = await getUserConsent(userId);\n\n  if (!consent) {\n    throw new Error('User consent status not found');\n  }\n\n  // Check if consent version is current\n  if (consent.needsUpdate) {\n    throw new Error('Consent requires update to current version');\n  }\n\n  // Check each required consent\n  for (const consentType of requiredConsents) {\n    const hasConsent = await checkConsent(userId, consentType);\n\n    if (!hasConsent) {\n      throw new Error(`User has not given consent for: ${consentType}`);\n    }\n  }\n}\n","import Stripe from 'stripe';\n\n// Lazy initialization to avoid build-time errors\nlet stripeInstance: Stripe | null = null;\n\nfunction getStripe(): Stripe {\n  if (!stripeInstance) {\n    const apiKey = process.env.STRIPE_SECRET_KEY;\n    if (!apiKey) {\n      throw new Error('STRIPE_SECRET_KEY is not configured');\n    }\n    stripeInstance = new Stripe(apiKey, {\n      // Using latest stable API version - Stripe will default to account version if omitted\n      // Specify explicit version only when needed for compatibility\n      typescript: true,\n    });\n  }\n  return stripeInstance;\n}\n\n// Export for backward compatibility\nexport const stripe = new Proxy({} as Stripe, {\n  get(target, prop) {\n    return (getStripe() as any)[prop];\n  }\n});\n\n// Create payment link for invoice\nexport async function createStripePaymentLink(params: {\n  amount: number;\n  invoiceReference: string;\n  clientEmail: string;\n  freelancerId: string;\n  currency?: string;\n}): Promise<string> {\n  try {\n    const paymentLink = await stripe.paymentLinks.create({\n      line_items: [\n        {\n          price_data: {\n            currency: (params.currency || 'GBP').toLowerCase(),\n            unit_amount: Math.round(params.amount * 100), // Convert to pence\n            product_data: {\n              name: `Invoice ${params.invoiceReference}`,\n              description: `Payment for ${params.invoiceReference}`,\n            },\n          },\n          quantity: 1,\n        },\n      ],\n      after_completion: {\n        type: 'redirect',\n        redirect: {\n          url: `${process.env.NEXT_PUBLIC_APP_URL}/payment-success?invoice=${params.invoiceReference}`,\n        },\n      },\n      metadata: {\n        invoiceReference: params.invoiceReference,\n        freelancerId: params.freelancerId,\n        clientEmail: params.clientEmail,\n      },\n      // Allow promotion codes\n      allow_promotion_codes: true,\n    });\n\n    return paymentLink.url;\n  } catch (error) {\n    console.error('Stripe payment link creation error:', error);\n    throw new Error('Failed to create payment link');\n  }\n}\n\n// Verify webhook signature (CRITICAL for security)\nexport function verifyWebhookSignature(\n  payload: string,\n  signature: string,\n  secret: string\n): Stripe.Event {\n  try {\n    return stripe.webhooks.constructEvent(payload, signature, secret);\n  } catch (error) {\n    console.error('Webhook signature verification failed:', error);\n    throw new Error('Invalid webhook signature');\n  }\n}\n\n// Get payment intent details\nexport async function getPaymentIntent(paymentIntentId: string) {\n  try {\n    return await stripe.paymentIntents.retrieve(paymentIntentId);\n  } catch (error) {\n    console.error('Stripe payment intent retrieval error:', error);\n    throw new Error('Failed to retrieve payment intent');\n  }\n}\n\n// Create customer (for subscription management later)\nexport async function createCustomer(params: {\n  email: string;\n  name: string;\n  metadata?: Record<string, string>;\n}) {\n  try {\n    return await stripe.customers.create({\n      email: params.email,\n      name: params.name,\n      metadata: params.metadata,\n    });\n  } catch (error) {\n    console.error('Stripe customer creation error:', error);\n    throw new Error('Failed to create customer');\n  }\n}\n","/**\n * PREMIUM FEATURE: AI Voice Agent for Collections Calls\n *\n * Integrates OpenAI Realtime API with Twilio for automated collection calls.\n * The AI agent conducts empathetic debt collection conversations, negotiates\n * payment arrangements, and can accept payments via IVR/SMS during the call.\n *\n * Architecture:\n * 1. Twilio initiates outbound call to debtor\n * 2. Call connects to our webhook endpoint\n * 3. Webhook establishes WebSocket to OpenAI Realtime API\n * 4. Audio streams bidirectionally: Twilio <-> Our Server <-> OpenAI\n * 5. AI agent conducts conversation following UK regulations\n * 6. Payment can be collected via Twilio IVR or SMS link\n * 7. Call transcript and outcome stored in Firestore\n *\n * Setup Instructions:\n * 1. Twilio Setup:\n *    - Account SID and Auth Token in .env\n *    - Phone number with Voice capabilities\n *    - Configure webhook: https://your-domain/api/webhooks/twilio/voice\n *\n * 2. OpenAI Setup:\n *    - Realtime API access (gpt-4o-realtime-preview model)\n *    - API key in .env\n *    - WebSocket endpoint: wss://api.openai.com/v1/realtime\n *\n * 3. Environment Variables:\n *    TWILIO_ACCOUNT_SID=ACxxxxx\n *    TWILIO_AUTH_TOKEN=xxxxx\n *    TWILIO_PHONE_NUMBER=+44xxxxx\n *    OPENAI_API_KEY=sk-xxxxx\n *    STRIPE_SECRET_KEY=sk_xxxxx (for payment links)\n *\n * 4. Install packages:\n *    npm install twilio ws openai\n *\n * UK Debt Collection Call Regulations:\n * - Must identify caller and purpose immediately\n * - Must not be threatening, abusive, or harassing\n * - Must respect request to stop calling\n * - Must not call at unreasonable hours (typically 21:00-08:00)\n * - Must allow debtor to dispute the debt\n * - Must offer payment arrangements for financial hardship\n * - Must record call with consent (or notify of recording)\n * - Comply with FCA debt collection rules\n * - GDPR: Store recordings securely, provide data access on request\n */\n\nimport { logError, logExternalApiCall, logInfo } from '@/utils/logger';\nimport { createStripePaymentLink } from './stripe';\n\n// AUDIT TASK #2: Packages are installed (twilio@5.10.5, ws@8.18.3)\nimport twilio from 'twilio';\nimport { WebSocket } from 'ws';\n\n/**\n * Call outcome types\n */\nexport type CallOutcome =\n  | 'paid' // Payment completed during call\n  | 'promise' // Debtor promised to pay by date\n  | 'partial' // Partial payment agreed\n  | 'refused' // Debtor refused to pay\n  | 'no_answer' // No answer\n  | 'voicemail' // Reached voicemail\n  | 'dispute' // Debtor disputes the debt\n  | 'financial_hardship' // Debtor claims financial hardship\n  | 'error'; // Technical error\n\n/**\n * AI Agent system prompt for debt collection\n * Configured for empathetic, regulation-compliant conversations\n */\nconst AI_AGENT_SYSTEM_PROMPT = `You are an AI collections agent calling on behalf of a freelancer to request payment for an overdue invoice.\n\nCRITICAL RULES (UK Debt Collection Regulations):\n1. Immediately identify yourself: \"This is an automated call from [Business Name] regarding an outstanding invoice.\"\n2. Ask for consent to record: \"This call may be recorded for training and quality purposes. Do you consent to continue?\"\n3. If they say NO to recording, end call politely immediately.\n4. Be professional, empathetic, and non-threatening at all times.\n5. NEVER be aggressive, threatening, or harassing.\n6. If they request to stop calling, agree immediately and end call.\n7. If they dispute the debt, note it and offer to send details in writing.\n8. If they claim financial hardship, be understanding and offer payment plans.\n9. Respect quiet hours - this call should only happen 08:00-21:00 UK time.\n10. Keep call under 10 minutes unless debtor is actively engaging.\n\nYOUR GOALS (in priority order):\n1. BEST: Collect full payment immediately via card payment link\n2. GOOD: Negotiate payment plan with first payment today\n3. ACCEPTABLE: Get promise to pay by specific date\n4. MINIMUM: Understand their situation and document for follow-up\n\nCONVERSATION FLOW:\n1. Opening & Consent (30 seconds)\n   - Identify yourself and purpose\n   - Request recording consent\n   - Confirm you're speaking to the right person\n\n2. Invoice Details (30 seconds)\n   - State invoice number, amount, and due date\n   - Mention how many days overdue\n   - Ask if they recall this invoice\n\n3. Payment Request (1 minute)\n   - Ask for immediate payment\n   - If hesitant, explain consequences (not threats - just facts)\n   - Offer to send secure payment link via SMS during call\n\n4. Negotiation (2-5 minutes if needed)\n   - If can't pay in full, ask what they CAN pay\n   - Offer payment plan (50% today, 50% in 14 days)\n   - If financial hardship, show empathy and reduce pressure\n   - Document any promises or commitments\n\n5. Payment Collection (if agreed)\n   - Confirm amount to be paid\n   - Send SMS payment link (tell them to expect text)\n   - Wait on call while they complete payment\n   - Confirm receipt and thank them\n\n6. Closing (30 seconds)\n   - Summarize agreed action\n   - Confirm any follow-up date\n   - Thank them for their time\n   - End politely\n\nHANDLING OBJECTIONS:\n- \"I don't have the money\": Offer smaller amount or payment plan\n- \"I never got the invoice\": Offer to resend, but payment still due\n- \"The work was poor\": Note dispute, but this doesn't cancel debt\n- \"I'll pay next week\": Get specific date and commitment\n- \"Stop calling me\": Apologize, agree immediately, end call\n- Abusive language: Stay calm, warn once, end call if continues\n\nPAYMENT LINK:\nWhen debtor agrees to pay, say:\n\"I'm sending you a secure payment link by text message right now. You can complete the payment while we're on the call. Please check your phone for a text from [Business Name].\"\n\nWait 30-60 seconds for them to receive and open SMS.\n\nVOICE TONE:\n- Friendly but professional\n- Empathetic and understanding\n- Patient but persistent\n- Clear and concise\n- NO aggressive or threatening tone\n\nREMEMBER: Your goal is to collect payment while maintaining the freelancer's reputation. A harsh call might get payment but lose future business. Be firm but fair.`;\n\n/**\n * Initialize Twilio client\n * AUDIT TASK #2: Twilio is installed and configured\n */\nfunction getTwilioClient() {\n  return twilio(\n    process.env.TWILIO_ACCOUNT_SID!,\n    process.env.TWILIO_AUTH_TOKEN!\n  );\n}\n\n/**\n * Initiate AI-powered collection call\n *\n * @param params Call parameters\n * @returns Call SID and status\n */\nexport async function initiateAICollectionCall(params: {\n  recipientPhone: string; // E.164: +44xxxxxxxxxx\n  recipientName: string;\n  invoiceReference: string;\n  amount: number;\n  dueDate: string;\n  daysPastDue: number;\n  businessName: string;\n  // Internal tracking\n  invoiceId: string;\n  freelancerId: string;\n  // Payment options\n  enablePaymentDuringCall?: boolean;\n}): Promise<{\n  success: boolean;\n  callSid?: string;\n  error?: string;\n}> {\n  const startTime = Date.now();\n\n  try {\n    // 1. Validate phone number\n    if (!params.recipientPhone.startsWith('+44')) {\n      throw new Error('Only UK phone numbers supported');\n    }\n\n    // 2. Check quiet hours (21:00 - 08:00)\n    const hour = new Date().getHours();\n    if (hour >= 21 || hour < 8) {\n      throw new Error('Cannot call during quiet hours (21:00-08:00)');\n    }\n\n    // 3. Create context for AI agent\n    const callContext = {\n      recipientName: params.recipientName,\n      invoiceReference: params.invoiceReference,\n      amount: params.amount,\n      dueDate: params.dueDate,\n      daysPastDue: params.daysPastDue,\n      businessName: params.businessName,\n      invoiceId: params.invoiceId,\n      freelancerId: params.freelancerId,\n    };\n\n    // 4. Initiate call via Twilio\n    // AUDIT TASK #2: Twilio is configured and ready for production use\n    const client = getTwilioClient();\n    const call = await client.calls.create({\n      to: params.recipientPhone,\n      from: process.env.TWILIO_PHONE_NUMBER!,\n      url: `${process.env.NEXT_PUBLIC_APP_URL}/api/webhooks/twilio/voice-ai?context=${encodeURIComponent(JSON.stringify(callContext))}`,\n      statusCallback: `${process.env.NEXT_PUBLIC_APP_URL}/api/webhooks/twilio/call-status`,\n      statusCallbackEvent: ['initiated', 'ringing', 'answered', 'completed'],\n      record: true,\n      recordingStatusCallback: `${process.env.NEXT_PUBLIC_APP_URL}/api/webhooks/twilio/recording-status`,\n    });\n\n    const duration = Date.now() - startTime;\n    logExternalApiCall('Twilio Voice AI', 'initiate', duration);\n\n    return {\n      success: true,\n      callSid: call.sid,\n    };\n\n  } catch (error) {\n    const duration = Date.now() - startTime;\n    logExternalApiCall('Twilio Voice AI', 'initiate', duration, error as Error);\n\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error',\n    };\n  }\n}\n\n/**\n * Handle OpenAI Realtime API WebSocket connection\n * This runs during the active call to stream audio\n *\n * WebSocket Server Implementation\n *\n * The full WebSocket handler is deployed separately for scalability.\n * Vercel doesn't support persistent WebSocket connections, so we use\n * a dedicated Fastify server on Render.com.\n *\n * Implementation Location:\n * - Server: render-server/src/index.ts\n * - OpenAI Integration: render-server/src/services/openai-realtime.ts\n * - Twilio Handler: render-server/src/services/twilio-handler.ts\n * - FCA Prompts: render-server/src/prompts/fca-compliant-prompts.ts\n *\n * Deployment:\n * - Platform: Render.com (Web Service)\n * - Config: render-server/render.yaml\n * - Guide: render-server/README.md\n *\n * WebSocket Endpoint: wss://[your-app].onrender.com/voice-stream\n * Webhook Callback: POST /api/webhooks/voice-call (this app)\n *\n * Environment Variables Required:\n * - OPENAI_API_KEY\n * - TWILIO_ACCOUNT_SID\n * - TWILIO_AUTH_TOKEN\n * - RELAY_WEBHOOK_URL (this app's URL)\n * - VOICE_SERVER_WEBHOOK_SECRET\n */\nexport async function handleRealtimeAICall(params: {\n  twilioStreamSid: string;\n  callContext: {\n    recipientName: string;\n    invoiceReference: string;\n    amount: number;\n    dueDate: string;\n    daysPastDue: number;\n    businessName: string;\n  };\n}): Promise<void> {\n  // TODO: Implement WebSocket connection to OpenAI Realtime API\n  /*\n  const openaiWs = new WebSocket('wss://api.openai.com/v1/realtime', {\n    headers: {\n      'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,\n      'OpenAI-Beta': 'realtime=v1',\n    },\n  });\n\n  // Configure session\n  openaiWs.on('open', () => {\n    openaiWs.send(JSON.stringify({\n      type: 'session.update',\n      session: {\n        modalities: ['text', 'audio'],\n        instructions: AI_AGENT_SYSTEM_PROMPT,\n        voice: 'alloy', // Professional female voice\n        input_audio_format: 'g711_ulaw', // Twilio format\n        output_audio_format: 'g711_ulaw',\n        turn_detection: {\n          type: 'server_vad', // Voice Activity Detection\n          threshold: 0.5,\n          prefix_padding_ms: 300,\n          silence_duration_ms: 500,\n        },\n      },\n    }));\n\n    // Send initial context\n    openaiWs.send(JSON.stringify({\n      type: 'conversation.item.create',\n      item: {\n        type: 'message',\n        role: 'system',\n        content: [{\n          type: 'input_text',\n          text: `You are calling ${params.callContext.recipientName} about invoice ${params.callContext.invoiceReference} for £${params.callContext.amount}, which is ${params.callContext.daysPastDue} days overdue.`,\n        }],\n      },\n    }));\n  });\n\n  // Handle audio from OpenAI -> Twilio\n  openaiWs.on('message', (data) => {\n    const message = JSON.parse(data.toString());\n\n    if (message.type === 'response.audio.delta') {\n      // Forward audio chunk to Twilio\n      // twilioWs.send(message.delta);\n    }\n\n    if (message.type === 'response.done') {\n      // Save transcript\n      console.log('[AI Transcript]', message.output);\n    }\n  });\n  */\n\n  logInfo('AI call handler scaffold - implement WebSocket streaming');\n}\n\n/**\n * Send payment link via SMS during active call\n *\n * This function is called by the AI agent during an active call\n * when the debtor agrees to pay immediately.\n * \n * The AI agent will say:\n * \"I'm sending you a secure payment link by text message right now.\n * You can complete the payment while we're on the call.\"\n * \n * CRITICAL: UK PECR Compliance\n * - SMS can only be sent if user has given SMS consent\n * - This consent is captured during onboarding or settings\n * - If no consent, fall back to email payment link\n *\n * @param params Payment link parameters\n * @returns SMS send result\n */\nexport async function sendPaymentLinkDuringCall(params: {\n  recipientPhone: string;\n  amount: number;\n  invoiceReference: string;\n  freelancerId: string;\n  invoiceId: string;\n}): Promise<{\n  success: boolean;\n  paymentLink?: string;\n  messageSid?: string;\n  error?: string;\n}> {\n  const startTime = Date.now();\n\n  try {\n    // 1. Create Stripe payment link with metadata\n    const paymentLink = await createStripePaymentLink({\n      amount: params.amount,\n      invoiceReference: params.invoiceReference,\n      clientEmail: 'payment-via-call@relay.app', // Temporary placeholder\n      freelancerId: params.freelancerId,\n      currency: 'GBP',\n    });\n\n    // 2. Send via Twilio SMS\n    // AUDIT TASK #2: Twilio SMS is configured and ready\n    const client = getTwilioClient();\n    const message = await client.messages.create({\n      to: params.recipientPhone,\n      from: process.env.TWILIO_PHONE_NUMBER,\n      body: `Payment link for invoice ${params.invoiceReference}: Pay £${params.amount.toFixed(2)} securely at ${paymentLink}. This link expires in 24 hours.`,\n      statusCallback: `${process.env.NEXT_PUBLIC_APP_URL}/api/webhooks/twilio/sms-status`,\n    });\n\n    const duration = Date.now() - startTime;\n    logExternalApiCall('Twilio SMS', 'send_payment_link', duration);\n\n    logInfo('Payment SMS sent during AI call', {\n      invoiceReference: params.invoiceReference,\n      recipientPhone: params.recipientPhone.substring(0, 7) + '***', // Privacy\n      messageSid: message.sid,\n    });\n\n    return {\n      success: true,\n      paymentLink,\n      messageSid: message.sid,\n    };\n\n  } catch (error) {\n    const duration = Date.now() - startTime;\n    logExternalApiCall('Twilio SMS', 'send_payment_link', duration, error as Error);\n\n    logError('Failed to send payment link during call', error);\n\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error',\n    };\n  }\n}\n\n/**\n * Process call outcome and extract structured data from transcript\n *\n * Uses OpenAI to analyze the call transcript and extract:\n * - Payment outcome\n * - Payment promises\n * - Dispute details\n * - Next actions\n *\n * @param callTranscript Full call transcript\n * @returns Structured call outcome\n */\nexport async function processCallOutcome(params: {\n  callTranscript: string;\n  callSid: string;\n  invoiceId: string;\n}): Promise<{\n  outcome: CallOutcome;\n  summary: string;\n  nextAction?: 'accept_partial' | 'schedule_followup' | 'escalate' | 'pause' | 'complete' | 'agency_handoff';\n  scheduledFollowupDate?: string;\n  partialAmountAgreed?: number;\n  clientProposedDate?: string;\n  disputeDetails?: string;\n  paymentMethod?: 'sms_link' | 'ivr' | 'bank_transfer';\n}> {\n  try {\n    // AUDIT TASK #8: Use OpenAI GPT-4 to analyze transcript\n    const { openai } = await import('@/lib/openai');\n\n    const response = await openai.chat.completions.create({\n      model: 'gpt-4o-mini',\n      messages: [\n        {\n          role: 'system',\n          content: `Analyze this debt collection call transcript and extract structured data.\nReturn JSON with:\n- outcome: 'paid' | 'promise' | 'partial' | 'refused' | 'no_answer' | 'voicemail' | 'dispute' | 'financial_hardship' | 'error'\n- summary: 2-3 sentence summary of call\n- nextAction: recommended next action ('accept_partial' | 'schedule_followup' | 'escalate' | 'pause' | 'complete' | 'agency_handoff')\n- scheduledFollowupDate: if debtor promised to pay by date (YYYY-MM-DD)\n- partialAmountAgreed: if partial payment agreed (number)\n- clientProposedDate: if client suggested payment date (YYYY-MM-DD)\n- disputeDetails: if debt was disputed, what are the details\n- paymentMethod: how payment was arranged ('sms_link' | 'ivr' | 'bank_transfer')\n\nBe objective and factual. Extract specific commitments and dates mentioned.`,\n        },\n        {\n          role: 'user',\n          content: params.callTranscript,\n        },\n      ],\n      response_format: { type: 'json_object' },\n      temperature: 0.1, // Low temperature for consistency\n    });\n\n    const content = response.choices[0]?.message?.content;\n    if (!content) {\n      throw new Error('No response from OpenAI');\n    }\n\n    const analysis = JSON.parse(content);\n\n    logInfo('Call transcript analyzed successfully', {\n      callSid: params.callSid,\n      invoiceId: params.invoiceId,\n      outcome: analysis.outcome,\n    });\n\n    return analysis;\n\n  } catch (error) {\n    logError('Failed to process call outcome', error);\n\n    return {\n      outcome: 'error',\n      summary: 'Failed to analyze call transcript',\n    };\n  }\n}\n\n/**\n * Get call recording URL from Twilio\n *\n * @param callSid Twilio call SID\n * @returns Recording URL\n */\nexport async function getCallRecording(callSid: string): Promise<{\n  recordingUrl?: string;\n  duration?: number;\n  error?: string;\n}> {\n  try {\n    // AUDIT TASK #2: Twilio is configured for production\n    const client = getTwilioClient();\n    const recordings = await client.recordings.list({ callSid, limit: 1 });\n\n    if (recordings.length > 0) {\n      const recording = recordings[0];\n      return {\n        recordingUrl: `https://api.twilio.com${recording.uri.replace('.json', '.mp3')}`,\n        duration: parseInt(recording.duration || '0', 10),\n      };\n    }\n\n    return {\n      error: 'No recording found for this call',\n    };\n\n  } catch (error) {\n    return {\n      error: error instanceof Error ? error.message : 'Unknown error',\n    };\n  }\n}\n\n/**\n * Estimate AI call cost\n * Breakdown of costs per call:\n * - Twilio outbound call: ~£0.02/min to UK mobiles\n * - OpenAI Realtime API: ~$0.06/min for audio input, ~$0.24/min for audio output\n * - Average 5-minute call: ~£0.10 Twilio + ~$1.50 OpenAI = ~£1.30 total\n * - SMS payment link: +£0.04\n * - Recording storage: ~£0.01\n *\n * Total per call: ~£1.35 for 5-minute call with payment link\n */\nexport function estimateAICallCost(params: {\n  estimatedDurationMinutes: number;\n  includeSMS?: boolean;\n  includeRecording?: boolean;\n}): {\n  twilioVoice: number;\n  openaiRealtime: number;\n  sms: number;\n  recording: number;\n  total: number;\n} {\n  const { estimatedDurationMinutes, includeSMS = false, includeRecording = true } = params;\n\n  const twilioVoice = estimatedDurationMinutes * 0.02; // £0.02/min\n  const openaiRealtime = estimatedDurationMinutes * 0.30; // ~£0.30/min ($0.06 input + $0.24 output)\n  const sms = includeSMS ? 0.04 : 0;\n  const recording = includeRecording ? 0.01 : 0;\n\n  return {\n    twilioVoice,\n    openaiRealtime,\n    sms,\n    recording,\n    total: twilioVoice + openaiRealtime + sms + recording,\n  };\n}\n\n/**\n * Check if user has given consent for AI calls\n * Required by UK law before making automated calls\n * AUDIT TASK #2: Implemented consent check (LOW priority item #11)\n */\nexport async function checkCallConsent(userId: string): Promise<boolean> {\n  try {\n    // Note: This requires Firebase to be imported\n    // Lazy import to avoid circular dependencies\n    const { db } = await import('@/lib/firebase');\n\n    const userDoc = await db.collection('users').doc(userId).get();\n    const user = userDoc.data();\n\n    return user?.collectionsConsent?.callConsent === true &&\n           user?.collectionsConsent?.callRecordingConsent === true;\n  } catch (error) {\n    logError('Failed to check call consent', error);\n    // Fail closed - no consent if we can't verify\n    return false;\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[1]}