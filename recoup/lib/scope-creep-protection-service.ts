/**
 * Scope Creep Protection Service
 *
 * COMPETITIVE ADVANTAGE: Only 2 competitors (HoneyBook, Bonsai) have basic version
 *
 * Addresses: 45% of projects experience scope creep (PMI Pulse Report)
 * - Unclear deliverables lead to endless work
 * - Difficult to say "no" to clients
 * - Can't track extra work requested
 * - Revision limits not enforced
 *
 * Features:
 * - Project scope documentation with deliverable checklist
 * - Automatic scope change detection
 * - One-click change order generation
 * - Revision counter with visual tracking
 * - Scope creep alerts (hours exceed estimate by 20%+)
 * - Client-facing deliverable acceptance workflow
 * - Template responses for scope creep
 */

import { logger } from '@/utils/logger';
import { generateJSON } from '@/lib/ai-service';

export interface ProjectScope {
  id: string;
  projectId: string;
  userId: string;
  clientId: string;
  projectName: string;

  // Scope definition
  scopeStatement: string; // What's included
  deliverables: Deliverable[];
  exclusions: string[]; // Explicitly what's NOT included

  // Estimates
  estimatedHours: number;
  estimatedCost: number;
  buffer: number; // % buffer (e.g., 10%)

  // Revision policy
  revisions: {
    included: number; // e.g., 2 revisions included
    used: number; // How many used so far
    costPerAdditional: number; // £ per extra revision
  };

  // Tracking
  actualHours: number;
  actualCost: number;
  scopeChanges: ScopeChange[];

  // Status
  status: 'active' | 'completed' | 'paused';
  acceptedByClient: boolean;
  acceptedDate?: Date;

  createdAt: Date;
  updatedAt: Date;
}

export interface Deliverable {
  id: string;
  title: string;
  description: string;
  estimatedHours: number;
  actualHours: number;
  status: 'pending' | 'in_progress' | 'completed' | 'accepted';
  dueDate?: Date;
  completedDate?: Date;
  acceptedDate?: Date; // When client accepted
  acceptedBy?: string; // Client name/email
  dependencies: string[]; // Other deliverable IDs
}

export interface ScopeChange {
  id: string;
  projectScopeId: string;
  requestedDate: Date;
  requestedBy: 'client' | 'freelancer';

  // Change details
  type: 'addition' | 'modification' | 'removal';
  title: string;
  description: string;
  reason: string;

  // Impact
  impact: {
    hoursAdded: number;
    costAdded: number;
    timelineImpact: number; // Days
    newDeliverables: string[];
  };

  // Approval
  status: 'pending' | 'approved' | 'rejected';
  approvedBy?: string;
  approvedDate?: Date;
  rejectionReason?: string;

  // Change order
  changeOrderGenerated: boolean;
  changeOrderId?: string;
  invoiced: boolean;
}

export interface ScopeCreepAlert {
  id: string;
  projectScopeId: string;
  severity: 'warning' | 'critical';
  triggeredDate: Date;

  trigger: {
    type: 'hours_exceeded' | 'revision_limit' | 'scope_change_detected' | 'deliverable_added';
    details: string;
  };

  metrics: {
    estimatedHours: number;
    actualHours: number;
    percentOverage: number;
    estimatedCost: number;
    actualCost: number;
    costOverage: number;
  };

  recommendedActions: string[];
  autoGeneratedChangeOrder?: boolean;
}

export interface ChangeOrder {
  id: string;
  changeOrderNumber: string;
  projectScopeId: string;
  scopeChangeId: string;
  userId: string;
  clientId: string;

  // Change details
  title: string;
  description: string;
  newDeliverables: string[];

  // Pricing
  additionalHours: number;
  hourlyRate: number;
  additionalCost: number;
  totalProjectCost: number; // New total

  // Status
  status: 'draft' | 'sent' | 'approved' | 'rejected';
  sentDate?: Date;
  approvedDate?: Date;
  rejectedDate?: Date;
  rejectionReason?: string;

  // Invoice
  invoiceGenerated: boolean;
  invoiceId?: string;

  createdAt: Date;
  updatedAt: Date;
}

export interface ClientAcceptance {
  deliverableId: string;
  clientName: string;
  clientEmail: string;
  acceptedDate: Date;
  signature?: string;
  comments?: string;
  ipAddress: string;
}

// ==============================================================================
// SCOPE DEFINITION & TRACKING
// ==============================================================================

/**
 * Create project scope with deliverables
 */
export function createProjectScope(params: {
  projectId: string;
  userId: string;
  clientId: string;
  projectName: string;
  scopeStatement: string;
  deliverables: Array<{
    title: string;
    description: string;
    estimatedHours: number;
    dueDate?: Date;
  }>;
  exclusions?: string[];
  estimatedHours: number;
  estimatedCost: number;
  revisionsIncluded: number;
  costPerAdditionalRevision: number;
}): ProjectScope {
  const {
    projectId,
    userId,
    clientId,
    projectName,
    scopeStatement,
    deliverables,
    exclusions = [],
    estimatedHours,
    estimatedCost,
    revisionsIncluded,
    costPerAdditionalRevision,
  } = params;

  const deliverablesList: Deliverable[] = deliverables.map((d, index) => ({
    id: `del-${Date.now()}-${index}`,
    title: d.title,
    description: d.description,
    estimatedHours: d.estimatedHours,
    actualHours: 0,
    status: 'pending',
    dueDate: d.dueDate,
    dependencies: [],
  }));

  const scope: ProjectScope = {
    id: `scope-${Date.now()}`,
    projectId,
    userId,
    clientId,
    projectName,
    scopeStatement,
    deliverables: deliverablesList,
    exclusions,
    estimatedHours,
    estimatedCost,
    buffer: 10, // Default 10% buffer
    revisions: {
      included: revisionsIncluded,
      used: 0,
      costPerAdditional: costPerAdditionalRevision,
    },
    actualHours: 0,
    actualCost: 0,
    scopeChanges: [],
    status: 'active',
    acceptedByClient: false,
    createdAt: new Date(),
    updatedAt: new Date(),
  };

  logger.info('Project scope created', {
    projectId,
    deliverablesCount: deliverablesList.length,
    estimatedHours,
  });

  return scope;
}

/**
 * Track time against project scope
 */
export function trackTimeAgainstScope(params: {
  scope: ProjectScope;
  hoursWorked: number;
  deliverableId?: string;
  hourlyRate: number;
}): {
  updatedScope: ProjectScope;
  alert?: ScopeCreepAlert;
} {
  const { scope, hoursWorked, deliverableId, hourlyRate } = params;

  // Update hours
  const newActualHours = scope.actualHours + hoursWorked;
  const newActualCost = newActualHours * hourlyRate;

  // Update deliverable if specified
  const updatedDeliverables = scope.deliverables.map(d => {
    if (d.id === deliverableId) {
      return {
        ...d,
        actualHours: d.actualHours + hoursWorked,
      };
    }
    return d;
  });

  const updatedScope: ProjectScope = {
    ...scope,
    actualHours: newActualHours,
    actualCost: newActualCost,
    deliverables: updatedDeliverables,
    updatedAt: new Date(),
  };

  // Check for scope creep
  const percentOverage = ((newActualHours - scope.estimatedHours) / scope.estimatedHours) * 100;
  const bufferThreshold = scope.estimatedHours * (1 + scope.buffer / 100);

  let alert: ScopeCreepAlert | undefined;

  if (newActualHours > bufferThreshold) {
    const severity: 'warning' | 'critical' =
      percentOverage > 50 ? 'critical' : 'warning';

    alert = {
      id: `alert-${Date.now()}`,
      projectScopeId: scope.id,
      severity,
      triggeredDate: new Date(),
      trigger: {
        type: 'hours_exceeded',
        details: `Project hours ${percentOverage.toFixed(0)}% over estimate`,
      },
      metrics: {
        estimatedHours: scope.estimatedHours,
        actualHours: newActualHours,
        percentOverage,
        estimatedCost: scope.estimatedCost,
        actualCost: newActualCost,
        costOverage: newActualCost - scope.estimatedCost,
      },
      recommendedActions: [
        'Review scope with client',
        'Generate change order for additional work',
        percentOverage > 30 ? 'Consider pausing work until scope clarified' : 'Increase rate for additional hours',
      ],
      autoGeneratedChangeOrder: percentOverage > 50,
    };

    logger.warn('Scope creep detected', {
      projectId: scope.projectId,
      percentOverage,
      severity,
    });
  }

  return { updatedScope, alert };
}

// ==============================================================================
// REVISION TRACKING
// ==============================================================================

/**
 * Track revision usage
 */
export function trackRevision(params: {
  scope: ProjectScope;
  deliverableId: string;
}): {
  updatedScope: ProjectScope;
  alert?: ScopeCreepAlert;
  additionalCost: number;
} {
  const { scope, deliverableId } = params;

  const newUsed = scope.revisions.used + 1;
  const additionalCost = newUsed > scope.revisions.included
    ? scope.revisions.costPerAdditional
    : 0;

  const updatedScope: ProjectScope = {
    ...scope,
    revisions: {
      ...scope.revisions,
      used: newUsed,
    },
    actualCost: scope.actualCost + additionalCost,
    updatedAt: new Date(),
  };

  let alert: ScopeCreepAlert | undefined;

  if (newUsed > scope.revisions.included) {
    alert = {
      id: `alert-${Date.now()}`,
      projectScopeId: scope.id,
      severity: 'warning',
      triggeredDate: new Date(),
      trigger: {
        type: 'revision_limit',
        details: `Revision limit exceeded: ${newUsed} of ${scope.revisions.included} included revisions used`,
      },
      metrics: {
        estimatedHours: scope.estimatedHours,
        actualHours: scope.actualHours,
        percentOverage: 0,
        estimatedCost: scope.estimatedCost,
        actualCost: updatedScope.actualCost,
        costOverage: additionalCost,
      },
      recommendedActions: [
        `Bill client £${additionalCost.toFixed(2)} for additional revision`,
        'Remind client of revision policy',
        'Consider increasing revision limit in future contracts',
      ],
      autoGeneratedChangeOrder: false,
    };
  }

  return { updatedScope, alert, additionalCost };
}

/**
 * Get revision status summary
 */
export function getRevisionStatus(scope: ProjectScope): {
  included: number;
  used: number;
  remaining: number;
  percentUsed: number;
  overageCount: number;
  overageCost: number;
  status: 'available' | 'low' | 'exceeded';
} {
  const included = scope.revisions.included;
  const used = scope.revisions.used;
  const remaining = Math.max(0, included - used);
  const percentUsed = (used / included) * 100;
  const overageCount = Math.max(0, used - included);
  const overageCost = overageCount * scope.revisions.costPerAdditional;

  const status: 'available' | 'low' | 'exceeded' =
    used >= included ? 'exceeded' :
    remaining <= 1 ? 'low' : 'available';

  return {
    included,
    used,
    remaining,
    percentUsed,
    overageCount,
    overageCost,
    status,
  };
}

// ==============================================================================
// SCOPE CHANGE MANAGEMENT
// ==============================================================================

/**
 * Detect potential scope change using AI
 */
export async function detectScopeChange(params: {
  scope: ProjectScope;
  clientRequest: string;
}): Promise<{
  isScopeChange: boolean;
  confidence: number; // 0-100
  reasoning: string;
  suggestedChange?: Partial<ScopeChange>;
}> {
  const { scope, clientRequest } = params;

  const prompt = `You are a project scope expert analyzing client requests.

Original Project Scope:
${scope.scopeStatement}

Deliverables:
${scope.deliverables.map(d => `- ${d.title}: ${d.description}`).join('\n')}

Exclusions:
${scope.exclusions.map(e => `- ${e}`).join('\n')}

Client Request:
"${clientRequest}"

Determine if this client request is within the original scope or represents scope creep (additional work beyond what was agreed).

Respond in JSON format:
{
  "isScopeChange": true/false,
  "confidence": 0-100,
  "reasoning": "Explanation of why this is/isn't scope creep",
  "type": "addition" | "modification" | "removal" | null,
  "estimatedHoursAdded": number (if scope change),
  "suggestedResponse": "Template response to client"
}`;

  const parsed = await generateJSON(prompt);

  logger.info('Scope change detection', {
    projectId: scope.projectId,
    isScopeChange: parsed.isScopeChange,
    confidence: parsed.confidence,
  });

  return {
    isScopeChange: parsed.isScopeChange,
    confidence: parsed.confidence,
    reasoning: parsed.reasoning,
    suggestedChange: parsed.isScopeChange ? {
      type: parsed.type,
      title: 'Client Requested Change',
      description: clientRequest,
      reason: parsed.reasoning,
      impact: {
        hoursAdded: parsed.estimatedHoursAdded || 0,
        costAdded: 0,
        timelineImpact: 0,
        newDeliverables: [],
      },
      status: 'pending',
      requestedBy: 'client',
      requestedDate: new Date(),
    } : undefined,
  };
}

/**
 * Create scope change request
 */
export function createScopeChange(params: {
  scope: ProjectScope;
  type: 'addition' | 'modification' | 'removal';
  title: string;
  description: string;
  reason: string;
  hoursAdded: number;
  hourlyRate: number;
  requestedBy: 'client' | 'freelancer';
}): ScopeChange {
  const { scope, type, title, description, reason, hoursAdded, hourlyRate, requestedBy } = params;

  const costAdded = hoursAdded * hourlyRate;

  const change: ScopeChange = {
    id: `change-${Date.now()}`,
    projectScopeId: scope.id,
    requestedDate: new Date(),
    requestedBy,
    type,
    title,
    description,
    reason,
    impact: {
      hoursAdded,
      costAdded,
      timelineImpact: Math.ceil(hoursAdded / 8), // Assume 8hr work days
      newDeliverables: [],
    },
    status: 'pending',
    changeOrderGenerated: false,
    invoiced: false,
  };

  logger.info('Scope change created', {
    projectId: scope.projectId,
    type,
    hoursAdded,
    costAdded,
  });

  return change;
}

// ==============================================================================
// CHANGE ORDERS
// ==============================================================================

/**
 * Generate change order from scope change
 */
export function generateChangeOrder(params: {
  scope: ProjectScope;
  scopeChange: ScopeChange;
  hourlyRate: number;
}): ChangeOrder {
  const { scope, scopeChange, hourlyRate } = params;

  const changeOrderNumber = `CO-${Date.now()}`;
  const additionalCost = scopeChange.impact.hoursAdded * hourlyRate;
  const newTotalCost = scope.estimatedCost + additionalCost;

  const changeOrder: ChangeOrder = {
    id: `co-${Date.now()}`,
    changeOrderNumber,
    projectScopeId: scope.id,
    scopeChangeId: scopeChange.id,
    userId: scope.userId,
    clientId: scope.clientId,
    title: scopeChange.title,
    description: scopeChange.description,
    newDeliverables: scopeChange.impact.newDeliverables,
    additionalHours: scopeChange.impact.hoursAdded,
    hourlyRate,
    additionalCost,
    totalProjectCost: newTotalCost,
    status: 'draft',
    invoiceGenerated: false,
    createdAt: new Date(),
    updatedAt: new Date(),
  };

  logger.info('Change order generated', {
    changeOrderNumber,
    additionalCost,
    newTotalCost,
  });

  return changeOrder;
}

/**
 * Approve change order
 */
export function approveChangeOrder(params: {
  changeOrder: ChangeOrder;
  approvedBy: string;
}): ChangeOrder {
  return {
    ...params.changeOrder,
    status: 'approved',
    approvedDate: new Date(),
    updatedAt: new Date(),
  };
}

// ==============================================================================
// CLIENT ACCEPTANCE
// ==============================================================================

/**
 * Mark deliverable as completed (pending client acceptance)
 */
export function completeDeliverable(params: {
  scope: ProjectScope;
  deliverableId: string;
}): ProjectScope {
  const updatedDeliverables = params.scope.deliverables.map(d => {
    if (d.id === params.deliverableId) {
      return {
        ...d,
        status: 'completed' as const,
        completedDate: new Date(),
      };
    }
    return d;
  });

  return {
    ...params.scope,
    deliverables: updatedDeliverables,
    updatedAt: new Date(),
  };
}

/**
 * Client accepts deliverable
 */
export function acceptDeliverable(params: {
  scope: ProjectScope;
  deliverableId: string;
  acceptance: Omit<ClientAcceptance, 'deliverableId'>;
}): {
  updatedScope: ProjectScope;
  acceptance: ClientAcceptance;
} {
  const { scope, deliverableId, acceptance: acceptanceData } = params;

  const updatedDeliverables = scope.deliverables.map(d => {
    if (d.id === deliverableId) {
      return {
        ...d,
        status: 'accepted' as const,
        acceptedDate: new Date(),
        acceptedBy: acceptanceData.clientEmail,
      };
    }
    return d;
  });

  const updatedScope: ProjectScope = {
    ...scope,
    deliverables: updatedDeliverables,
    updatedAt: new Date(),
  };

  const acceptance: ClientAcceptance = {
    deliverableId,
    ...acceptanceData,
  };

  logger.info('Deliverable accepted by client', {
    deliverableId,
    clientEmail: acceptance.clientEmail,
  });

  return { updatedScope, acceptance };
}

/**
 * Check if all deliverables are accepted
 */
export function areAllDeliverablesAccepted(scope: ProjectScope): boolean {
  return scope.deliverables.every(d => d.status === 'accepted');
}

// ==============================================================================
// TEMPLATE RESPONSES
// ==============================================================================

/**
 * Get template response for scope creep situations
 */
export function getScopeCreepTemplate(params: {
  situation: 'revision_limit' | 'additional_work' | 'scope_change' | 'hours_exceeded';
  clientName: string;
  projectName: string;
  additionalCost?: number;
  revisionsUsed?: number;
  revisionsIncluded?: number;
}): string {
  const { situation, clientName, projectName, additionalCost, revisionsUsed, revisionsIncluded } = params;

  const templates = {
    revision_limit: `Hi ${clientName},

I've completed revision #${revisionsUsed} for ${projectName}. As per our agreement, the project includes ${revisionsIncluded} revisions.

Since we've now exceeded the included revisions, additional revisions are £${additionalCost?.toFixed(2)} each.

Would you like to proceed with another revision at this rate, or shall we consider the current version final?

Thanks!`,

    additional_work: `Hi ${clientName},

Thanks for your request regarding ${projectName}. I've reviewed it, and this would be additional work beyond our original scope.

I'd be happy to help with this! The additional work would be approximately £${additionalCost?.toFixed(2)}.

I can send over a change order if you'd like to proceed, or we can discuss adjusting the scope to accommodate this within the current budget.

Let me know what works best for you!`,

    scope_change: `Hi ${clientName},

I wanted to touch base about the recent request for ${projectName}. This falls outside our original agreement, which covered:

[Original scope summary]

I can absolutely help with this additional work. I've prepared a change order outlining the additional time and cost (£${additionalCost?.toFixed(2)}).

Would you like me to send that over?`,

    hours_exceeded: `Hi ${clientName},

Quick update on ${projectName}: We've exceeded the estimated hours due to [reason].

I wanted to be transparent about this and discuss how to proceed. We can:
1. Continue at the current scope with additional billing
2. Reduce remaining deliverables to stay within budget
3. Extend the budget

What works best for you?`,
  };

  return templates[situation];
}

/**
 * Get scope protection summary
 */
export function getScopeProtectionSummary(scope: ProjectScope): {
  hoursUtilization: number; // %
  budgetUtilization: number; // %
  revisionsUtilization: number; // %
  overallRisk: 'low' | 'medium' | 'high';
  alerts: string[];
  recommendations: string[];
} {
  const hoursUtilization = (scope.actualHours / scope.estimatedHours) * 100;
  const budgetUtilization = (scope.actualCost / scope.estimatedCost) * 100;
  const revisionStatus = getRevisionStatus(scope);
  const revisionsUtilization = revisionStatus.percentUsed;

  const alerts: string[] = [];
  const recommendations: string[] = [];

  if (hoursUtilization > 80) {
    alerts.push(`Hours ${hoursUtilization.toFixed(0)}% utilized - approaching limit`);
  }

  if (budgetUtilization > 80) {
    alerts.push(`Budget ${budgetUtilization.toFixed(0)}% utilized`);
  }

  if (revisionStatus.status === 'exceeded') {
    alerts.push(`Revision limit exceeded by ${revisionStatus.overageCount}`);
  }

  const overallRisk: 'low' | 'medium' | 'high' =
    hoursUtilization > 100 || budgetUtilization > 100 ? 'high' :
    hoursUtilization > 80 || budgetUtilization > 80 ? 'medium' : 'low';

  if (overallRisk === 'high') {
    recommendations.push('Generate change order for additional work');
    recommendations.push('Review scope with client immediately');
  }

  if (scope.scopeChanges.filter(c => c.status === 'pending').length > 0) {
    recommendations.push('Pending scope changes need approval');
  }

  return {
    hoursUtilization,
    budgetUtilization,
    revisionsUtilization,
    overallRisk,
    alerts,
    recommendations,
  };
}
