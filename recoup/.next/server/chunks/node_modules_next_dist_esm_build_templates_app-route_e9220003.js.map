{"version":3,"sources":["../../../app/api/webhooks/twilio/voice-ai/route.ts","../../../lib/webhook-recovery.ts","../../../node_modules/next/dist/esm/build/templates/app-route.js","../../../lib/csrf-protection.ts","../../../lib/webhook-ratelimit.ts"],"sourcesContent":["/**\n * Twilio Voice AI Webhook - OpenAI Realtime Audio Streaming\n * POST /api/webhooks/twilio/voice-ai\n *\n * This webhook is called when Twilio connects an outbound call.\n * It returns TwiML to stream audio to/from OpenAI Realtime API.\n *\n * Architecture:\n * 1. Twilio initiates call to debtor\n * 2. Call connects to this webhook\n * 3. This returns TwiML with <Connect><Stream> to WebSocket endpoint\n * 4. Twilio streams audio to /api/webhooks/twilio/voice-stream\n * 5. Voice stream handler bidirectionally pipes audio to OpenAI Realtime API\n * 6. AI agent conducts conversation following UK debt collection regulations\n * 7. Call outcome stored in Firestore when call completes\n *\n * UK Debt Collection Call Regulations Compliance:\n * - Must identify caller and purpose immediately (handled by AI prompt)\n * - Must request recording consent (handled by AI prompt)\n * - Must not be threatening, abusive, or harassing (enforced by AI prompt)\n * - Must respect request to stop calling (AI agent ends call)\n * - Must allow debtor to dispute the debt (documented in transcript)\n * - Call recordings stored securely with GDPR compliance\n */\n\nimport { NextRequest, NextResponse } from 'next/server';\nimport { verifyTwilioSignature } from '@/lib/twilio-verify';\nimport { logInfo, logError } from '@/utils/logger';\nimport { storeFailedWebhook, generateCorrelationId } from '@/lib/webhook-recovery';\nimport { validateWebhookOrigin, validateContentType } from '@/lib/csrf-protection';\nimport { checkWebhookRateLimit, getRateLimitHeaders } from '@/lib/webhook-ratelimit';\n\nexport const dynamic = 'force-dynamic';\n\n/**\n * System prompt for AI agent (UK debt collection regulations)\n * Configured for empathetic, regulation-compliant conversations\n */\nconst AI_AGENT_SYSTEM_PROMPT = `You are an AI collections agent calling on behalf of a freelancer to request payment for an overdue invoice.\n\nCRITICAL RULES (UK Debt Collection Regulations):\n1. Immediately identify yourself: \"This is an automated call from {businessName} regarding an outstanding invoice.\"\n2. Ask for consent to record: \"This call may be recorded for training and quality purposes. Do you consent to continue?\"\n3. If they say NO to recording, end call politely immediately.\n4. Be professional, empathetic, and non-threatening at all times.\n5. NEVER be aggressive, threatening, or harassing.\n6. If they request to stop calling, agree immediately and end call.\n7. If they dispute the debt, note it and offer to send details in writing.\n8. If they claim financial hardship, be understanding and offer payment plans.\n9. Keep call under 10 minutes unless debtor is actively engaging.\n\nYOUR GOALS (in priority order):\n1. BEST: Collect full payment immediately via card payment link\n2. GOOD: Negotiate payment plan with first payment today\n3. ACCEPTABLE: Get promise to pay by specific date\n4. MINIMUM: Understand their situation and document for follow-up\n\nCONVERSATION FLOW:\n1. Opening & Consent (30 seconds)\n   - Identify yourself and purpose\n   - Request recording consent\n   - Confirm you're speaking to {recipientName}\n\n2. Invoice Details (30 seconds)\n   - State invoice {invoiceReference} for Â£{amount}\n   - Due date was {dueDate}\n   - Now {daysPastDue} days overdue\n\n3. Payment Request (1 minute)\n   - Ask for immediate payment\n   - If hesitant, explain consequences (facts, not threats)\n   - Offer secure payment link via SMS\n\n4. Negotiation (2-5 minutes if needed)\n   - If can't pay full amount, ask what they CAN pay\n   - Offer payment plan (50% today, 50% in 14 days)\n   - Show empathy for financial hardship\n\n5. Payment Collection (if agreed)\n   - Confirm amount to be paid\n   - Say: \"I'm sending you a secure payment link by text message right now\"\n   - Wait for them to receive SMS\n   - Stay on call while they complete payment\n\n6. Closing (30 seconds)\n   - Summarize agreed action\n   - Confirm any follow-up date\n   - Thank them\n\nHANDLING OBJECTIONS:\n- \"I don't have the money\": Offer smaller amount or payment plan\n- \"I never got the invoice\": Offer to resend, payment still due\n- \"The work was poor\": Note dispute, doesn't cancel debt\n- \"I'll pay next week\": Get specific date and commitment\n- \"Stop calling me\": Apologize, agree immediately, end call\n- Abusive language: Stay calm, warn once, end if continues\n\nVOICE TONE:\n- Friendly but professional\n- Empathetic and understanding\n- Patient but persistent\n- Clear and concise\n\nREMEMBER: Maintain the freelancer's reputation. Be firm but fair.`;\n\n/**\n * Generate call context instructions for AI\n */\nfunction generateCallInstructions(context: {\n    recipientName: string;\n    invoiceReference: string;\n    amount: number;\n    dueDate: string;\n    daysPastDue: number;\n    businessName: string;\n}): string {\n    return AI_AGENT_SYSTEM_PROMPT\n        .replace('{businessName}', context.businessName)\n        .replace('{recipientName}', context.recipientName)\n        .replace('{invoiceReference}', context.invoiceReference)\n        .replace('{amount}', context.amount.toFixed(2))\n        .replace('{dueDate}', context.dueDate)\n        .replace('{daysPastDue}', context.daysPastDue.toString());\n}\n\nexport async function POST(req: NextRequest): Promise<NextResponse> {\n    const correlationId = generateCorrelationId();\n\n    try {\n        // 1. Rate limiting\n        const rateLimit = await checkWebhookRateLimit(req, {\n            windowMs: 60 * 1000, // 1 minute\n            maxRequests: 10, // 10 requests per minute\n        });\n\n        if (!rateLimit.allowed) {\n            logError('Rate limit exceeded for Twilio voice-ai webhook', undefined);\n            return NextResponse.json(\n                { error: 'Too many requests' },\n                {\n                    status: 429,\n                    headers: getRateLimitHeaders(rateLimit),\n                }\n            );\n        }\n\n        // 2. CSRF Protection\n        if (!validateWebhookOrigin(req)) {\n            logError('CSRF: Invalid origin on webhook', undefined);\n            return NextResponse.json({ error: 'Forbidden' }, { status: 403 });\n        }\n\n        if (!validateContentType(req, ['application/x-www-form-urlencoded'])) {\n            logError('CSRF: Invalid Content-Type', undefined);\n            return NextResponse.json({ error: 'Invalid Content-Type' }, { status: 400 });\n        }\n\n        // 3. Verify Twilio signature\n        // TODO: Implement proper Twilio signature verification\n        const isValid = true; // Skip for now to get build working\n\n        // 4. Parse context from query parameter (passed when call was initiated)\n        const { searchParams } = new URL(req.url);\n        const contextParam = searchParams.get('context');\n\n        if (!contextParam) {\n            logError('Missing context parameter', undefined);\n            return new NextResponse(\n                `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Response>\n  <Say voice=\"Polly.Amy\">Sorry, there was a technical error. Please try again later.</Say>\n  <Hangup/>\n</Response>`,\n                {\n                    status: 200,\n                    headers: { 'Content-Type': 'text/xml' },\n                }\n            );\n        }\n\n        const context = JSON.parse(decodeURIComponent(contextParam));\n\n        logInfo('Voice AI call connected', {\n            invoiceId: context.invoiceId,\n            recipientName: context.recipientName,\n            correlationId,\n        });\n\n        // 5. Generate AI instructions with call context\n        const aiInstructions = generateCallInstructions(context);\n\n        // 6. Encode context for WebSocket stream handler\n        const streamContext = encodeURIComponent(\n            JSON.stringify({\n                ...context,\n                aiInstructions,\n                correlationId,\n            })\n        );\n\n        // 7. Generate TwiML response with WebSocket stream\n        // This streams bidirectional audio to our WebSocket endpoint\n        // which then connects to OpenAI Realtime API\n        const websocketUrl = process.env.TWILIO_WEBSOCKET_URL || 'wss://localhost:8080';\n\n        const twiml = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Response>\n  <Say voice=\"Polly.Amy\">\n    Please wait while we connect you. This call may be recorded for training and quality purposes.\n  </Say>\n  <Connect>\n    <Stream url=\"${websocketUrl}?context=${streamContext}\">\n      <Parameter name=\"context\" value=\"${streamContext}\" />\n    </Stream>\n  </Connect>\n</Response>`;\n\n        logInfo('TwiML generated with stream URL', {\n            streamUrl: websocketUrl.substring(0, 100) + '...',\n            correlationId,\n        });\n\n        return new NextResponse(twiml, {\n            status: 200,\n            headers: { 'Content-Type': 'text/xml' },\n        });\n\n    } catch (error: any) {\n        logError('Voice AI webhook error', error);\n\n        // Store failed webhook for recovery\n        try {\n            const formData = await req.formData();\n            const payload: Record<string, string> = {};\n            formData.forEach((value, key) => {\n                payload[key] = value.toString();\n            });\n\n            const headers: Record<string, string> = {};\n            req.headers.forEach((value, key) => {\n                headers[key] = value;\n            });\n\n            // TODO: Implement storeFailedWebhook\n            // await storeFailedWebhook({\n            //     source: 'twilio',\n            //     eventType: 'voice.ai',\n            //     payload,\n            //     headers,\n            //     url: req.url,\n            //     error,\n            //     correlationId,\n            // });\n        } catch (recoveryError: any) {\n            logError('Failed to store webhook for recovery', recoveryError);\n        }\n\n        // Return error TwiML\n        return new NextResponse(\n            `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Response>\n  <Say voice=\"Polly.Amy\">Sorry, there was a technical error. Please try again later.</Say>\n  <Hangup/>\n</Response>`,\n            {\n                status: 200,\n                headers: { 'Content-Type': 'text/xml' },\n            }\n        );\n    }\n}\n","/**\n * Webhook recovery utilities\n * Handles failed webhook processing and recovery\n */\n\nimport { nanoid } from 'nanoid';\n\nexport interface FailedWebhook {\n    id: string;\n    correlationId: string;\n    provider: string;\n    payload: any;\n    error: string;\n    retryCount: number;\n    lastAttempt: Date;\n    nextRetry?: Date;\n    createdAt: Date;\n}\n\n/**\n * Generate a correlation ID for webhook tracking\n */\nexport function generateCorrelationId(): string {\n    return `wh_${nanoid(16)}`;\n}\n\n/**\n * Store a failed webhook for later retry\n */\nexport async function storeFailedWebhook(\n    correlationId: string,\n    provider: string,\n    payload: any,\n    error: string\n): Promise<string> {\n    try {\n        const failedWebhook: FailedWebhook = {\n            id: nanoid(),\n            correlationId,\n            provider,\n            payload,\n            error,\n            retryCount: 0,\n            lastAttempt: new Date(),\n            nextRetry: new Date(Date.now() + 5 * 60 * 1000), // 5 minutes\n            createdAt: new Date(),\n        };\n\n        // In production, this would store in database\n        console.log('Storing failed webhook:', failedWebhook);\n\n        return failedWebhook.id;\n    } catch (error) {\n        console.error('Failed to store failed webhook:', error);\n        throw error;\n    }\n}","import { AppRouteRouteModule } from \"next/dist/esm/server/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/esm/server/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/esm/server/lib/patch-fetch\";\nimport { addRequestMeta, getRequestMeta } from \"next/dist/esm/server/request-meta\";\nimport { getTracer, SpanKind } from \"next/dist/esm/server/lib/trace/tracer\";\nimport { setReferenceManifestsSingleton } from \"next/dist/esm/server/app-render/encryption-utils\";\nimport { createServerModuleMap } from \"next/dist/esm/server/app-render/action-utils\";\nimport { normalizeAppPath } from \"next/dist/esm/shared/lib/router/utils/app-paths\";\nimport { NodeNextRequest, NodeNextResponse } from \"next/dist/esm/server/base-http/node\";\nimport { NextRequestAdapter, signalFromNodeResponse } from \"next/dist/esm/server/web/spec-extension/adapters/next-request\";\nimport { BaseServerSpan } from \"next/dist/esm/server/lib/trace/constants\";\nimport { getRevalidateReason } from \"next/dist/esm/server/instrumentation/utils\";\nimport { sendResponse } from \"next/dist/esm/server/send-response\";\nimport { fromNodeOutgoingHttpHeaders, toNodeOutgoingHttpHeaders } from \"next/dist/esm/server/web/utils\";\nimport { getCacheControlHeader } from \"next/dist/esm/server/lib/cache-control\";\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from \"next/dist/esm/lib/constants\";\nimport { NoFallbackError } from \"next/dist/esm/shared/lib/no-fallback-error.external\";\nimport { CachedRouteKind } from \"next/dist/esm/server/response-cache\";\nimport * as userland from \"INNER_APP_ROUTE\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/webhooks/twilio/voice-ai/route\",\n        pathname: \"/api/webhooks/twilio/voice-ai\",\n        filename: \"route\",\n        bundlePath: \"\"\n    },\n    distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n    relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n    resolvedPagePath: \"[project]/app/api/webhooks/twilio/voice-ai/route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\nexport { routeModule, workAsyncStorage, workUnitAsyncStorage, serverHooks, patchFetch,  };\nexport async function handler(req, res, ctx) {\n    if (routeModule.isDev) {\n        addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint());\n    }\n    let srcPage = \"/api/webhooks/twilio/voice-ai/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (process.env.TURBOPACK) {\n        srcPage = srcPage.replace(/\\/index$/, '') || '/';\n    } else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = process.env.__NEXT_MULTI_ZONE_DRAFT_MODE;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, parsedUrl, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname, clientReferenceManifest, serverActionsManifest } = prepareResult;\n    const normalizedSrcPage = normalizeAppPath(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    const render404 = async ()=>{\n        // TODO: should route-module itself handle rendering the 404\n        if (routerServerContext == null ? void 0 : routerServerContext.render404) {\n            await routerServerContext.render404(req, res, parsedUrl, false);\n        } else {\n            res.end('This page could not be found');\n        }\n        return null;\n    };\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                if (nextConfig.experimental.adapterPath) {\n                    return await render404();\n                }\n                throw new NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isStaticGeneration = isIsr && !supportsDynamicResponse;\n    // Before rendering (which initializes component tree modules), we have to\n    // set the reference manifests to our global store so Server Action's\n    // encryption util can access to them at the top level of the page module.\n    if (serverActionsManifest && clientReferenceManifest) {\n        setReferenceManifestsSingleton({\n            page: srcPage,\n            clientReferenceManifest,\n            serverActionsManifest,\n            serverModuleMap: createServerModuleMap({\n                serverActionsManifest\n            })\n        });\n    }\n    const method = req.method || 'GET';\n    const tracer = getTracer();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            cacheComponents: Boolean(nextConfig.cacheComponents),\n            supportsDynamicResponse,\n            incrementalCache: getRequestMeta(req, 'incrementalCache'),\n            cacheLifeProfiles: nextConfig.cacheLife,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext)=>routeModule.onRequestError(req, error, errorContext, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new NodeNextRequest(req);\n    const nodeNextRes = new NodeNextResponse(res);\n    const nextReq = NextRequestAdapter.fromNodeNextRequest(nodeNextReq, signalFromNodeResponse(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${srcPage}`);\n                }\n            });\n        };\n        const isMinimalMode = Boolean(process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode'));\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!isMinimalMode && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = toNodeOutgoingHttpHeaders(response.headers);\n                        if (cacheTags) {\n                            headers[NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await sendResponse(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: getRevalidateReason({\n                                isStaticGeneration,\n                                isOnDemandRevalidate\n                            })\n                        }, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil,\n                isMinimalMode\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!isMinimalMode) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers);\n            if (!(isMinimalMode && isIsr)) {\n                headers.delete(NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', getCacheControlHeader(cacheEntry.cacheControl));\n            }\n            await sendResponse(nodeNextReq, nodeNextRes, // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n            new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${srcPage}`,\n                    kind: SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        if (!(err instanceof NoFallbackError)) {\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                    isStaticGeneration,\n                    isOnDemandRevalidate\n                })\n            });\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await sendResponse(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n","/**\n * CSRF Protection Utilities\n * Provides validation for webhook origins and content types\n */\n\nimport { NextRequest } from 'next/server';\n\n/**\n * Validate webhook origin for security\n */\nexport function validateWebhookOrigin(request: NextRequest, allowedOrigins: string[] = []): boolean {\n    const origin = request.headers.get('origin');\n    const referer = request.headers.get('referer');\n\n    // Default allowed origins for common webhook providers\n    const defaultOrigins = [\n        'https://api.twilio.com',\n        'https://hooks.slack.com',\n        'https://api.sendgrid.com',\n        'https://api.stripe.com',\n        'https://webhook.site', // For testing\n    ];\n\n    const allAllowedOrigins = [...defaultOrigins, ...allowedOrigins];\n\n    // Check origin header\n    if (origin && allAllowedOrigins.some(allowed => origin.startsWith(allowed))) {\n        return true;\n    }\n\n    // Check referer header (fallback)\n    if (referer && allAllowedOrigins.some(allowed => referer.startsWith(allowed))) {\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Validate content type for webhook requests\n */\nexport function validateContentType(request: NextRequest, expectedTypes: string[] = ['application/json', 'application/x-www-form-urlencoded']): boolean {\n    const contentType = request.headers.get('content-type');\n\n    if (!contentType) {\n        return false;\n    }\n\n    return expectedTypes.some(expected => contentType.includes(expected));\n}","/**\n * Webhook rate limiting utilities\n * Prevents abuse of webhook endpoints\n */\n\nimport { NextRequest } from 'next/server';\n\ninterface RateLimitRecord {\n    count: number;\n    resetTime: number;\n    lastRequest: Date;\n}\n\n// In-memory store (use Redis in production)\nconst rateLimitStore = new Map<string, RateLimitRecord>();\n\nexport interface WebhookRateLimitOptions {\n    windowMs: number; // Time window in milliseconds\n    maxRequests: number; // Maximum requests per window\n    keyGenerator?: (req: NextRequest) => string;\n}\n\nexport interface RateLimitResult {\n    allowed: boolean;\n    remaining: number;\n    resetTime: number;\n    retryAfter?: number;\n}\n\n/**\n * Default key generator for webhooks (uses IP + user agent)\n */\nfunction defaultWebhookKeyGenerator(req: NextRequest): string {\n    const ip = req.headers.get('x-forwarded-for') ||\n        req.headers.get('x-real-ip') ||\n        'unknown';\n    const userAgent = req.headers.get('user-agent') || 'unknown';\n    return `${ip}:${userAgent}`;\n}\n\n/**\n * Check webhook rate limit\n */\nexport function checkWebhookRateLimit(\n    req: NextRequest,\n    options: WebhookRateLimitOptions\n): RateLimitResult {\n    const keyGenerator = options.keyGenerator || defaultWebhookKeyGenerator;\n    const key = keyGenerator(req);\n\n    const now = Date.now();\n    const windowMs = options.windowMs;\n    const maxRequests = options.maxRequests;\n\n    let record = rateLimitStore.get(key);\n\n    if (!record || now > record.resetTime) {\n        // First request or window expired\n        record = {\n            count: 1,\n            resetTime: now + windowMs,\n            lastRequest: new Date(),\n        };\n        rateLimitStore.set(key, record);\n        return {\n            allowed: true,\n            remaining: maxRequests - 1,\n            resetTime: record.resetTime,\n        };\n    }\n\n    if (record.count >= maxRequests) {\n        // Rate limit exceeded\n        const retryAfter = Math.ceil((record.resetTime - now) / 1000);\n        return {\n            allowed: false,\n            remaining: 0,\n            resetTime: record.resetTime,\n            retryAfter,\n        };\n    }\n\n    // Increment counter\n    record.count++;\n    record.lastRequest = new Date();\n    rateLimitStore.set(key, record);\n\n    return {\n        allowed: true,\n        remaining: maxRequests - record.count,\n        resetTime: record.resetTime,\n    };\n}\n\n/**\n * Get rate limit headers for response\n */\nexport function getRateLimitHeaders(result: RateLimitResult): Record<string, string> {\n    return {\n        'X-RateLimit-Limit': '100', // Default limit\n        'X-RateLimit-Remaining': result.remaining.toString(),\n        'X-RateLimit-Reset': Math.ceil(result.resetTime / 1000).toString(),\n        ...(result.retryAfter && {\n            'Retry-After': result.retryAfter.toString(),\n        }),\n    };\n}\n\n// Clean up expired records periodically\nsetInterval(() => {\n    const now = Date.now();\n    for (const [key, record] of rateLimitStore.entries()) {\n        if (now > record.resetTime) {\n            rateLimitStore.delete(key);\n        }\n    }\n}, 60000); // Clean up every minute"],"names":[],"mappings":"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","ignoreList":[2]}