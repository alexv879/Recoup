{"version":3,"sources":["../../../services/transactionService.ts","../../../services/agencyHandoffService.ts","../../../app/api/collections/agency-handoff/route.ts","../../../node_modules/next/src/build/templates/app-route.ts"],"sourcesContent":["/**\n * Transaction Service\n * Handles financial transactions and agency recovery processes\n */\n\nexport interface AgencyRecoveryTransaction {\n    id: string;\n    invoiceId: string;\n    amount: number;\n    agencyId: string;\n    status: 'pending' | 'processing' | 'completed' | 'failed';\n    createdAt: Date;\n    completedAt?: Date;\n}\n\n/**\n * Create an agency recovery transaction\n */\nexport async function createAgencyRecoveryTransaction(params: {\n    invoiceId: string;\n    amount: number;\n    agencyId: string;\n}): Promise<AgencyRecoveryTransaction> {\n    // Placeholder implementation\n    console.log('Creating agency recovery transaction:', params);\n\n    return {\n        id: `txn_${Math.random().toString(36).substring(2, 15)}`,\n        invoiceId: params.invoiceId,\n        amount: params.amount,\n        agencyId: params.agencyId,\n        status: 'pending',\n        createdAt: new Date(),\n    };\n}","/**\n * PREMIUM FEATURE: Agency Hand-off Service\n *\n * Manages escalation of difficult collections to third-party agencies.\n * When internal collection attempts fail, freelancers can escalate to\n * professional collection agencies with established agreements.\n *\n * Flow:\n * 1. Freelancer decides to escalate after X failed attempts\n * 2. System packages all evidence (invoices, communications, proofs)\n * 3. Creates handoff record with agency\n * 4. Agency receives case and begins their process\n * 5. System tracks agency progress and outcomes\n * 6. If recovered, commission is calculated and paid\n *\n * UK Collection Agency Regulations:\n * - Agencies must be licensed by FCA (Financial Conduct Authority)\n * - Must comply with Consumer Credit Act\n * - Must follow FCA debt collection rules\n * - Cannot harass or threaten debtors\n * - Must verify debt before collection\n * - Typical commission: 10-40% depending on age and amount\n * \n * STANDARD AGENCY PROCESS (UK):\n * 1. Initial Demand Letter (14-day notice):\n *    - Formal Letter Before Action sent by agency\n *    - Must comply with FCA CONC 7 (Arrears and Default rules)\n *    - States debt amount, interest accrued, agency commission\n *    - References original creditor and debt transfer date\n *    - Gives debtor 14 days to pay in full or dispute\n *    - Must include debtor rights (payment plans, dispute process)\n * 2. Intensive Collection Period (60-90 days):\n *    - Multi-channel contact: phone (max 3 calls/day), email, SMS, postal\n *    - Office hours only: 8am-9pm Mon-Sat, no Sundays (FCA requirement)\n *    - Payment arrangement negotiations (income/expenditure assessment)\n *    - Settlement offers (often 70-90% to close quickly)\n *    - Debtor vulnerability checks (mental health, financial hardship)\n * 3. Escalation Decision (if unsuccessful after 90 days):\n *    - Recommend County Court claim to original creditor\n *    - Recommend write-off if debtor insolvent/untraceable\n *    - Continue collection if partial payments being made\n * 4. Commission Payment:\n *    - Typically 15-25% of recovered amount (some charge 10-40%)\n *    - Deducted from collected funds (not upfront payment)\n *    - Higher percentage for older/disputed debts\n *    - Some agencies charge upfront admin fee (£50-£150)\n * \n * ADDITIONAL UK AGENCIES (Integration pending):\n * \n * Moorcroft Debt Recovery:\n * - Website: https://www.moorcroft.co.uk\n * - Phone: 0845 300 2000\n * - Email: commercial@moorcroft.co.uk\n * - Specializes: Professional services, trade debt\n * - Minimum: £500 | Commission: 15-20%\n * \n * ARC Europe:\n * - Website: https://www.arceurope.com\n * - Phone: 01932 251 000\n * - Email: info@arceurope.com\n * - Specializes: Multi-sector commercial collections\n * - Minimum: £1,000 | Commission: 20-25%\n * \n * Intrum (large claims specialist):\n * - Website: https://www.intrum.co.uk\n * - Phone: 0203 633 5500\n * - Email: uk@intrum.com\n * - Specializes: Large commercial claims (>£10k)\n * - Minimum: £5,000 | Commission: 15-22% (negotiable)\n * \n * REGULATORY RESOURCES:\n * - FCA CONC Rules: https://www.fca.org.uk/firms/consumer-credit\n * - Credit Services Association: https://www.csa-uk.com\n * - Debt Collection Guidance: See docs/late-payment-legal-resources.md\n */\n\nimport { db, FieldValue, Timestamp } from '@/lib/firebase';\nimport { AgencyHandoff, Invoice, CollectionAttempt } from '@/types/models';\nimport { logError, logInfo } from '@/utils/logger';\nimport { sendNotificationEmail } from '@/lib/sendgrid';\nimport { nanoid } from 'nanoid';\nimport { uploadCommunicationHistory } from '@/lib/firebase-storage';\nimport { createAgencyRecoveryTransaction } from './transactionService';\n\n/**\n * Registered collection agencies\n * In production, maintain database of vetted agencies\n */\nconst REGISTERED_AGENCIES = [\n  {\n    agencyId: 'agency_lowell_uk',\n    agencyName: 'Lowell Financial Ltd',\n    agencyContactEmail: 'handoffs@lowellfinancial.co.uk',\n    agencyContactPhone: '+44 113 281 8820',\n    commissionPercentage: 25, // 25%\n    minimumDebtAmount: 100, // £100 minimum\n    specialties: ['consumer', 'small_business'],\n  },\n  {\n    agencyId: 'agency_cabot_uk',\n    agencyName: 'Cabot Credit Management',\n    agencyContactEmail: 'newcases@cabotcm.co.uk',\n    agencyContactPhone: '+44 113 234 5678',\n    commissionPercentage: 30, // 30%\n    minimumDebtAmount: 250,\n    specialties: ['consumer', 'high_value'],\n  },\n  {\n    agencyId: 'agency_intrum_uk',\n    agencyName: 'Intrum UK',\n    agencyContactEmail: 'uk.handoffs@intrum.com',\n    agencyContactPhone: '+44 161 923 4000',\n    commissionPercentage: 20, // 20% (lower but high volume)\n    minimumDebtAmount: 50,\n    specialties: ['consumer', 'small_business', 'international'],\n  },\n];\n\n/**\n * Check if invoice is eligible for agency escalation\n */\nexport async function checkEscalationEligibility(invoiceId: string): Promise<{\n  eligible: boolean;\n  reason?: string;\n  recommendedAgency?: string;\n}> {\n  try {\n    // 1. Get invoice\n    const invoiceDoc = await db.collection('invoices').doc(invoiceId).get();\n    if (!invoiceDoc.exists) {\n      return { eligible: false, reason: 'Invoice not found' };\n    }\n\n    const invoice = invoiceDoc.data() as Invoice;\n\n    // 2. Check status\n    if (invoice.status === 'paid') {\n      return { eligible: false, reason: 'Invoice already paid' };\n    }\n\n    if (invoice.status === 'in_collections') {\n      // Check if already escalated\n      const existingHandoff = await db\n        .collection('agency_handoffs')\n        .where('invoiceId', '==', invoiceId)\n        .where('handoffStatus', 'in', ['pending', 'in_progress'])\n        .get();\n\n      if (!existingHandoff.empty) {\n        return { eligible: false, reason: 'Already escalated to agency' };\n      }\n    }\n\n    // 3. Check minimum amount\n    if (invoice.amount < 50) {\n      return { eligible: false, reason: 'Amount too low for agency escalation (minimum £50)' };\n    }\n\n    // 4. Check collection attempts\n    const attempts = await db\n      .collection('collection_attempts')\n      .where('invoiceId', '==', invoiceId)\n      .orderBy('createdAt', 'desc')\n      .get();\n\n    if (attempts.size < 3) {\n      return { eligible: false, reason: 'Insufficient collection attempts (minimum 3 required)' };\n    }\n\n    // 5. Check days past due\n    const daysPastDue = Math.floor(\n      (Date.now() - invoice.dueDate.toMillis()) / (1000 * 60 * 60 * 24)\n    );\n\n    if (daysPastDue < 60) {\n      return { eligible: false, reason: 'Not enough time passed (minimum 60 days overdue)' };\n    }\n\n    // 6. Recommend agency based on amount\n    let recommendedAgency = 'agency_intrum_uk'; // Default\n\n    if (invoice.amount >= 250) {\n      recommendedAgency = 'agency_cabot_uk'; // Higher value\n    } else if (invoice.amount >= 100) {\n      recommendedAgency = 'agency_lowell_uk'; // Medium value\n    }\n\n    return {\n      eligible: true,\n      recommendedAgency,\n    };\n\n  } catch (error) {\n    logError('Failed to check escalation eligibility', error);\n    return { eligible: false, reason: 'System error' };\n  }\n}\n\n/**\n * Create agency handoff\n */\nexport async function createAgencyHandoff(params: {\n  invoiceId: string;\n  freelancerId: string;\n  agencyId: string;\n  notes?: string;\n}): Promise<{\n  success: boolean;\n  handoffId?: string;\n  error?: string;\n}> {\n  try {\n    // 1. Validate eligibility\n    const eligibility = await checkEscalationEligibility(params.invoiceId);\n    if (!eligibility.eligible) {\n      return {\n        success: false,\n        error: eligibility.reason || 'Not eligible for escalation',\n      };\n    }\n\n    // 2. Get invoice and collection history\n    const invoiceDoc = await db.collection('invoices').doc(params.invoiceId).get();\n    const invoice = invoiceDoc.data() as Invoice;\n\n    const attemptsSnapshot = await db\n      .collection('collection_attempts')\n      .where('invoiceId', '==', params.invoiceId)\n      .orderBy('createdAt', 'desc')\n      .get();\n\n    const attempts = attemptsSnapshot.docs.map(doc => doc.data() as CollectionAttempt);\n\n    // 3. Get agency details\n    const agency = REGISTERED_AGENCIES.find(a => a.agencyId === params.agencyId);\n    if (!agency) {\n      return { success: false, error: 'Agency not found' };\n    }\n\n    // 4. Check minimum amount\n    if (invoice.amount < agency.minimumDebtAmount) {\n      return {\n        success: false,\n        error: `Amount below agency minimum (£${agency.minimumDebtAmount})`,\n      };\n    }\n\n    // 5. Calculate days past due\n    const daysPastDue = Math.floor(\n      (Date.now() - invoice.dueDate.toMillis()) / (1000 * 60 * 60 * 24)\n    );\n\n    // 6. Build communication history for agency\n    // Map attemptType to simplified communication type\n    const communicationHistory = attempts.map(attempt => {\n      let commType: 'email' | 'sms' | 'call' | 'letter' = 'email';\n\n      if (attempt.attemptType === 'sms_reminder') commType = 'sms';\n      else if (attempt.attemptType === 'physical_letter') commType = 'letter';\n      else if (attempt.attemptType === 'ai_call') commType = 'call';\n      else commType = 'email'; // email_reminder, manual_contact, payment_received default to email\n\n      return {\n        date: attempt.createdAt,\n        type: commType,\n        summary: `${attempt.attemptType}: ${attempt.result}${attempt.resultDetails ? ' - ' + attempt.resultDetails : ''}`,\n      };\n    });\n\n    // 7. Create handoff document\n    const handoffRef = db.collection('agency_handoffs').doc();\n    const handoff: AgencyHandoff = {\n      handoffId: handoffRef.id,\n      invoiceId: params.invoiceId,\n      freelancerId: params.freelancerId,\n      agencyId: params.agencyId,\n      handoffDate: FieldValue.serverTimestamp() as any,\n      handoffStatus: 'pending',\n\n      // Agency info\n      agencyName: agency.agencyName,\n      agencyContactEmail: agency.agencyContactEmail,\n      agencyContactPhone: agency.agencyContactPhone,\n\n      // Invoice details\n      originalAmount: invoice.amount,\n      outstandingAmount: invoice.amount, // Assuming no partial payments yet\n      daysPastDue,\n\n      // Documents & Evidence\n      documents: [], // TODO: Upload invoice PDFs, comms to cloud storage\n      communicationHistory,\n\n      // Financial terms\n      commissionPercentage: agency.commissionPercentage,\n\n      // Notes\n      notes: params.notes,\n\n      // Status updates\n      agencyUpdates: [],\n\n      // Timestamps\n      createdAt: FieldValue.serverTimestamp() as any,\n    };\n\n    await handoffRef.set(handoff);\n\n    // 8. Update invoice status\n    await db.collection('invoices').doc(params.invoiceId).update({\n      status: 'in_collections',\n      updatedAt: FieldValue.serverTimestamp(),\n    });\n\n    // 9. Create collection attempt record\n    const attemptRef = db.collection('collection_attempts').doc();\n    await attemptRef.set({\n      attemptId: attemptRef.id,\n      invoiceId: params.invoiceId,\n      freelancerId: params.freelancerId,\n      attemptType: 'manual_contact',\n      attemptDate: FieldValue.serverTimestamp(),\n      attemptNumber: attempts.length + 1,\n      result: 'pending',\n      resultDetails: `Escalated to ${agency.agencyName}`,\n      escalatedToAgency: true,\n      agencyHandoffId: handoffRef.id,\n      escalationDate: FieldValue.serverTimestamp(),\n      isPremiumFeature: true,\n      createdAt: FieldValue.serverTimestamp(),\n    });\n\n    // AUDIT TASK #4: Send notifications for agency handoff\n    try {\n      // 1. Notify agency via email\n      await sendNotificationEmail({\n        toEmail: agency.agencyContactEmail,\n        subject: `New Collection Case: ${invoice.reference} - £${invoice.amount.toFixed(2)}`,\n        message: `A new collection case has been assigned to ${agency.agencyName}.\n\n**Invoice Details:**\n- Invoice Number: ${invoice.reference}\n- Client: ${invoice.clientName}\n- Amount: £${invoice.amount.toFixed(2)}\n- Days Past Due: ${daysPastDue}\n- Original Invoice Date: ${invoice.invoiceDate.toDate().toLocaleDateString()}\n\n**Case Summary:**\n${communicationHistory.length} collection attempts have been made:\n${communicationHistory.slice(0, 5).map((comm: any) => `- ${comm.type}: ${comm.summary}`).join('\\n')}\n\n**Next Steps:**\n1. Review the case details in your agency portal\n2. Download supporting documents (invoice PDFs, communication history)\n3. Begin collection process per your standard procedures\n\nCommission: ${agency.commissionPercentage}% of recovered amount\n\nCase ID: ${handoffRef.id}`,\n        actionUrl: `${process.env.NEXT_PUBLIC_APP_URL}/agency/cases/${handoffRef.id}`,\n      });\n\n      logInfo('Agency notification email sent', {\n        handoffId: handoffRef.id,\n        agencyEmail: agency.agencyContactEmail,\n      });\n\n    } catch (emailError) {\n      logError('Failed to send agency notification email', emailError);\n      // Continue - don't fail the handoff if email fails\n    }\n\n    try {\n      // 2. Notify freelancer with in-app notification and email\n      const freelancerDoc = await db.collection('users').doc(params.freelancerId).get();\n      const freelancer = freelancerDoc.data();\n\n      if (freelancer) {\n        // Create in-app notification\n        const notification = {\n          notificationId: nanoid(),\n          userId: params.freelancerId,\n          type: 'agency_handoff',\n          title: 'Invoice escalated to collection agency',\n          message: `Invoice ${invoice.reference} (${invoice.clientName}) has been escalated to ${agency.agencyName} for professional collection. You'll be notified of any updates.`,\n          read: false,\n          actionUrl: `${process.env.NEXT_PUBLIC_APP_URL}/dashboard/collections/agency/${handoffRef.id}`,\n          metadata: {\n            handoffId: handoffRef.id,\n            invoiceId: params.invoiceId,\n            agencyName: agency.agencyName,\n          },\n          createdAt: Timestamp.now(),\n        };\n\n        await db.collection('notifications').add(notification);\n\n        // Send email if enabled\n        if (freelancer.notificationPreferences?.emailNotifications && freelancer.email) {\n          await sendNotificationEmail({\n            toEmail: freelancer.email,\n            subject: 'Invoice Escalated to Collection Agency',\n            message: `Your invoice ${invoice.reference} for ${invoice.clientName} (£${invoice.amount.toFixed(2)}) has been escalated to ${agency.agencyName}.\n\n**What happens next:**\n1. ${agency.agencyName} will take over the collection process\n2. You'll receive updates on their progress\n3. If payment is recovered, the commission (${agency.commissionPercentage}%) will be automatically deducted\n\n**You don't need to do anything** - the agency will handle all communication with the client.\n\nWe'll notify you of any developments.`,\n            actionUrl: notification.actionUrl,\n          });\n        }\n\n        logInfo('Freelancer notification sent', {\n          handoffId: handoffRef.id,\n          freelancerId: params.freelancerId,\n        });\n      }\n\n    } catch (notificationError) {\n      logError('Failed to send freelancer notification', notificationError);\n      // Continue - don't fail the handoff if notification fails\n    }\n\n    // AUDIT TASK #5: Upload supporting documents to Firebase Storage\n    try {\n      const uploadedDocuments: string[] = [];\n\n      // 1. Create communication history document as JSON\n      const communicationHistoryJson = {\n        handoffId: handoffRef.id,\n        invoiceId: params.invoiceId,\n        generatedAt: new Date().toISOString(),\n        attempts: communicationHistory,\n        summary: {\n          totalAttempts: communicationHistory.length,\n          attemptTypes: {\n            email: communicationHistory.filter((c: any) => c.type === 'email').length,\n            sms: communicationHistory.filter((c: any) => c.type === 'sms').length,\n            call: communicationHistory.filter((c: any) => c.type === 'call').length,\n            letter: communicationHistory.filter((c: any) => c.type === 'letter').length,\n          },\n          daysPastDue,\n          originalAmount: invoice.amount,\n        },\n      };\n\n      const historyBuffer = Buffer.from(JSON.stringify(communicationHistoryJson, null, 2), 'utf-8');\n\n      const uploadResult = await uploadCommunicationHistory({\n        contentBuffer: historyBuffer,\n        fileName: `communication-history-${Date.now()}.json`,\n        contentType: 'application/json',\n        handoffId: handoffRef.id,\n        freelancerId: params.freelancerId,\n      });\n\n      if (uploadResult.success && uploadResult.storagePath) {\n        uploadedDocuments.push(uploadResult.storagePath);\n\n        // Update handoff with document references\n        await handoffRef.update({\n          documents: uploadedDocuments,\n          documentUrls: uploadedDocuments.map(path => ({\n            storagePath: path,\n            uploadedAt: Timestamp.now(),\n            documentType: 'communication_history',\n          })),\n        });\n\n        logInfo('Communication history uploaded to storage', {\n          handoffId: handoffRef.id,\n          storagePath: uploadResult.storagePath,\n        });\n      }\n\n      // Note: Invoice PDF upload would require the actual PDF file\n      // This can be added when invoice generation is implemented\n      // For now, we store the communication history which is the most critical\n\n    } catch (uploadError) {\n      logError('Failed to upload documents to storage', uploadError);\n      // Continue - document upload failure shouldn't block handoff creation\n      // Documents can be uploaded manually later if needed\n    }\n\n    logInfo('Agency handoff created', {\n      handoffId: handoffRef.id,\n      invoiceId: params.invoiceId,\n      agencyId: params.agencyId,\n    });\n\n    return {\n      success: true,\n      handoffId: handoffRef.id,\n    };\n\n  } catch (error) {\n    logError('Failed to create agency handoff', error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error',\n    };\n  }\n}\n\n/**\n * Update handoff status from agency\n */\nexport async function updateHandoffStatus(\n  handoffId: string,\n  update: {\n    status?: AgencyHandoff['handoffStatus'];\n    notes?: string;\n    actionTaken?: string;\n    recoveryAmount?: number;\n    recoveryOutcome?: AgencyHandoff['recoveryOutcome'];\n  }\n): Promise<{ success: boolean; error?: string }> {\n  try {\n    const handoffRef = db.collection('agency_handoffs').doc(handoffId);\n    const handoffDoc = await handoffRef.get();\n\n    if (!handoffDoc.exists) {\n      return { success: false, error: 'Handoff not found' };\n    }\n\n    const updateData: any = {\n      lastUpdate: FieldValue.serverTimestamp(),\n      updatedAt: FieldValue.serverTimestamp(),\n    };\n\n    // Update status if provided\n    if (update.status) {\n      updateData.handoffStatus = update.status;\n\n      if (update.status === 'closed') {\n        updateData.closedAt = FieldValue.serverTimestamp();\n      }\n    }\n\n    // Add recovery details if provided\n    if (update.recoveryAmount !== undefined) {\n      updateData.recoveryAmount = update.recoveryAmount;\n      updateData.recoveryDate = FieldValue.serverTimestamp();\n\n      // Calculate commission\n      const handoff = handoffDoc.data() as AgencyHandoff;\n      updateData.commissionAmount = (update.recoveryAmount * handoff.commissionPercentage) / 100;\n    }\n\n    if (update.recoveryOutcome) {\n      updateData.recoveryOutcome = update.recoveryOutcome;\n    }\n\n    // Add to agency updates log\n    if (update.notes || update.actionTaken) {\n      updateData.agencyUpdates = FieldValue.arrayUnion({\n        date: FieldValue.serverTimestamp(),\n        status: update.status || 'in_progress',\n        notes: update.notes || '',\n        actionTaken: update.actionTaken,\n      });\n    }\n\n    await handoffRef.update(updateData);\n\n    // If paid, update invoice\n    if (update.status === 'collected' && update.recoveryAmount) {\n      const handoff = handoffDoc.data() as AgencyHandoff;\n      await db.collection('invoices').doc(handoff.invoiceId).update({\n        status: 'paid',\n        paidAt: FieldValue.serverTimestamp(),\n        updatedAt: FieldValue.serverTimestamp(),\n      });\n\n      // AUDIT TASK #4 & #6: Notify freelancer of successful recovery\n      try {\n        const freelancerDoc = await db.collection('users').doc(handoff.freelancerId).get();\n        const freelancer = freelancerDoc.data();\n\n        if (freelancer) {\n          // Calculate net amount after commission\n          const commissionAmount = update.recoveryAmount * (handoff.commissionPercentage / 100);\n          const netAmount = update.recoveryAmount - commissionAmount;\n\n          // Create in-app notification\n          const notification = {\n            notificationId: nanoid(),\n            userId: handoff.freelancerId,\n            type: 'payment_recovered',\n            title: `Payment recovered by ${handoff.agencyName}!`,\n            message: `Great news! ${handoff.agencyName} has successfully collected £${update.recoveryAmount.toFixed(2)} for invoice ${handoff.invoiceId}. After ${handoff.commissionPercentage}% commission, you'll receive £${netAmount.toFixed(2)}.`,\n            read: false,\n            actionUrl: `${process.env.NEXT_PUBLIC_APP_URL}/dashboard/collections/agency/${handoffId}`,\n            metadata: {\n              handoffId,\n              invoiceId: handoff.invoiceId,\n              recoveryAmount: update.recoveryAmount,\n              commissionAmount,\n              netAmount,\n            },\n            createdAt: Timestamp.now(),\n          };\n\n          await db.collection('notifications').add(notification);\n\n          // Send email if enabled\n          if (freelancer.notificationPreferences?.emailNotifications && freelancer.email) {\n            await sendNotificationEmail({\n              toEmail: freelancer.email,\n              subject: 'Payment Successfully Recovered!',\n              message: `Excellent news! ${handoff.agencyName} has successfully recovered payment for your invoice.\n\n**Recovery Details:**\n- Invoice: ${handoff.invoiceId}\n- Amount Recovered: £${update.recoveryAmount.toFixed(2)}\n- Agency Commission (${handoff.commissionPercentage}%): £${commissionAmount.toFixed(2)}\n- Net Amount to You: £${netAmount.toFixed(2)}\n\nThe net amount will be transferred to your account within 5-7 business days.\n\nThank you for using Recoup's collection services!`,\n              actionUrl: notification.actionUrl,\n            });\n          }\n\n          logInfo('Recovery notification sent to freelancer', {\n            handoffId,\n            freelancerId: handoff.freelancerId,\n            recoveryAmount: update.recoveryAmount,\n          });\n        }\n\n      } catch (notificationError) {\n        logError('Failed to send recovery notification', notificationError);\n        // Continue - notification failure shouldn't block the update\n      }\n\n      // AUDIT TASK #6: Create transaction record for payment tracking\n      try {\n        const transactionResult = await createAgencyRecoveryTransaction({\n          invoiceId: handoff.invoiceId,\n          freelancerId: handoff.freelancerId,\n          agencyHandoffId: handoffId,\n          agencyId: handoff.agencyId,\n          grossAmount: update.recoveryAmount,\n          agencyCommissionRate: handoff.commissionPercentage / 100,\n          notes: `Recovery by ${handoff.agencyName}. ${update.recoveryOutcome || 'full_recovery'}`,\n        });\n\n        if (transactionResult.success) {\n          // Link transaction to handoff\n          await handoffRef.update({\n            transactionId: transactionResult.transactionId,\n            transactionCreatedAt: Timestamp.now(),\n          });\n\n          logInfo('Agency recovery transaction created', {\n            handoffId,\n            transactionId: transactionResult.transactionId,\n            grossAmount: update.recoveryAmount,\n          });\n        } else {\n          logError('Failed to create recovery transaction', new Error(transactionResult.error));\n        }\n\n      } catch (transactionError) {\n        logError('Failed to create recovery transaction', transactionError);\n        // Continue - transaction creation failure shouldn't block the update\n        // Transactions can be created manually later if needed\n      }\n    }\n\n    return { success: true };\n\n  } catch (error) {\n    logError('Failed to update handoff status', error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error',\n    };\n  }\n}\n\n/**\n * Get handoff details\n */\nexport async function getHandoffDetails(handoffId: string): Promise<AgencyHandoff | null> {\n  try {\n    const doc = await db.collection('agency_handoffs').doc(handoffId).get();\n\n    if (!doc.exists) {\n      return null;\n    }\n\n    return doc.data() as AgencyHandoff;\n\n  } catch (error) {\n    logError('Failed to get handoff details', error);\n    return null;\n  }\n}\n\n/**\n * List handoffs for freelancer\n */\nexport async function listFreelancerHandoffs(\n  freelancerId: string,\n  options?: {\n    status?: AgencyHandoff['handoffStatus'];\n    limit?: number;\n  }\n): Promise<AgencyHandoff[]> {\n  try {\n    let query = db\n      .collection('agency_handoffs')\n      .where('freelancerId', '==', freelancerId)\n      .orderBy('createdAt', 'desc');\n\n    if (options?.status) {\n      query = query.where('handoffStatus', '==', options.status) as any;\n    }\n\n    if (options?.limit) {\n      query = query.limit(options.limit) as any;\n    }\n\n    const snapshot = await query.get();\n    return snapshot.docs.map(doc => doc.data() as AgencyHandoff);\n\n  } catch (error) {\n    logError('Failed to list handoffs', error);\n    return [];\n  }\n}\n\n/**\n * Calculate potential commission for agency escalation\n */\nexport function calculateAgencyCommission(params: {\n  amount: number;\n  agencyId: string;\n}): {\n  commissionPercentage: number;\n  commissionAmount: number;\n  freelancerReceives: number;\n  agencyReceives: number;\n} | null {\n  const agency = REGISTERED_AGENCIES.find(a => a.agencyId === params.agencyId);\n\n  if (!agency) {\n    return null;\n  }\n\n  const commissionAmount = (params.amount * agency.commissionPercentage) / 100;\n  const freelancerReceives = params.amount - commissionAmount;\n\n  return {\n    commissionPercentage: agency.commissionPercentage,\n    commissionAmount,\n    freelancerReceives,\n    agencyReceives: commissionAmount,\n  };\n}\n\n/**\n * Get list of available agencies for freelancer\n */\nexport function getAvailableAgencies(params: {\n  amount: number;\n}): Array<{\n  agencyId: string;\n  agencyName: string;\n  commissionPercentage: number;\n  commissionAmount: number;\n  freelancerReceives: number;\n  minimumDebtAmount: number;\n  eligible: boolean;\n}> {\n  return REGISTERED_AGENCIES.map(agency => {\n    const eligible = params.amount >= agency.minimumDebtAmount;\n    const commissionAmount = (params.amount * agency.commissionPercentage) / 100;\n    const freelancerReceives = params.amount - commissionAmount;\n\n    return {\n      agencyId: agency.agencyId,\n      agencyName: agency.agencyName,\n      commissionPercentage: agency.commissionPercentage,\n      commissionAmount,\n      freelancerReceives,\n      minimumDebtAmount: agency.minimumDebtAmount,\n      eligible,\n    };\n  }).sort((a, b) => a.commissionPercentage - b.commissionPercentage); // Lowest commission first\n}\n","/**\n * PREMIUM API: Agency Hand-off\n * POST /api/collections/agency-handoff\n *\n * Escalates a difficult invoice to a professional collection agency.\n * Requires minimum threshold of collection attempts and days overdue.\n */\n\nimport { NextRequest, NextResponse } from 'next/server';\nimport { auth } from '@clerk/nextjs/server';\nimport {\n  createAgencyHandoff,\n  checkEscalationEligibility,\n  getAvailableAgencies,\n  listFreelancerHandoffs,\n  getHandoffDetails,\n} from '@/services/agencyHandoffService';\nimport { requirePremiumAccess, logPremiumFeatureUsage } from '@/middleware/premiumGating';\nimport { requireClerkFeature } from '@/middleware/clerkPremiumGating';\nimport { errors, handleApiError, UnauthorizedError, NotFoundError, ForbiddenError, ValidationError } from '@/utils/error';\nimport { logApiRequest, logApiResponse } from '@/utils/logger';\n\nexport const dynamic = 'force-dynamic';\n\n/**\n * Create agency handoff\n * POST /api/collections/agency-handoff\n */\nexport async function POST(req: NextRequest): Promise<NextResponse> {\n  const startTime = Date.now();\n\n  try {\n    // 1. Authenticate\n    const { userId } = await auth();\n    if (!userId) {\n      throw new UnauthorizedError();\n    }\n\n    logApiRequest('POST', '/api/collections/agency-handoff', userId);\n\n    // 2. Check premium access (NEW: Clerk Billing feature check)\n    await requireClerkFeature(userId, 'dedicated_account_manager');\n\n    // 3. Parse request body\n    const body = await req.json();\n    const {\n      invoiceId,\n      agencyId,\n      notes,\n    }: {\n      invoiceId: string;\n      agencyId: string;\n      notes?: string;\n    } = body;\n\n    if (!invoiceId || !agencyId) {\n      throw new ValidationError('Missing required fields: invoiceId, agencyId');\n    }\n\n    // 4. Check eligibility\n    const eligibility = await checkEscalationEligibility(invoiceId);\n\n    if (!eligibility.eligible) {\n      return NextResponse.json(\n        {\n          success: false,\n          error: eligibility.reason,\n          eligible: false,\n        },\n        { status: 400 }\n      );\n    }\n\n    // 5. Create handoff\n    const result = await createAgencyHandoff({\n      invoiceId,\n      freelancerId: userId,\n      agencyId,\n      notes,\n    });\n\n    if (!result.success) {\n      throw new Error(result.error || 'Failed to create handoff');\n    }\n\n    // 6. Log premium feature usage\n    await logPremiumFeatureUsage({\n      userId,\n      feature: 'agency_handoff',\n      invoiceId,\n      cost: 0, // Commission-based, not upfront cost\n    });\n\n    const duration = Date.now() - startTime;\n    logApiResponse('POST', '/api/collections/agency-handoff', 200, { duration, userId });\n\n    return NextResponse.json({\n      success: true,\n      message: 'Invoice escalated to agency successfully',\n      handoffId: result.handoffId,\n      note: 'Agency will begin collection efforts within 2-3 business days',\n    });\n\n  } catch (error: any) {\n    const errorResponse = await handleApiError(error);\n    return NextResponse.json(errorResponse.body, { status: errorResponse.status });\n  }\n}\n\n/**\n * Get handoff details or list handoffs\n * GET /api/collections/agency-handoff?handoffId=xxx\n * GET /api/collections/agency-handoff (list all)\n */\nexport async function GET(req: NextRequest): Promise<NextResponse> {\n  try {\n    const { userId } = await auth();\n    if (!userId) {\n      throw new UnauthorizedError();\n    }\n\n    const { searchParams } = new URL(req.url);\n    const handoffId = searchParams.get('handoffId');\n    const status = searchParams.get('status') as any;\n\n    // Get specific handoff\n    if (handoffId) {\n      const handoff = await getHandoffDetails(handoffId);\n\n      if (!handoff) {\n        throw new NotFoundError('Handoff not found');\n      }\n\n      // Verify ownership\n      if (handoff.freelancerId !== userId) {\n        throw new ForbiddenError('You do not have access to this handoff');\n      }\n\n      return NextResponse.json({\n        success: true,\n        handoff,\n      });\n    }\n\n    // List all handoffs for user\n    const handoffs = await listFreelancerHandoffs(userId, {\n      status,\n      limit: 50,\n    });\n\n    return NextResponse.json({\n      success: true,\n      handoffs,\n      count: handoffs.length,\n    });\n\n  } catch (error) {\n    const errorResponse = await handleApiError(error);\n    return NextResponse.json(errorResponse.body, { status: errorResponse.status });\n  }\n}\n","import {\n  AppRouteRouteModule,\n  type AppRouteRouteHandlerContext,\n  type AppRouteRouteModuleOptions,\n} from '../../server/route-modules/app-route/module.compiled'\nimport { RouteKind } from '../../server/route-kind'\nimport { patchFetch as _patchFetch } from '../../server/lib/patch-fetch'\nimport type { IncomingMessage, ServerResponse } from 'node:http'\nimport { addRequestMeta, getRequestMeta } from '../../server/request-meta'\nimport { getTracer, type Span, SpanKind } from '../../server/lib/trace/tracer'\nimport { setReferenceManifestsSingleton } from '../../server/app-render/encryption-utils'\nimport { createServerModuleMap } from '../../server/app-render/action-utils'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { NodeNextRequest, NodeNextResponse } from '../../server/base-http/node'\nimport {\n  NextRequestAdapter,\n  signalFromNodeResponse,\n} from '../../server/web/spec-extension/adapters/next-request'\nimport { BaseServerSpan } from '../../server/lib/trace/constants'\nimport { getRevalidateReason } from '../../server/instrumentation/utils'\nimport { sendResponse } from '../../server/send-response'\nimport {\n  fromNodeOutgoingHttpHeaders,\n  toNodeOutgoingHttpHeaders,\n} from '../../server/web/utils'\nimport { getCacheControlHeader } from '../../server/lib/cache-control'\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from '../../lib/constants'\nimport { NoFallbackError } from '../../shared/lib/no-fallback-error.external'\nimport {\n  CachedRouteKind,\n  type ResponseCacheEntry,\n  type ResponseGenerator,\n} from '../../server/response-cache'\n\nimport * as userland from 'VAR_USERLAND'\n\n// These are injected by the loader afterwards. This is injected as a variable\n// instead of a replacement because this could also be `undefined` instead of\n// an empty string.\ndeclare const nextConfigOutput: AppRouteRouteModuleOptions['nextConfigOutput']\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\n// INJECT:nextConfigOutput\n\nconst routeModule = new AppRouteRouteModule({\n  definition: {\n    kind: RouteKind.APP_ROUTE,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    filename: 'VAR_DEFINITION_FILENAME',\n    bundlePath: 'VAR_DEFINITION_BUNDLE_PATH',\n  },\n  distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n  relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n  resolvedPagePath: 'VAR_RESOLVED_PAGE_PATH',\n  nextConfigOutput,\n  userland,\n})\n\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule\n\nfunction patchFetch() {\n  return _patchFetch({\n    workAsyncStorage,\n    workUnitAsyncStorage,\n  })\n}\n\nexport {\n  routeModule,\n  workAsyncStorage,\n  workUnitAsyncStorage,\n  serverHooks,\n  patchFetch,\n}\n\nexport async function handler(\n  req: IncomingMessage,\n  res: ServerResponse,\n  ctx: {\n    waitUntil: (prom: Promise<void>) => void\n  }\n) {\n  if (routeModule.isDev) {\n    addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint())\n  }\n  let srcPage = 'VAR_DEFINITION_PAGE'\n\n  // turbopack doesn't normalize `/index` in the page name\n  // so we need to to process dynamic routes properly\n  // TODO: fix turbopack providing differing value from webpack\n  if (process.env.TURBOPACK) {\n    srcPage = srcPage.replace(/\\/index$/, '') || '/'\n  } else if (srcPage === '/index') {\n    // we always normalize /index specifically\n    srcPage = '/'\n  }\n  const multiZoneDraftMode = process.env\n    .__NEXT_MULTI_ZONE_DRAFT_MODE as any as boolean\n\n  const prepareResult = await routeModule.prepare(req, res, {\n    srcPage,\n    multiZoneDraftMode,\n  })\n\n  if (!prepareResult) {\n    res.statusCode = 400\n    res.end('Bad Request')\n    ctx.waitUntil?.(Promise.resolve())\n    return null\n  }\n\n  const {\n    buildId,\n    params,\n    nextConfig,\n    parsedUrl,\n    isDraftMode,\n    prerenderManifest,\n    routerServerContext,\n    isOnDemandRevalidate,\n    revalidateOnlyGenerated,\n    resolvedPathname,\n    clientReferenceManifest,\n    serverActionsManifest,\n  } = prepareResult\n\n  const normalizedSrcPage = normalizeAppPath(srcPage)\n\n  let isIsr = Boolean(\n    prerenderManifest.dynamicRoutes[normalizedSrcPage] ||\n      prerenderManifest.routes[resolvedPathname]\n  )\n\n  const render404 = async () => {\n    // TODO: should route-module itself handle rendering the 404\n    if (routerServerContext?.render404) {\n      await routerServerContext.render404(req, res, parsedUrl, false)\n    } else {\n      res.end('This page could not be found')\n    }\n    return null\n  }\n\n  if (isIsr && !isDraftMode) {\n    const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname])\n    const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage]\n\n    if (prerenderInfo) {\n      if (prerenderInfo.fallback === false && !isPrerendered) {\n        if (nextConfig.experimental.adapterPath) {\n          return await render404()\n        }\n        throw new NoFallbackError()\n      }\n    }\n  }\n\n  let cacheKey: string | null = null\n\n  if (isIsr && !routeModule.isDev && !isDraftMode) {\n    cacheKey = resolvedPathname\n    // ensure /index and / is normalized to one key\n    cacheKey = cacheKey === '/index' ? '/' : cacheKey\n  }\n\n  const supportsDynamicResponse: boolean =\n    // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true ||\n    // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr\n\n  // This is a revalidation request if the request is for a static\n  // page and it is not being resumed from a postponed render and\n  // it is not a dynamic RSC request then it is a revalidation\n  // request.\n  const isStaticGeneration = isIsr && !supportsDynamicResponse\n\n  // Before rendering (which initializes component tree modules), we have to\n  // set the reference manifests to our global store so Server Action's\n  // encryption util can access to them at the top level of the page module.\n  if (serverActionsManifest && clientReferenceManifest) {\n    setReferenceManifestsSingleton({\n      page: srcPage,\n      clientReferenceManifest,\n      serverActionsManifest,\n      serverModuleMap: createServerModuleMap({\n        serverActionsManifest,\n      }),\n    })\n  }\n\n  const method = req.method || 'GET'\n  const tracer = getTracer()\n  const activeSpan = tracer.getActiveScopeSpan()\n\n  const context: AppRouteRouteHandlerContext = {\n    params,\n    prerenderManifest,\n    renderOpts: {\n      experimental: {\n        authInterrupts: Boolean(nextConfig.experimental.authInterrupts),\n      },\n      cacheComponents: Boolean(nextConfig.cacheComponents),\n      supportsDynamicResponse,\n      incrementalCache: getRequestMeta(req, 'incrementalCache'),\n      cacheLifeProfiles: nextConfig.cacheLife,\n      waitUntil: ctx.waitUntil,\n      onClose: (cb) => {\n        res.on('close', cb)\n      },\n      onAfterTaskError: undefined,\n      onInstrumentationRequestError: (error, _request, errorContext) =>\n        routeModule.onRequestError(\n          req,\n          error,\n          errorContext,\n          routerServerContext\n        ),\n    },\n    sharedContext: {\n      buildId,\n    },\n  }\n  const nodeNextReq = new NodeNextRequest(req)\n  const nodeNextRes = new NodeNextResponse(res)\n\n  const nextReq = NextRequestAdapter.fromNodeNextRequest(\n    nodeNextReq,\n    signalFromNodeResponse(res)\n  )\n\n  try {\n    const invokeRouteModule = async (span?: Span) => {\n      return routeModule.handle(nextReq, context).finally(() => {\n        if (!span) return\n\n        span.setAttributes({\n          'http.status_code': res.statusCode,\n          'next.rsc': false,\n        })\n\n        const rootSpanAttributes = tracer.getRootSpanAttributes()\n        // We were unable to get attributes, probably OTEL is not enabled\n        if (!rootSpanAttributes) {\n          return\n        }\n\n        if (\n          rootSpanAttributes.get('next.span_type') !==\n          BaseServerSpan.handleRequest\n        ) {\n          console.warn(\n            `Unexpected root span type '${rootSpanAttributes.get(\n              'next.span_type'\n            )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n          )\n          return\n        }\n\n        const route = rootSpanAttributes.get('next.route')\n        if (route) {\n          const name = `${method} ${route}`\n\n          span.setAttributes({\n            'next.route': route,\n            'http.route': route,\n            'next.span_name': name,\n          })\n          span.updateName(name)\n        } else {\n          span.updateName(`${method} ${srcPage}`)\n        }\n      })\n    }\n    const isMinimalMode = Boolean(\n      process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode')\n    )\n\n    const handleResponse = async (currentSpan?: Span) => {\n      const responseGenerator: ResponseGenerator = async ({\n        previousCacheEntry,\n      }) => {\n        try {\n          if (\n            !isMinimalMode &&\n            isOnDemandRevalidate &&\n            revalidateOnlyGenerated &&\n            !previousCacheEntry\n          ) {\n            res.statusCode = 404\n            // on-demand revalidate always sets this header\n            res.setHeader('x-nextjs-cache', 'REVALIDATED')\n            res.end('This page could not be found')\n            return null\n          }\n\n          const response = await invokeRouteModule(currentSpan)\n\n          ;(req as any).fetchMetrics = (context.renderOpts as any).fetchMetrics\n          let pendingWaitUntil = context.renderOpts.pendingWaitUntil\n\n          // Attempt using provided waitUntil if available\n          // if it's not we fallback to sendResponse's handling\n          if (pendingWaitUntil) {\n            if (ctx.waitUntil) {\n              ctx.waitUntil(pendingWaitUntil)\n              pendingWaitUntil = undefined\n            }\n          }\n          const cacheTags = context.renderOpts.collectedTags\n\n          // If the request is for a static response, we can cache it so long\n          // as it's not edge.\n          if (isIsr) {\n            const blob = await response.blob()\n\n            // Copy the headers from the response.\n            const headers = toNodeOutgoingHttpHeaders(response.headers)\n\n            if (cacheTags) {\n              headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n            }\n\n            if (!headers['content-type'] && blob.type) {\n              headers['content-type'] = blob.type\n            }\n\n            const revalidate =\n              typeof context.renderOpts.collectedRevalidate === 'undefined' ||\n              context.renderOpts.collectedRevalidate >= INFINITE_CACHE\n                ? false\n                : context.renderOpts.collectedRevalidate\n\n            const expire =\n              typeof context.renderOpts.collectedExpire === 'undefined' ||\n              context.renderOpts.collectedExpire >= INFINITE_CACHE\n                ? undefined\n                : context.renderOpts.collectedExpire\n\n            // Create the cache entry for the response.\n            const cacheEntry: ResponseCacheEntry = {\n              value: {\n                kind: CachedRouteKind.APP_ROUTE,\n                status: response.status,\n                body: Buffer.from(await blob.arrayBuffer()),\n                headers,\n              },\n              cacheControl: { revalidate, expire },\n            }\n\n            return cacheEntry\n          } else {\n            // send response without caching if not ISR\n            await sendResponse(\n              nodeNextReq,\n              nodeNextRes,\n              response,\n              context.renderOpts.pendingWaitUntil\n            )\n            return null\n          }\n        } catch (err) {\n          // if this is a background revalidate we need to report\n          // the request error here as it won't be bubbled\n          if (previousCacheEntry?.isStale) {\n            await routeModule.onRequestError(\n              req,\n              err,\n              {\n                routerKind: 'App Router',\n                routePath: srcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                  isStaticGeneration,\n                  isOnDemandRevalidate,\n                }),\n              },\n              routerServerContext\n            )\n          }\n          throw err\n        }\n      }\n\n      const cacheEntry = await routeModule.handleResponse({\n        req,\n        nextConfig,\n        cacheKey,\n        routeKind: RouteKind.APP_ROUTE,\n        isFallback: false,\n        prerenderManifest,\n        isRoutePPREnabled: false,\n        isOnDemandRevalidate,\n        revalidateOnlyGenerated,\n        responseGenerator,\n        waitUntil: ctx.waitUntil,\n        isMinimalMode,\n      })\n\n      // we don't create a cacheEntry for ISR\n      if (!isIsr) {\n        return null\n      }\n\n      if (cacheEntry?.value?.kind !== CachedRouteKind.APP_ROUTE) {\n        throw new Error(\n          `Invariant: app-route received invalid cache entry ${cacheEntry?.value?.kind}`\n        )\n      }\n\n      if (!isMinimalMode) {\n        res.setHeader(\n          'x-nextjs-cache',\n          isOnDemandRevalidate\n            ? 'REVALIDATED'\n            : cacheEntry.isMiss\n              ? 'MISS'\n              : cacheEntry.isStale\n                ? 'STALE'\n                : 'HIT'\n        )\n      }\n\n      // Draft mode should never be cached\n      if (isDraftMode) {\n        res.setHeader(\n          'Cache-Control',\n          'private, no-cache, no-store, max-age=0, must-revalidate'\n        )\n      }\n\n      const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers)\n\n      if (!(isMinimalMode && isIsr)) {\n        headers.delete(NEXT_CACHE_TAGS_HEADER)\n      }\n\n      // If cache control is already set on the response we don't\n      // override it to allow users to customize it via next.config\n      if (\n        cacheEntry.cacheControl &&\n        !res.getHeader('Cache-Control') &&\n        !headers.get('Cache-Control')\n      ) {\n        headers.set(\n          'Cache-Control',\n          getCacheControlHeader(cacheEntry.cacheControl)\n        )\n      }\n\n      await sendResponse(\n        nodeNextReq,\n        nodeNextRes,\n        // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n        new Response(cacheEntry.value.body, {\n          headers,\n          status: cacheEntry.value.status || 200,\n        })\n      )\n      return null\n    }\n\n    // TODO: activeSpan code path is for when wrapped by\n    // next-server can be removed when this is no longer used\n    if (activeSpan) {\n      await handleResponse(activeSpan)\n    } else {\n      await tracer.withPropagatedContext(req.headers, () =>\n        tracer.trace(\n          BaseServerSpan.handleRequest,\n          {\n            spanName: `${method} ${srcPage}`,\n            kind: SpanKind.SERVER,\n            attributes: {\n              'http.method': method,\n              'http.target': req.url,\n            },\n          },\n          handleResponse\n        )\n      )\n    }\n  } catch (err) {\n    if (!(err instanceof NoFallbackError)) {\n      await routeModule.onRequestError(req, err, {\n        routerKind: 'App Router',\n        routePath: normalizedSrcPage,\n        routeType: 'route',\n        revalidateReason: getRevalidateReason({\n          isStaticGeneration,\n          isOnDemandRevalidate,\n        }),\n      })\n    }\n\n    // rethrow so that we can handle serving error page\n\n    // If this is during static generation, throw the error again.\n    if (isIsr) throw err\n\n    // Otherwise, send a 500 response.\n    await sendResponse(\n      nodeNextReq,\n      nodeNextRes,\n      new Response(null, { status: 500 })\n    )\n    return null\n  }\n}\n"],"names":["AppRouteRouteModule","RouteKind","patchFetch","_patchFetch","addRequestMeta","getRequestMeta","getTracer","SpanKind","setReferenceManifestsSingleton","createServerModuleMap","normalizeAppPath","NodeNextRequest","NodeNextResponse","NextRequestAdapter","signalFromNodeResponse","BaseServerSpan","getRevalidateReason","sendResponse","fromNodeOutgoingHttpHeaders","toNodeOutgoingHttpHeaders","getCacheControlHeader","INFINITE_CACHE","NEXT_CACHE_TAGS_HEADER","NoFallbackError","CachedRouteKind","userland","routeModule","definition","kind","APP_ROUTE","page","pathname","filename","bundlePath","distDir","process","env","__NEXT_RELATIVE_DIST_DIR","relativeProjectDir","__NEXT_RELATIVE_PROJECT_DIR","resolvedPagePath","nextConfigOutput","workAsyncStorage","workUnitAsyncStorage","serverHooks","handler","req","res","ctx","isDev","hrtime","bigint","srcPage","TURBOPACK","replace","multiZoneDraftMode","__NEXT_MULTI_ZONE_DRAFT_MODE","prepareResult","prepare","statusCode","end","waitUntil","Promise","resolve","buildId","params","nextConfig","parsedUrl","isDraftMode","prerenderManifest","routerServerContext","isOnDemandRevalidate","revalidateOnlyGenerated","resolvedPathname","clientReferenceManifest","serverActionsManifest","normalizedSrcPage","isIsr","Boolean","dynamicRoutes","routes","render404","isPrerendered","prerenderInfo","fallback","experimental","adapterPath","cacheKey","supportsDynamicResponse","isStaticGeneration","serverModuleMap","method","tracer","activeSpan","getActiveScopeSpan","context","renderOpts","authInterrupts","cacheComponents","incrementalCache","cacheLifeProfiles","cacheLife","onClose","cb","on","onAfterTaskError","undefined","onInstrumentationRequestError","error","_request","errorContext","onRequestError","sharedContext","nodeNextReq","nodeNextRes","nextReq","fromNodeNextRequest","invokeRouteModule","span","handle","finally","setAttributes","rootSpanAttributes","getRootSpanAttributes","get","handleRequest","console","warn","route","name","updateName","isMinimalMode","MINIMAL_MODE","handleResponse","currentSpan","cacheEntry","responseGenerator","previousCacheEntry","setHeader","response","fetchMetrics","pendingWaitUntil","cacheTags","collectedTags","blob","headers","type","revalidate","collectedRevalidate","expire","collectedExpire","value","status","body","Buffer","from","arrayBuffer","cacheControl","err","isStale","routerKind","routePath","routeType","revalidateReason","routeKind","isFallback","isRoutePPREnabled","Error","isMiss","delete","getHeader","set","Response","withPropagatedContext","trace","spanName","SERVER","attributes","url"],"mappings":"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","ignoreList":[3]}