module.exports=[918622,(e,t,r)=>{t.exports=e.x("next/dist/compiled/next-server/app-page-turbo.runtime.prod.js",()=>require("next/dist/compiled/next-server/app-page-turbo.runtime.prod.js"))},556704,(e,t,r)=>{t.exports=e.x("next/dist/server/app-render/work-async-storage.external.js",()=>require("next/dist/server/app-render/work-async-storage.external.js"))},832319,(e,t,r)=>{t.exports=e.x("next/dist/server/app-render/work-unit-async-storage.external.js",()=>require("next/dist/server/app-render/work-unit-async-storage.external.js"))},324725,(e,t,r)=>{t.exports=e.x("next/dist/server/app-render/after-task-async-storage.external.js",()=>require("next/dist/server/app-render/after-task-async-storage.external.js"))},193695,(e,t,r)=>{t.exports=e.x("next/dist/shared/lib/no-fallback-error.external.js",()=>require("next/dist/shared/lib/no-fallback-error.external.js"))},155742,e=>e.a(async(t,r)=>{try{let t=await e.y("firebase-admin/firestore");e.n(t),r()}catch(e){r(e)}},!0),391889,e=>e.a(async(t,r)=>{try{var n,a=e.i(155742),i=t([a]);[a]=i.then?(await i)():i;var s=((n={}).ACTIVE="active",n.PAUSED="paused",n.COMPLETED="completed",n.CANCELLED="cancelled",n);async function o(e){let t=(0,a.getFirestore)(),r={...e,generatedInvoiceIds:[],totalInvoicesGenerated:0,createdAt:new Date().toISOString(),updatedAt:new Date().toISOString()};return(await t.collection("recurring_invoices").add(r)).id}async function c(e){let t=(0,a.getFirestore)(),r=await t.collection("recurring_invoices").doc(e).get();return r.exists?{id:r.id,...r.data()}:null}async function u(e,t){let r=(0,a.getFirestore)().collection("recurring_invoices").where("userId","==",e);return t&&(r=r.where("status","==",t)),(await r.get()).docs.map(e=>({id:e.id,...e.data()}))}async function l(){let e=(0,a.getFirestore)(),t=new Date().toISOString().split("T")[0];return(await e.collection("recurring_invoices").where("status","==","active").where("nextInvoiceDate","<=",t).get()).docs.map(e=>({id:e.id,...e.data()}))}async function d(e,t){let r=(0,a.getFirestore)();await r.collection("recurring_invoices").doc(e).update({...t,updatedAt:new Date().toISOString()})}async function p(e,t){await d(e,{status:"paused",pausedAt:new Date().toISOString(),pausedReason:t})}async function g(e){let t=await c(e);if(!t)throw Error("Recurring invoice not found");let r=w(new Date().toISOString().split("T")[0],t.frequency);await d(e,{status:"active",nextInvoiceDate:r,pausedAt:void 0,pausedReason:void 0})}async function v(e){await d(e,{status:"cancelled"})}async function h(e){await d(e,{status:"completed"})}function w(e,t){let r=new Date(e);switch(t){case"weekly":r.setDate(r.getDate()+7);break;case"biweekly":r.setDate(r.getDate()+14);break;case"monthly":r.setMonth(r.getMonth()+1);break;case"quarterly":r.setMonth(r.getMonth()+3);break;case"annually":r.setFullYear(r.getFullYear()+1);break;default:throw Error(`Unknown frequency: ${t}`)}return r.toISOString().split("T")[0]}async function m(e){let t=(0,a.getFirestore)(),r=await c(e);if(!r)throw Error("Recurring invoice not found");if("active"!==r.status)throw Error(`Cannot generate invoice from ${r.status} recurring invoice`);let n=r.nextInvoiceDate,i=w(n,r.frequency),s=w(r.nextInvoiceDate,r.frequency),o=new Date(r.nextInvoiceDate);o.setDate(o.getDate()+r.paymentTermsDays);let u=await R(r.userId),l=`INV-${String(u+1).padStart(6,"0")}`,d={userId:r.userId,invoiceNumber:l,clientId:r.clientId,clientName:r.clientName,clientEmail:r.clientEmail,description:r.description,lineItems:r.lineItems,subtotal:r.subtotal,vatRate:r.vatRate,vatAmount:r.vatAmount,total:r.total,invoiceDate:r.nextInvoiceDate,dueDate:o.toISOString().split("T")[0],status:"draft",paymentStatus:"unpaid",recurringInvoiceId:e,isRecurring:!0,recurringPeriodStart:n,recurringPeriodEnd:i,createdAt:new Date().toISOString(),updatedAt:new Date().toISOString()},p=await t.collection("invoices").add(d);return await t.collection("recurring_invoices").doc(e).update({generatedInvoiceIds:a.FieldValue.arrayUnion(p.id),lastGeneratedDate:r.nextInvoiceDate,totalInvoicesGenerated:a.FieldValue.increment(1),nextInvoiceDate:s,updatedAt:new Date().toISOString()}),r.endDate&&s>r.endDate&&await h(e),await t.collection("recurring_invoice_history").add({recurringInvoiceId:e,invoiceId:p.id,generatedAt:new Date().toISOString(),periodStart:n,periodEnd:i}),p.id}async function R(e){let t=(0,a.getFirestore)();return(await t.collection("invoices").where("userId","==",e).get()).size}async function f(){let e=await l(),t={processed:e.length,succeeded:0,failed:0,errors:[]};for(let r of e)try{await m(r.id),t.succeeded++}catch(e){t.failed++,t.errors.push({recurringInvoiceId:r.id,error:e.message||"Unknown error"}),console.error(`Failed to generate recurring invoice ${r.id}:`,e)}return t}async function y(e){let t=(0,a.getFirestore)();return(await t.collection("recurring_invoice_history").where("recurringInvoiceId","==",e).orderBy("generatedAt","desc").get()).docs.map(e=>e.data())}function I(e){let t=[];return e.clientId||t.push("Client ID is required"),e.clientName||t.push("Client name is required"),e.clientEmail||t.push("Client email is required"),e.description||t.push("Description is required"),e.lineItems&&0!==e.lineItems.length||t.push("At least one line item is required"),e.startDate||t.push("Start date is required"),e.frequency||t.push("Frequency is required"),(!e.paymentTermsDays||e.paymentTermsDays<0)&&t.push("Valid payment terms required"),e.lineItems&&e.lineItems.forEach((e,r)=>{e.description||t.push(`Line item ${r+1}: Description required`),e.quantity<=0&&t.push(`Line item ${r+1}: Quantity must be positive`),e.unitPrice<0&&t.push(`Line item ${r+1}: Unit price must be non-negative`)}),e.startDate&&e.endDate&&new Date(e.endDate)<=new Date(e.startDate)&&t.push("End date must be after start date"),t}e.s(["RecurringInvoiceStatus",()=>s,"cancelRecurringInvoice",()=>v,"createRecurringInvoice",()=>o,"getRecurringInvoice",()=>c,"getRecurringInvoiceHistory",()=>y,"getUserRecurringInvoices",()=>u,"pauseRecurringInvoice",()=>p,"processRecurringInvoices",()=>f,"resumeRecurringInvoice",()=>g,"updateRecurringInvoice",()=>d,"validateRecurringInvoice",()=>I]),r()}catch(e){r(e)}},!1),711306,e=>e.a(async(t,r)=>{try{var n=e.i(89171),a=e.i(391889),i=t([a]);async function s(e){try{let t=e.headers.get("authorization"),r=process.env.CRON_SECRET;if(r&&t!==`Bearer ${r}`)return n.NextResponse.json({error:"Unauthorized"},{status:401});console.log("[CRON] Processing recurring invoices...");let i=await (0,a.processRecurringInvoices)();return console.log("[CRON] Recurring invoices processed:",i),n.NextResponse.json({success:!0,...i,timestamp:new Date().toISOString()})}catch(e){return console.error("[CRON] Process recurring invoices error:",e),n.NextResponse.json({success:!1,error:e.message||"Failed to process recurring invoices",timestamp:new Date().toISOString()},{status:500})}}async function o(e){return s(e)}[a]=i.then?(await i)():i,e.s(["GET",()=>s,"POST",()=>o]),r()}catch(e){r(e)}},!1),739101,e=>e.a(async(t,r)=>{try{var n=e.i(747909),a=e.i(174017),i=e.i(996250),s=e.i(759756),o=e.i(561916),c=e.i(114444),u=e.i(837092),l=e.i(869741),d=e.i(316795),p=e.i(487718),g=e.i(995169),v=e.i(47587),h=e.i(666012),w=e.i(570101),m=e.i(626937),R=e.i(10372),f=e.i(193695);e.i(52474);var y=e.i(600220),I=e.i(711306),x=t([I]);[I]=x.then?(await x)():x;let S=new n.AppRouteRouteModule({definition:{kind:a.RouteKind.APP_ROUTE,page:"/api/cron/process-recurring-invoices/route",pathname:"/api/cron/process-recurring-invoices",filename:"route",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/app/api/cron/process-recurring-invoices/route.ts",nextConfigOutput:"",userland:I}),{workAsyncStorage:C,workUnitAsyncStorage:A,serverHooks:O}=S;function D(){return(0,i.patchFetch)({workAsyncStorage:C,workUnitAsyncStorage:A})}async function E(e,t,r){S.isDev&&(0,s.addRequestMeta)(e,"devRequestTimingInternalsEnd",process.hrtime.bigint());let n="/api/cron/process-recurring-invoices/route";n=n.replace(/\/index$/,"")||"/";let i=await S.prepare(e,t,{srcPage:n,multiZoneDraftMode:!1});if(!i)return t.statusCode=400,t.end("Bad Request"),null==r.waitUntil||r.waitUntil.call(r,Promise.resolve()),null;let{buildId:I,params:x,nextConfig:D,parsedUrl:E,isDraftMode:C,prerenderManifest:A,routerServerContext:O,isOnDemandRevalidate:b,revalidateOnlyGenerated:q,resolvedPathname:T,clientReferenceManifest:N,serverActionsManifest:P}=i,_=(0,l.normalizeAppPath)(n),k=!!(A.dynamicRoutes[_]||A.routes[T]),F=async()=>((null==O?void 0:O.render404)?await O.render404(e,t,E,!1):t.end("This page could not be found"),null);if(k&&!C){let e=!!A.routes[T],t=A.dynamicRoutes[_];if(t&&!1===t.fallback&&!e){if(D.experimental.adapterPath)return await F();throw new f.NoFallbackError}}let U=null;!k||S.isDev||C||(U=T,U="/index"===U?"/":U);let M=!0===S.isDev||!k,j=k&&!M;P&&N&&(0,c.setReferenceManifestsSingleton)({page:n,clientReferenceManifest:N,serverActionsManifest:P,serverModuleMap:(0,u.createServerModuleMap)({serverActionsManifest:P})});let H=e.method||"GET",$=(0,o.getTracer)(),L=$.getActiveScopeSpan(),K={params:x,prerenderManifest:A,renderOpts:{experimental:{authInterrupts:!!D.experimental.authInterrupts},cacheComponents:!!D.cacheComponents,supportsDynamicResponse:M,incrementalCache:(0,s.getRequestMeta)(e,"incrementalCache"),cacheLifeProfiles:D.cacheLife,waitUntil:r.waitUntil,onClose:e=>{t.on("close",e)},onAfterTaskError:void 0,onInstrumentationRequestError:(t,r,n)=>S.onRequestError(e,t,n,O)},sharedContext:{buildId:I}},V=new d.NodeNextRequest(e),B=new d.NodeNextResponse(t),G=p.NextRequestAdapter.fromNodeNextRequest(V,(0,p.signalFromNodeResponse)(t));try{let i=async e=>S.handle(G,K).finally(()=>{if(!e)return;e.setAttributes({"http.status_code":t.statusCode,"next.rsc":!1});let r=$.getRootSpanAttributes();if(!r)return;if(r.get("next.span_type")!==g.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${r.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let a=r.get("next.route");if(a){let t=`${H} ${a}`;e.setAttributes({"next.route":a,"http.route":a,"next.span_name":t}),e.updateName(t)}else e.updateName(`${H} ${n}`)}),c=!!(0,s.getRequestMeta)(e,"minimalMode"),u=async s=>{var o,u;let l=async({previousCacheEntry:a})=>{try{if(!c&&b&&q&&!a)return t.statusCode=404,t.setHeader("x-nextjs-cache","REVALIDATED"),t.end("This page could not be found"),null;let n=await i(s);e.fetchMetrics=K.renderOpts.fetchMetrics;let o=K.renderOpts.pendingWaitUntil;o&&r.waitUntil&&(r.waitUntil(o),o=void 0);let u=K.renderOpts.collectedTags;if(!k)return await (0,h.sendResponse)(V,B,n,K.renderOpts.pendingWaitUntil),null;{let e=await n.blob(),t=(0,w.toNodeOutgoingHttpHeaders)(n.headers);u&&(t[R.NEXT_CACHE_TAGS_HEADER]=u),!t["content-type"]&&e.type&&(t["content-type"]=e.type);let r=void 0!==K.renderOpts.collectedRevalidate&&!(K.renderOpts.collectedRevalidate>=R.INFINITE_CACHE)&&K.renderOpts.collectedRevalidate,a=void 0===K.renderOpts.collectedExpire||K.renderOpts.collectedExpire>=R.INFINITE_CACHE?void 0:K.renderOpts.collectedExpire;return{value:{kind:y.CachedRouteKind.APP_ROUTE,status:n.status,body:Buffer.from(await e.arrayBuffer()),headers:t},cacheControl:{revalidate:r,expire:a}}}}catch(t){throw(null==a?void 0:a.isStale)&&await S.onRequestError(e,t,{routerKind:"App Router",routePath:n,routeType:"route",revalidateReason:(0,v.getRevalidateReason)({isStaticGeneration:j,isOnDemandRevalidate:b})},O),t}},d=await S.handleResponse({req:e,nextConfig:D,cacheKey:U,routeKind:a.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:A,isRoutePPREnabled:!1,isOnDemandRevalidate:b,revalidateOnlyGenerated:q,responseGenerator:l,waitUntil:r.waitUntil,isMinimalMode:c});if(!k)return null;if((null==d||null==(o=d.value)?void 0:o.kind)!==y.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==d||null==(u=d.value)?void 0:u.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});c||t.setHeader("x-nextjs-cache",b?"REVALIDATED":d.isMiss?"MISS":d.isStale?"STALE":"HIT"),C&&t.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let p=(0,w.fromNodeOutgoingHttpHeaders)(d.value.headers);return c&&k||p.delete(R.NEXT_CACHE_TAGS_HEADER),!d.cacheControl||t.getHeader("Cache-Control")||p.get("Cache-Control")||p.set("Cache-Control",(0,m.getCacheControlHeader)(d.cacheControl)),await (0,h.sendResponse)(V,B,new Response(d.value.body,{headers:p,status:d.value.status||200})),null};L?await u(L):await $.withPropagatedContext(e.headers,()=>$.trace(g.BaseServerSpan.handleRequest,{spanName:`${H} ${n}`,kind:o.SpanKind.SERVER,attributes:{"http.method":H,"http.target":e.url}},u))}catch(t){if(t instanceof f.NoFallbackError||await S.onRequestError(e,t,{routerKind:"App Router",routePath:_,routeType:"route",revalidateReason:(0,v.getRevalidateReason)({isStaticGeneration:j,isOnDemandRevalidate:b})}),k)throw t;return await (0,h.sendResponse)(V,B,new Response(null,{status:500})),null}}e.s(["handler",()=>E,"patchFetch",()=>D,"routeModule",()=>S,"serverHooks",()=>O,"workAsyncStorage",()=>C,"workUnitAsyncStorage",()=>A]),r()}catch(e){r(e)}},!1)];

//# sourceMappingURL=%5Broot-of-the-server%5D__943af18e._.js.map