{"version":3,"sources":["turbopack:///[project]/node_modules/next/src/client/components/navigation-untracked.ts","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/create-href-from-url.ts","turbopack:///[project]/node_modules/next/src/client/components/nav-failure-handler.ts","turbopack:///[project]/node_modules/next/src/shared/lib/router/utils/html-bots.ts","turbopack:///[project]/node_modules/next/src/shared/lib/router/utils/is-bot.ts","turbopack:///[project]/node_modules/next/src/client/components/error-boundary.tsx","turbopack:///[project]/node_modules/next/src/shared/lib/page-path/ensure-leading-slash.ts","turbopack:///[project]/node_modules/next/src/shared/lib/router/utils/app-paths.ts","turbopack:///[project]/node_modules/next/src/shared/lib/router/utils/interception-routes.ts","turbopack:///[project]/node_modules/next/src/client/components/match-segments.ts","turbopack:///[project]/node_modules/next/src/shared/lib/segment-cache/segment-value-encoding.ts","turbopack:///[project]/node_modules/next/src/client/route-params.ts","turbopack:///[project]/node_modules/next/src/client/flight-data-helpers.ts","turbopack:///[project]/node_modules/next/src/client/app-build-id.ts","turbopack:///[project]/node_modules/next/src/shared/lib/hash.ts","turbopack:///[project]/node_modules/next/src/shared/lib/router/utils/cache-busting-search-param.ts","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/set-cache-busting-search-param.ts","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/fetch-server-response.ts","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/create-router-cache-key.ts","turbopack:///[project]/node_modules/next/src/client/components/redirect-boundary.tsx","turbopack:///[project]/node_modules/next/src/client/components/unresolved-thenable.ts","turbopack:///[project]/node_modules/next/src/lib/framework/boundary-components.tsx","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/reducers/has-interception-route-in-current-tree.ts"],"sourcesContent":["import { useContext } from 'react'\nimport { PathnameContext } from '../../shared/lib/hooks-client-context.shared-runtime'\n\n/**\n * This checks to see if the current render has any unknown route parameters that\n * would cause the pathname to be dynamic. It's used to trigger a different\n * render path in the error boundary.\n *\n * @returns true if there are any unknown route parameters, false otherwise\n */\nfunction hasFallbackRouteParams(): boolean {\n  if (typeof window === 'undefined') {\n    // AsyncLocalStorage should not be included in the client bundle.\n    const { workUnitAsyncStorage } =\n      require('../../server/app-render/work-unit-async-storage.external') as typeof import('../../server/app-render/work-unit-async-storage.external')\n\n    const workUnitStore = workUnitAsyncStorage.getStore()\n    if (!workUnitStore) return false\n\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n        const fallbackParams = workUnitStore.fallbackRouteParams\n        return fallbackParams ? fallbackParams.size > 0 : false\n      case 'prerender-legacy':\n      case 'request':\n      case 'prerender-runtime':\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n\n    return false\n  }\n\n  return false\n}\n\n/**\n * This returns a `null` value if there are any unknown route parameters, and\n * otherwise returns the pathname from the context. This is an alternative to\n * `usePathname` that is used in the error boundary to avoid rendering the\n * error boundary when there are unknown route parameters. This doesn't throw\n * when accessed with unknown route parameters.\n *\n * @returns\n *\n * @internal\n */\nexport function useUntrackedPathname(): string | null {\n  // If there are any unknown route parameters we would typically throw\n  // an error, but this internal method allows us to return a null value instead\n  // for components that do not propagate the pathname to the static shell (like\n  // the error boundary).\n  if (hasFallbackRouteParams()) {\n    return null\n  }\n\n  // This shouldn't cause any issues related to conditional rendering because\n  // the environment will be consistent for the render.\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  return useContext(PathnameContext)\n}\n","export function createHrefFromUrl(\n  url: Pick<URL, 'pathname' | 'search' | 'hash'>,\n  includeHash: boolean = true\n): string {\n  return url.pathname + url.search + (includeHash ? url.hash : '')\n}\n","import { useEffect } from 'react'\nimport { createHrefFromUrl } from './router-reducer/create-href-from-url'\n\nexport function handleHardNavError(error: unknown): boolean {\n  if (\n    error &&\n    typeof window !== 'undefined' &&\n    window.next.__pendingUrl &&\n    createHrefFromUrl(new URL(window.location.href)) !==\n      createHrefFromUrl(window.next.__pendingUrl)\n  ) {\n    console.error(\n      `Error occurred during navigation, falling back to hard navigation`,\n      error\n    )\n    window.location.href = window.next.__pendingUrl.toString()\n    return true\n  }\n  return false\n}\n\nexport function useNavFailureHandler() {\n  if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n    // this if is only for DCE of the feature flag not conditional\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      const uncaughtExceptionHandler = (\n        evt: ErrorEvent | PromiseRejectionEvent\n      ) => {\n        const error = 'reason' in evt ? evt.reason : evt.error\n        // if we have an unhandled exception/rejection during\n        // a navigation we fall back to a hard navigation to\n        // attempt recovering to a good state\n        handleHardNavError(error)\n      }\n      window.addEventListener('unhandledrejection', uncaughtExceptionHandler)\n      window.addEventListener('error', uncaughtExceptionHandler)\n      return () => {\n        window.removeEventListener('error', uncaughtExceptionHandler)\n        window.removeEventListener(\n          'unhandledrejection',\n          uncaughtExceptionHandler\n        )\n      }\n    }, [])\n  }\n}\n","// This regex contains the bots that we need to do a blocking render for and can't safely stream the response\n// due to how they parse the DOM. For example, they might explicitly check for metadata in the `head` tag, so we can't stream metadata tags after the `head` was sent.\n// Note: The pattern [\\w-]+-Google captures all Google crawlers with \"-Google\" suffix (e.g., Mediapartners-Google, AdsBot-Google, Storebot-Google)\n// as well as crawlers starting with \"Google-\" (e.g., Google-PageRenderer, Google-InspectionTool)\nexport const HTML_LIMITED_BOT_UA_RE =\n  /[\\w-]+-Google|Google-[\\w-]+|Chrome-Lighthouse|Slurp|DuckDuckBot|baiduspider|yandex|sogou|bitlybot|tumblr|vkShare|quora link preview|redditbot|ia_archiver|Bingbot|BingPreview|applebot|facebookexternalhit|facebookcatalog|Twitterbot|LinkedInBot|Slackbot|Discordbot|WhatsApp|SkypeUriPreview|Yeti|googleweblight/i\n","import { HTML_LIMITED_BOT_UA_RE } from './html-bots'\n\n// Bot crawler that will spin up a headless browser and execute JS.\n// Only the main Googlebot search crawler executes JavaScript, not other Google crawlers.\n// x-ref: https://developers.google.com/search/docs/crawling-indexing/google-common-crawlers\n// This regex specifically matches \"Googlebot\" but NOT \"Mediapartners-Google\", \"AdsBot-Google\", etc.\nconst HEADLESS_BROWSER_BOT_UA_RE = /Googlebot(?!-)|Googlebot$/i\n\nexport const HTML_LIMITED_BOT_UA_RE_STRING = HTML_LIMITED_BOT_UA_RE.source\n\nexport { HTML_LIMITED_BOT_UA_RE }\n\nfunction isDomBotUA(userAgent: string) {\n  return HEADLESS_BROWSER_BOT_UA_RE.test(userAgent)\n}\n\nfunction isHtmlLimitedBotUA(userAgent: string) {\n  return HTML_LIMITED_BOT_UA_RE.test(userAgent)\n}\n\nexport function isBot(userAgent: string): boolean {\n  return isDomBotUA(userAgent) || isHtmlLimitedBotUA(userAgent)\n}\n\nexport function getBotType(userAgent: string): 'dom' | 'html' | undefined {\n  if (isDomBotUA(userAgent)) {\n    return 'dom'\n  }\n  if (isHtmlLimitedBotUA(userAgent)) {\n    return 'html'\n  }\n  return undefined\n}\n","'use client'\n\nimport React, { type JSX } from 'react'\nimport { useUntrackedPathname } from './navigation-untracked'\nimport { isNextRouterError } from './is-next-router-error'\nimport { handleHardNavError } from './nav-failure-handler'\nimport { HandleISRError } from './handle-isr-error'\nimport { isBot } from '../../shared/lib/router/utils/is-bot'\n\nconst isBotUserAgent =\n  typeof window !== 'undefined' && isBot(window.navigator.userAgent)\n\nexport type ErrorComponent = React.ComponentType<{\n  error: Error\n  // global-error, there's no `reset` function;\n  // regular error boundary, there's a `reset` function.\n  reset?: () => void\n}>\n\nexport interface ErrorBoundaryProps {\n  children?: React.ReactNode\n  errorComponent: ErrorComponent | undefined\n  errorStyles?: React.ReactNode | undefined\n  errorScripts?: React.ReactNode | undefined\n}\n\ninterface ErrorBoundaryHandlerProps extends ErrorBoundaryProps {\n  pathname: string | null\n  errorComponent: ErrorComponent\n}\n\ninterface ErrorBoundaryHandlerState {\n  error: Error | null\n  previousPathname: string | null\n}\n\nexport class ErrorBoundaryHandler extends React.Component<\n  ErrorBoundaryHandlerProps,\n  ErrorBoundaryHandlerState\n> {\n  constructor(props: ErrorBoundaryHandlerProps) {\n    super(props)\n    this.state = { error: null, previousPathname: this.props.pathname }\n  }\n\n  static getDerivedStateFromError(error: Error) {\n    if (isNextRouterError(error)) {\n      // Re-throw if an expected internal Next.js router error occurs\n      // this means it should be handled by a different boundary (such as a NotFound boundary in a parent segment)\n      throw error\n    }\n\n    return { error }\n  }\n\n  static getDerivedStateFromProps(\n    props: ErrorBoundaryHandlerProps,\n    state: ErrorBoundaryHandlerState\n  ): ErrorBoundaryHandlerState | null {\n    const { error } = state\n\n    // if we encounter an error while\n    // a navigation is pending we shouldn't render\n    // the error boundary and instead should fallback\n    // to a hard navigation to attempt recovering\n    if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n      if (error && handleHardNavError(error)) {\n        // clear error so we don't render anything\n        return {\n          error: null,\n          previousPathname: props.pathname,\n        }\n      }\n    }\n\n    /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */\n    if (props.pathname !== state.previousPathname && state.error) {\n      return {\n        error: null,\n        previousPathname: props.pathname,\n      }\n    }\n    return {\n      error: state.error,\n      previousPathname: props.pathname,\n    }\n  }\n\n  reset = () => {\n    this.setState({ error: null })\n  }\n\n  // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.\n  render(): React.ReactNode {\n    //When it's bot request, segment level error boundary will keep rendering the children,\n    // the final error will be caught by the root error boundary and determine wether need to apply graceful degrade.\n    if (this.state.error && !isBotUserAgent) {\n      return (\n        <>\n          <HandleISRError error={this.state.error} />\n          {this.props.errorStyles}\n          {this.props.errorScripts}\n          <this.props.errorComponent\n            error={this.state.error}\n            reset={this.reset}\n          />\n        </>\n      )\n    }\n\n    return this.props.children\n  }\n}\n\n/**\n * Handles errors through `getDerivedStateFromError`.\n * Renders the provided error component and provides a way to `reset` the error boundary state.\n */\n\n/**\n * Renders error boundary with the provided \"errorComponent\" property as the fallback.\n * If no \"errorComponent\" property is provided it renders the children without an error boundary.\n */\nexport function ErrorBoundary({\n  errorComponent,\n  errorStyles,\n  errorScripts,\n  children,\n}: ErrorBoundaryProps & {\n  children: React.ReactNode\n}): JSX.Element {\n  // When we're rendering the missing params shell, this will return null. This\n  // is because we won't be rendering any not found boundaries or error\n  // boundaries for the missing params shell. When this runs on the client\n  // (where these errors can occur), we will get the correct pathname.\n  const pathname = useUntrackedPathname()\n  if (errorComponent) {\n    return (\n      <ErrorBoundaryHandler\n        pathname={pathname}\n        errorComponent={errorComponent}\n        errorStyles={errorStyles}\n        errorScripts={errorScripts}\n      >\n        {children}\n      </ErrorBoundaryHandler>\n    )\n  }\n\n  return <>{children}</>\n}\n","/**\n * For a given page path, this function ensures that there is a leading slash.\n * If there is not a leading slash, one is added, otherwise it is noop.\n */\nexport function ensureLeadingSlash(path: string) {\n  return path.startsWith('/') ? path : `/${path}`\n}\n","import { ensureLeadingSlash } from '../../page-path/ensure-leading-slash'\nimport { isGroupSegment } from '../../segment'\n\n/**\n * Normalizes an app route so it represents the actual request path. Essentially\n * performing the following transformations:\n *\n * - `/(dashboard)/user/[id]/page` to `/user/[id]`\n * - `/(dashboard)/account/page` to `/account`\n * - `/user/[id]/page` to `/user/[id]`\n * - `/account/page` to `/account`\n * - `/page` to `/`\n * - `/(dashboard)/user/[id]/route` to `/user/[id]`\n * - `/(dashboard)/account/route` to `/account`\n * - `/user/[id]/route` to `/user/[id]`\n * - `/account/route` to `/account`\n * - `/route` to `/`\n * - `/` to `/`\n *\n * @param route the app route to normalize\n * @returns the normalized pathname\n */\nexport function normalizeAppPath(route: string) {\n  return ensureLeadingSlash(\n    route.split('/').reduce((pathname, segment, index, segments) => {\n      // Empty segments are ignored.\n      if (!segment) {\n        return pathname\n      }\n\n      // Groups are ignored.\n      if (isGroupSegment(segment)) {\n        return pathname\n      }\n\n      // Parallel segments are ignored.\n      if (segment[0] === '@') {\n        return pathname\n      }\n\n      // The last segment (if it's a leaf) should be ignored.\n      if (\n        (segment === 'page' || segment === 'route') &&\n        index === segments.length - 1\n      ) {\n        return pathname\n      }\n\n      return `${pathname}/${segment}`\n    }, '')\n  )\n}\n\n/**\n * Strips the `.rsc` extension if it's in the pathname.\n * Since this function is used on full urls it checks `?` for searchParams handling.\n */\nexport function normalizeRscURL(url: string) {\n  return url.replace(\n    /\\.rsc($|\\?)/,\n    // $1 ensures `?` is preserved\n    '$1'\n  )\n}\n","import { normalizeAppPath } from './app-paths'\n\n// order matters here, the first match will be used\nexport const INTERCEPTION_ROUTE_MARKERS = [\n  '(..)(..)',\n  '(.)',\n  '(..)',\n  '(...)',\n] as const\n\nexport function isInterceptionRouteAppPath(path: string): boolean {\n  // TODO-APP: add more serious validation\n  return (\n    path\n      .split('/')\n      .find((segment) =>\n        INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))\n      ) !== undefined\n  )\n}\n\ntype InterceptionRouteInformation = {\n  /**\n   * The intercepting route. This is the route that is being intercepted or the\n   * route that the user was coming from. This is matched by the Next-Url\n   * header.\n   */\n  interceptingRoute: string\n\n  /**\n   * The intercepted route. This is the route that is being intercepted or the\n   * route that the user is going to. This is matched by the request pathname.\n   */\n  interceptedRoute: string\n}\n\nexport function extractInterceptionRouteInformation(\n  path: string\n): InterceptionRouteInformation {\n  let interceptingRoute: string | undefined\n  let marker: (typeof INTERCEPTION_ROUTE_MARKERS)[number] | undefined\n  let interceptedRoute: string | undefined\n\n  for (const segment of path.split('/')) {\n    marker = INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))\n    if (marker) {\n      ;[interceptingRoute, interceptedRoute] = path.split(marker, 2)\n      break\n    }\n  }\n\n  if (!interceptingRoute || !marker || !interceptedRoute) {\n    throw new Error(\n      `Invalid interception route: ${path}. Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>`\n    )\n  }\n\n  interceptingRoute = normalizeAppPath(interceptingRoute) // normalize the path, e.g. /(blog)/feed -> /feed\n\n  switch (marker) {\n    case '(.)':\n      // (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route\n      if (interceptingRoute === '/') {\n        interceptedRoute = `/${interceptedRoute}`\n      } else {\n        interceptedRoute = interceptingRoute + '/' + interceptedRoute\n      }\n      break\n    case '(..)':\n      // (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route\n      if (interceptingRoute === '/') {\n        throw new Error(\n          `Invalid interception route: ${path}. Cannot use (..) marker at the root level, use (.) instead.`\n        )\n      }\n      interceptedRoute = interceptingRoute\n        .split('/')\n        .slice(0, -1)\n        .concat(interceptedRoute)\n        .join('/')\n      break\n    case '(...)':\n      // (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route\n      interceptedRoute = '/' + interceptedRoute\n      break\n    case '(..)(..)':\n      // (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route\n\n      const splitInterceptingRoute = interceptingRoute.split('/')\n      if (splitInterceptingRoute.length <= 2) {\n        throw new Error(\n          `Invalid interception route: ${path}. Cannot use (..)(..) marker at the root level or one level up.`\n        )\n      }\n\n      interceptedRoute = splitInterceptingRoute\n        .slice(0, -2)\n        .concat(interceptedRoute)\n        .join('/')\n      break\n    default:\n      throw new Error('Invariant: unexpected marker')\n  }\n\n  return { interceptingRoute, interceptedRoute }\n}\n","import type { Segment } from '../../shared/lib/app-router-types'\n\nexport const matchSegment = (\n  existingSegment: Segment,\n  segment: Segment\n): boolean => {\n  // segment is either Array or string\n  if (typeof existingSegment === 'string') {\n    if (typeof segment === 'string') {\n      // Common case: segment is just a string\n      return existingSegment === segment\n    }\n    return false\n  }\n\n  if (typeof segment === 'string') {\n    return false\n  }\n  return existingSegment[0] === segment[0] && existingSegment[1] === segment[1]\n}\n","import { PAGE_SEGMENT_KEY } from '../segment'\nimport type { Segment as FlightRouterStateSegment } from '../app-router-types'\n\n// TypeScript trick to simulate opaque types, like in Flow.\ntype Opaque<K, T> = T & { __brand: K }\n\nexport type SegmentRequestKeyPart = Opaque<'SegmentRequestKeyPart', string>\nexport type SegmentRequestKey = Opaque<'SegmentRequestKey', string>\n\nexport const ROOT_SEGMENT_REQUEST_KEY = '' as SegmentRequestKey\n\nexport const HEAD_REQUEST_KEY = '/_head' as SegmentRequestKey\n\nexport function createSegmentRequestKeyPart(\n  segment: FlightRouterStateSegment\n): SegmentRequestKeyPart {\n  if (typeof segment === 'string') {\n    if (segment.startsWith(PAGE_SEGMENT_KEY)) {\n      // The Flight Router State type sometimes includes the search params in\n      // the page segment. However, the Segment Cache tracks this as a separate\n      // key. So, we strip the search params here, and then add them back when\n      // the cache entry is turned back into a FlightRouterState. This is an\n      // unfortunate consequence of the FlightRouteState being used both as a\n      // transport type and as a cache key; we'll address this once more of the\n      // Segment Cache implementation has settled.\n      // TODO: We should hoist the search params out of the FlightRouterState\n      // type entirely, This is our plan for dynamic route params, too.\n      return PAGE_SEGMENT_KEY as SegmentRequestKeyPart\n    }\n    const safeName =\n      // TODO: FlightRouterState encodes Not Found routes as \"/_not-found\".\n      // But params typically don't include the leading slash. We should use\n      // a different encoding to avoid this special case.\n      segment === '/_not-found'\n        ? '_not-found'\n        : encodeToFilesystemAndURLSafeString(segment)\n    // Since this is not a dynamic segment, it's fully encoded. It does not\n    // need to be \"hydrated\" with a param value.\n    return safeName as SegmentRequestKeyPart\n  }\n\n  const name = segment[0]\n  const paramType = segment[2]\n  const safeName = encodeToFilesystemAndURLSafeString(name)\n\n  const encodedName = '$' + paramType + '$' + safeName\n  return encodedName as SegmentRequestKeyPart\n}\n\nexport function appendSegmentRequestKeyPart(\n  parentRequestKey: SegmentRequestKey,\n  parallelRouteKey: string,\n  childRequestKeyPart: SegmentRequestKeyPart\n): SegmentRequestKey {\n  // Aside from being filesystem safe, segment keys are also designed so that\n  // each segment and parallel route creates its own subdirectory. Roughly in\n  // the same shape as the source app directory. This is mostly just for easier\n  // debugging (you can open up the build folder and navigate the output); if\n  // we wanted to do we could just use a flat structure.\n\n  // Omit the parallel route key for children, since this is the most\n  // common case. Saves some bytes (and it's what the app directory does).\n  const slotKey =\n    parallelRouteKey === 'children'\n      ? childRequestKeyPart\n      : `@${encodeToFilesystemAndURLSafeString(parallelRouteKey)}/${childRequestKeyPart}`\n  return (parentRequestKey + '/' + slotKey) as SegmentRequestKey\n}\n\n// Define a regex pattern to match the most common characters found in a route\n// param. It excludes anything that might not be cross-platform filesystem\n// compatible, like |. It does not need to be precise because the fallback is to\n// just base64url-encode the whole parameter, which is fine; we just don't do it\n// by default for compactness, and for easier debugging.\nconst simpleParamValueRegex = /^[a-zA-Z0-9\\-_@]+$/\n\nfunction encodeToFilesystemAndURLSafeString(value: string) {\n  if (simpleParamValueRegex.test(value)) {\n    return value\n  }\n  // If there are any unsafe characters, base64url-encode the entire value.\n  // We also add a ! prefix so it doesn't collide with the simple case.\n  const base64url = btoa(value)\n    .replace(/\\+/g, '-') // Replace '+' with '-'\n    .replace(/\\//g, '_') // Replace '/' with '_'\n    .replace(/=+$/, '') // Remove trailing '='\n  return '!' + base64url\n}\n\nexport function convertSegmentPathToStaticExportFilename(\n  segmentPath: string\n): string {\n  return `__next${segmentPath.replace(/\\//g, '.')}.txt`\n}\n","import type { DynamicParamTypesShort } from '../shared/lib/app-router-types'\nimport {\n  addSearchParamsIfPageSegment,\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../shared/lib/segment'\nimport { ROOT_SEGMENT_REQUEST_KEY } from '../shared/lib/segment-cache/segment-value-encoding'\nimport {\n  NEXT_REWRITTEN_PATH_HEADER,\n  NEXT_REWRITTEN_QUERY_HEADER,\n  NEXT_RSC_UNION_QUERY,\n} from './components/app-router-headers'\nimport type {\n  NormalizedPathname,\n  NormalizedSearch,\n} from './components/segment-cache/cache-key'\nimport type { RSCResponse } from './components/router-reducer/fetch-server-response'\nimport type { ParsedUrlQuery } from 'querystring'\n\nexport type RouteParamValue = string | Array<string> | null\n\nexport function getRenderedSearch(\n  response: RSCResponse<unknown> | Response\n): NormalizedSearch {\n  // If the server performed a rewrite, the search params used to render the\n  // page will be different from the params in the request URL. In this case,\n  // the response will include a header that gives the rewritten search query.\n  const rewrittenQuery = response.headers.get(NEXT_REWRITTEN_QUERY_HEADER)\n  if (rewrittenQuery !== null) {\n    return (\n      rewrittenQuery === '' ? '' : '?' + rewrittenQuery\n    ) as NormalizedSearch\n  }\n  // If the header is not present, there was no rewrite, so we use the search\n  // query of the response URL.\n  return urlToUrlWithoutFlightMarker(new URL(response.url))\n    .search as NormalizedSearch\n}\n\nexport function getRenderedPathname(\n  response: RSCResponse<unknown> | Response\n): NormalizedPathname {\n  // If the server performed a rewrite, the pathname used to render the\n  // page will be different from the pathname in the request URL. In this case,\n  // the response will include a header that gives the rewritten pathname.\n  const rewrittenPath = response.headers.get(NEXT_REWRITTEN_PATH_HEADER)\n  return (rewrittenPath ??\n    urlToUrlWithoutFlightMarker(new URL(response.url))\n      .pathname) as NormalizedPathname\n}\n\nexport function parseDynamicParamFromURLPart(\n  paramType: DynamicParamTypesShort,\n  pathnameParts: Array<string>,\n  partIndex: number\n): RouteParamValue {\n  // This needs to match the behavior in get-dynamic-param.ts.\n  switch (paramType) {\n    // Catchalls\n    case 'c': {\n      // Catchalls receive all the remaining URL parts. If there are no\n      // remaining pathname parts, return an empty array.\n      return partIndex < pathnameParts.length\n        ? pathnameParts.slice(partIndex).map((s) => encodeURIComponent(s))\n        : []\n    }\n    // Catchall intercepted\n    case 'ci(..)(..)':\n    case 'ci(.)':\n    case 'ci(..)':\n    case 'ci(...)': {\n      const prefix = paramType.length - 2\n      return partIndex < pathnameParts.length\n        ? pathnameParts.slice(partIndex).map((s, i) => {\n            if (i === 0) {\n              return encodeURIComponent(s.slice(prefix))\n            }\n\n            return encodeURIComponent(s)\n          })\n        : []\n    }\n    // Optional catchalls\n    case 'oc': {\n      // Optional catchalls receive all the remaining URL parts, unless this is\n      // the end of the pathname, in which case they return null.\n      return partIndex < pathnameParts.length\n        ? pathnameParts.slice(partIndex).map((s) => encodeURIComponent(s))\n        : null\n    }\n    // Dynamic\n    case 'd': {\n      if (partIndex >= pathnameParts.length) {\n        // The route tree expected there to be more parts in the URL than there\n        // actually are. This could happen if the x-nextjs-rewritten-path header\n        // is incorrectly set, or potentially due to bug in Next.js. TODO:\n        // Should this be a hard error? During a prefetch, we can just abort.\n        // During a client navigation, we could trigger a hard refresh. But if\n        // it happens during initial render, we don't really have any\n        // recovery options.\n        return ''\n      }\n      return encodeURIComponent(pathnameParts[partIndex])\n    }\n    // Dynamic intercepted\n    case 'di(..)(..)':\n    case 'di(.)':\n    case 'di(..)':\n    case 'di(...)': {\n      const prefix = paramType.length - 2\n      if (partIndex >= pathnameParts.length) {\n        // The route tree expected there to be more parts in the URL than there\n        // actually are. This could happen if the x-nextjs-rewritten-path header\n        // is incorrectly set, or potentially due to bug in Next.js. TODO:\n        // Should this be a hard error? During a prefetch, we can just abort.\n        // During a client navigation, we could trigger a hard refresh. But if\n        // it happens during initial render, we don't really have any\n        // recovery options.\n        return ''\n      }\n\n      return encodeURIComponent(pathnameParts[partIndex].slice(prefix))\n    }\n    default:\n      paramType satisfies never\n      return ''\n  }\n}\n\nexport function doesStaticSegmentAppearInURL(segment: string): boolean {\n  // This is not a parameterized segment; however, we need to determine\n  // whether or not this segment appears in the URL. For example, this route\n  // groups do not appear in the URL, so they should be skipped. Any other\n  // special cases must be handled here.\n  // TODO: Consider encoding this directly into the router tree instead of\n  // inferring it on the client based on the segment type. Something like\n  // a `doesAppearInURL` flag in FlightRouterState.\n  if (\n    segment === ROOT_SEGMENT_REQUEST_KEY ||\n    // For some reason, the loader tree sometimes includes extra __PAGE__\n    // \"layouts\" when part of a parallel route. But it's not a leaf node.\n    // Otherwise, we wouldn't need this special case because pages are\n    // always leaf nodes.\n    // TODO: Investigate why the loader produces these fake page segments.\n    segment.startsWith(PAGE_SEGMENT_KEY) ||\n    // Route groups.\n    (segment[0] === '(' && segment.endsWith(')')) ||\n    segment === DEFAULT_SEGMENT_KEY ||\n    segment === '/_not-found'\n  ) {\n    return false\n  } else {\n    // All other segment types appear in the URL\n    return true\n  }\n}\n\nexport function getCacheKeyForDynamicParam(\n  paramValue: RouteParamValue,\n  renderedSearch: NormalizedSearch\n): string {\n  // This needs to match the logic in get-dynamic-param.ts, until we're able to\n  // unify the various implementations so that these are always computed on\n  // the client.\n  if (typeof paramValue === 'string') {\n    // TODO: Refactor or remove this helper function to accept a string rather\n    // than the whole segment type. Also we can probably just append the\n    // search string instead of turning it into JSON.\n    const pageSegmentWithSearchParams = addSearchParamsIfPageSegment(\n      paramValue,\n      Object.fromEntries(new URLSearchParams(renderedSearch))\n    ) as string\n    return pageSegmentWithSearchParams\n  } else if (paramValue === null) {\n    return ''\n  } else {\n    return paramValue.join('/')\n  }\n}\n\nexport function urlToUrlWithoutFlightMarker(url: URL): URL {\n  const urlWithoutFlightParameters = new URL(url)\n  urlWithoutFlightParameters.searchParams.delete(NEXT_RSC_UNION_QUERY)\n  if (process.env.NODE_ENV === 'production') {\n    if (\n      process.env.__NEXT_CONFIG_OUTPUT === 'export' &&\n      urlWithoutFlightParameters.pathname.endsWith('.txt')\n    ) {\n      const { pathname } = urlWithoutFlightParameters\n      const length = pathname.endsWith('/index.txt') ? 10 : 4\n      // Slice off `/index.txt` or `.txt` from the end of the pathname\n      urlWithoutFlightParameters.pathname = pathname.slice(0, -length)\n    }\n  }\n  return urlWithoutFlightParameters\n}\n\nexport function getParamValueFromCacheKey(\n  paramCacheKey: string,\n  paramType: DynamicParamTypesShort\n) {\n  // Turn the cache key string sent by the server (as part of FlightRouterState)\n  // into a value that can be passed to `useParams` and client components.\n  const isCatchAll = paramType === 'c' || paramType === 'oc'\n  if (isCatchAll) {\n    // Catch-all param keys are a concatenation of the path segments.\n    // See equivalent logic in `getSelectedParams`.\n    // TODO: We should just pass the array directly, rather than concatenate\n    // it to a string and then split it back to an array. It needs to be an\n    // array in some places, like when passing a key React, but we can convert\n    // it at runtime in those places.\n    return paramCacheKey.split('/')\n  }\n  return paramCacheKey\n}\n\nexport function urlSearchParamsToParsedUrlQuery(\n  searchParams: URLSearchParams\n): ParsedUrlQuery {\n  // Converts a URLSearchParams object to the same type used by the server when\n  // creating search params props, i.e. the type returned by Node's\n  // \"querystring\" module.\n  const result: ParsedUrlQuery = {}\n  for (const [key, value] of searchParams.entries()) {\n    if (result[key] === undefined) {\n      result[key] = value\n    } else if (Array.isArray(result[key])) {\n      result[key].push(value)\n    } else {\n      result[key] = [result[key], value]\n    }\n  }\n  return result\n}\n","import type {\n  CacheNodeSeedData,\n  FlightData,\n  FlightDataPath,\n  FlightRouterState,\n  FlightSegmentPath,\n  Segment,\n  HeadData,\n  InitialRSCPayload,\n} from '../shared/lib/app-router-types'\nimport { PAGE_SEGMENT_KEY } from '../shared/lib/segment'\nimport type { NormalizedSearch } from './components/segment-cache/cache-key'\nimport {\n  getCacheKeyForDynamicParam,\n  parseDynamicParamFromURLPart,\n  doesStaticSegmentAppearInURL,\n  getRenderedPathname,\n  getRenderedSearch,\n} from './route-params'\nimport { createHrefFromUrl } from './components/router-reducer/create-href-from-url'\n\nexport type NormalizedFlightData = {\n  /**\n   * The full `FlightSegmentPath` inclusive of the final `Segment`\n   */\n  segmentPath: FlightSegmentPath\n  /**\n   * The `FlightSegmentPath` exclusive of the final `Segment`\n   */\n  pathToSegment: FlightSegmentPath\n  segment: Segment\n  tree: FlightRouterState\n  seedData: CacheNodeSeedData | null\n  head: HeadData\n  isHeadPartial: boolean\n  isRootRender: boolean\n}\n\n// TODO: We should only have to export `normalizeFlightData`, however because the initial flight data\n// that gets passed to `createInitialRouterState` doesn't conform to the `FlightDataPath` type (it's missing the root segment)\n// we're currently exporting it so we can use it directly. This should be fixed as part of the unification of\n// the different ways we express `FlightSegmentPath`.\nexport function getFlightDataPartsFromPath(\n  flightDataPath: FlightDataPath\n): NormalizedFlightData {\n  // Pick the last 4 items from the `FlightDataPath` to get the [tree, seedData, viewport, isHeadPartial].\n  const flightDataPathLength = 4\n  // tree, seedData, and head are *always* the last three items in the `FlightDataPath`.\n  const [tree, seedData, head, isHeadPartial] =\n    flightDataPath.slice(-flightDataPathLength)\n  // The `FlightSegmentPath` is everything except the last three items. For a root render, it won't be present.\n  const segmentPath = flightDataPath.slice(0, -flightDataPathLength)\n\n  return {\n    // TODO: Unify these two segment path helpers. We are inconsistently pushing an empty segment (\"\")\n    // to the start of the segment path in some places which makes it hard to use solely the segment path.\n    // Look for \"// TODO-APP: remove ''\" in the codebase.\n    pathToSegment: segmentPath.slice(0, -1),\n    segmentPath,\n    // if the `FlightDataPath` corresponds with the root, there'll be no segment path,\n    // in which case we default to ''.\n    segment: segmentPath[segmentPath.length - 1] ?? '',\n    tree,\n    seedData,\n    head,\n    isHeadPartial,\n    isRootRender: flightDataPath.length === flightDataPathLength,\n  }\n}\n\nexport function createInitialRSCPayloadFromFallbackPrerender(\n  response: Response,\n  fallbackInitialRSCPayload: InitialRSCPayload\n): InitialRSCPayload {\n  // This is a static fallback page. In order to hydrate the page, we need to\n  // parse the client params from the URL, but to account for the possibility\n  // that the page was rewritten, we need to check the response headers\n  // for x-nextjs-rewritten-path or x-nextjs-rewritten-query headers. Since\n  // we can't access the headers of the initial document response, the client\n  // performs a fetch request to the current location. Since it's possible that\n  // the fetch request will be dynamically rewritten to a different path than\n  // the initial document, this fetch request delivers _all_ the hydration data\n  // for the page; it was not inlined into the document, like it normally\n  // would be.\n  //\n  // TODO: Consider treating the case where fetch is rewritten to a different\n  // path from the document as a special deopt case. We should optimistically\n  // assume this won't happen, inline the data into the document, and perform\n  // a minimal request (like a HEAD or range request) to verify that the\n  // response matches. Tricky to get right because we need to account for\n  // all the different deployment environments we support, like output:\n  // \"export\" mode, where we currently don't assume that custom response\n  // headers are present.\n\n  // Patch the Flight data sent by the server with the correct params parsed\n  // from the URL + response object.\n  const renderedPathname = getRenderedPathname(response)\n  const renderedSearch = getRenderedSearch(response)\n  const canonicalUrl = createHrefFromUrl(new URL(location.href))\n  const originalFlightDataPath = fallbackInitialRSCPayload.f[0]\n  const originalFlightRouterState = originalFlightDataPath[0]\n  return {\n    b: fallbackInitialRSCPayload.b,\n    c: canonicalUrl.split('/'),\n    q: renderedSearch,\n    i: fallbackInitialRSCPayload.i,\n    f: [\n      [\n        fillInFallbackFlightRouterState(\n          originalFlightRouterState,\n          renderedPathname,\n          renderedSearch as NormalizedSearch\n        ),\n        originalFlightDataPath[1],\n        originalFlightDataPath[2],\n        originalFlightDataPath[2],\n      ],\n    ],\n    m: fallbackInitialRSCPayload.m,\n    G: fallbackInitialRSCPayload.G,\n    S: fallbackInitialRSCPayload.S,\n  }\n}\n\nfunction fillInFallbackFlightRouterState(\n  flightRouterState: FlightRouterState,\n  renderedPathname: string,\n  renderedSearch: NormalizedSearch\n): FlightRouterState {\n  const pathnameParts = renderedPathname.split('/').filter((p) => p !== '')\n  const index = 0\n  return fillInFallbackFlightRouterStateImpl(\n    flightRouterState,\n    renderedSearch,\n    pathnameParts,\n    index\n  )\n}\n\nfunction fillInFallbackFlightRouterStateImpl(\n  flightRouterState: FlightRouterState,\n  renderedSearch: NormalizedSearch,\n  pathnameParts: Array<string>,\n  pathnamePartsIndex: number\n): FlightRouterState {\n  const originalSegment = flightRouterState[0]\n  let newSegment: Segment\n  let doesAppearInURL: boolean\n  if (typeof originalSegment === 'string') {\n    newSegment = originalSegment\n    doesAppearInURL = doesStaticSegmentAppearInURL(originalSegment)\n  } else {\n    const paramName = originalSegment[0]\n    const paramType = originalSegment[2]\n    const paramValue = parseDynamicParamFromURLPart(\n      paramType,\n      pathnameParts,\n      pathnamePartsIndex\n    )\n    const cacheKey = getCacheKeyForDynamicParam(paramValue, renderedSearch)\n    newSegment = [paramName, cacheKey, paramType]\n    doesAppearInURL = true\n  }\n\n  // Only increment the index if the segment appears in the URL. If it's a\n  // \"virtual\" segment, like a route group, it remains the same.\n  const childPathnamePartsIndex = doesAppearInURL\n    ? pathnamePartsIndex + 1\n    : pathnamePartsIndex\n\n  const children = flightRouterState[1]\n  const newChildren: { [key: string]: FlightRouterState } = {}\n  for (let key in children) {\n    const childFlightRouterState = children[key]\n    newChildren[key] = fillInFallbackFlightRouterStateImpl(\n      childFlightRouterState,\n      renderedSearch,\n      pathnameParts,\n      childPathnamePartsIndex\n    )\n  }\n\n  const newState: FlightRouterState = [\n    newSegment,\n    newChildren,\n    null,\n    flightRouterState[3],\n    flightRouterState[4],\n  ]\n  return newState\n}\n\nexport function getNextFlightSegmentPath(\n  flightSegmentPath: FlightSegmentPath\n): FlightSegmentPath {\n  // Since `FlightSegmentPath` is a repeated tuple of `Segment` and `ParallelRouteKey`, we slice off two items\n  // to get the next segment path.\n  return flightSegmentPath.slice(2)\n}\n\nexport function normalizeFlightData(\n  flightData: FlightData\n): NormalizedFlightData[] | string {\n  // FlightData can be a string when the server didn't respond with a proper flight response,\n  // or when a redirect happens, to signal to the client that it needs to perform an MPA navigation.\n  if (typeof flightData === 'string') {\n    return flightData\n  }\n\n  return flightData.map((flightDataPath) =>\n    getFlightDataPartsFromPath(flightDataPath)\n  )\n}\n\n/**\n * This function is used to prepare the flight router state for the request.\n * It removes markers that are not needed by the server, and are purely used\n * for stashing state on the client.\n * @param flightRouterState - The flight router state to prepare.\n * @param isHmrRefresh - Whether this is an HMR refresh request.\n * @returns The prepared flight router state.\n */\nexport function prepareFlightRouterStateForRequest(\n  flightRouterState: FlightRouterState,\n  isHmrRefresh?: boolean\n): string {\n  // HMR requests need the complete, unmodified state for proper functionality\n  if (isHmrRefresh) {\n    return encodeURIComponent(JSON.stringify(flightRouterState))\n  }\n\n  return encodeURIComponent(\n    JSON.stringify(stripClientOnlyDataFromFlightRouterState(flightRouterState))\n  )\n}\n\n/**\n * Recursively strips client-only data from FlightRouterState while preserving\n * server-needed information for proper rendering decisions.\n */\nfunction stripClientOnlyDataFromFlightRouterState(\n  flightRouterState: FlightRouterState\n): FlightRouterState {\n  const [\n    segment,\n    parallelRoutes,\n    _url, // Intentionally unused - URLs are client-only\n    refreshMarker,\n    isRootLayout,\n    hasLoadingBoundary,\n  ] = flightRouterState\n\n  // __PAGE__ segments are always fetched from the server, so there's\n  // no need to send them up\n  const cleanedSegment = stripSearchParamsFromPageSegment(segment)\n\n  // Recursively process parallel routes\n  const cleanedParallelRoutes: { [key: string]: FlightRouterState } = {}\n  for (const [key, childState] of Object.entries(parallelRoutes)) {\n    cleanedParallelRoutes[key] =\n      stripClientOnlyDataFromFlightRouterState(childState)\n  }\n\n  const result: FlightRouterState = [\n    cleanedSegment,\n    cleanedParallelRoutes,\n    null, // URLs omitted - server reconstructs paths from segments\n    shouldPreserveRefreshMarker(refreshMarker) ? refreshMarker : null,\n  ]\n\n  // Append optional fields if present\n  if (isRootLayout !== undefined) {\n    result[4] = isRootLayout\n  }\n  if (hasLoadingBoundary !== undefined) {\n    result[5] = hasLoadingBoundary\n  }\n\n  return result\n}\n\n/**\n * Strips search parameters from __PAGE__ segments to prevent sensitive\n * client-side data from being sent to the server.\n */\nfunction stripSearchParamsFromPageSegment(segment: Segment): Segment {\n  if (\n    typeof segment === 'string' &&\n    segment.startsWith(PAGE_SEGMENT_KEY + '?')\n  ) {\n    return PAGE_SEGMENT_KEY\n  }\n  return segment\n}\n\n/**\n * Determines whether the refresh marker should be sent to the server\n * Client-only markers like 'refresh' are stripped, while server-needed markers\n * like 'refetch' and 'inside-shared-layout' are preserved.\n */\nfunction shouldPreserveRefreshMarker(\n  refreshMarker: FlightRouterState[3]\n): boolean {\n  return Boolean(refreshMarker && refreshMarker !== 'refresh')\n}\n","// This gets assigned as a side-effect during app initialization. Because it\n// represents the build used to create the JS bundle, it should never change\n// after being set, so we store it in a global variable.\n//\n// When performing RSC requests, if the incoming data has a different build ID,\n// we perform an MPA navigation/refresh to load the updated build and ensure\n// that the client and server in sync.\n\n// Starts as an empty string. In practice, because setAppBuildId is called\n// during initialization before hydration starts, this will always get\n// reassigned to the actual build ID before it's ever needed by a navigation.\n// If for some reasons it didn't, due to a bug or race condition, then on\n// navigation the build comparision would fail and trigger an MPA navigation.\nlet globalBuildId: string = ''\n\nexport function setAppBuildId(buildId: string) {\n  globalBuildId = buildId\n}\n\nexport function getAppBuildId(): string {\n  return globalBuildId\n}\n","// http://www.cse.yorku.ca/~oz/hash.html\n// More specifically, 32-bit hash via djbxor\n// (ref: https://gist.github.com/eplawless/52813b1d8ad9af510d85?permalink_comment_id=3367765#gistcomment-3367765)\n// This is due to number type differences between rust for turbopack to js number types,\n// where rust does not have easy way to repreesnt js's 53-bit float number type for the matching\n// overflow behavior. This is more `correct` in terms of having canonical hash across different runtime / implementation\n// as can gaurantee determinstic output from 32bit hash.\nexport function djb2Hash(str: string) {\n  let hash = 5381\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i)\n    hash = ((hash << 5) + hash + char) & 0xffffffff\n  }\n  return hash >>> 0\n}\n\nexport function hexHash(str: string) {\n  return djb2Hash(str).toString(36).slice(0, 5)\n}\n","import { hexHash } from '../../hash'\n\nexport function computeCacheBustingSearchParam(\n  prefetchHeader: '1' | '2' | '0' | undefined,\n  segmentPrefetchHeader: string | string[] | undefined,\n  stateTreeHeader: string | string[] | undefined,\n  nextUrlHeader: string | string[] | undefined\n): string {\n  if (\n    (prefetchHeader === undefined || prefetchHeader === '0') &&\n    segmentPrefetchHeader === undefined &&\n    stateTreeHeader === undefined &&\n    nextUrlHeader === undefined\n  ) {\n    return ''\n  }\n  return hexHash(\n    [\n      prefetchHeader || '0',\n      segmentPrefetchHeader || '0',\n      stateTreeHeader || '0',\n      nextUrlHeader || '0',\n    ].join(',')\n  )\n}\n","'use client'\n\nimport { computeCacheBustingSearchParam } from '../../../shared/lib/router/utils/cache-busting-search-param'\nimport {\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  NEXT_RSC_UNION_QUERY,\n} from '../app-router-headers'\nimport type { RequestHeaders } from './fetch-server-response'\n\n/**\n * Mutates the provided URL by adding a cache-busting search parameter for CDNs that don't\n * support custom headers. This helps avoid caching conflicts by making each request unique.\n *\n * Rather than relying on the Vary header which some CDNs ignore, we append a search param\n * to create a unique URL that forces a fresh request.\n *\n * Example:\n * URL before: https://example.com/path?query=1\n * URL after: https://example.com/path?query=1&_rsc=abc123\n *\n * Note: This function mutates the input URL directly and does not return anything.\n *\n * TODO: Since we need to use a search param anyway, we could simplify by removing the custom\n * headers approach entirely and just use search params.\n */\nexport const setCacheBustingSearchParam = (\n  url: URL,\n  headers: RequestHeaders\n): void => {\n  const uniqueCacheKey = computeCacheBustingSearchParam(\n    headers[NEXT_ROUTER_PREFETCH_HEADER],\n    headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER],\n    headers[NEXT_ROUTER_STATE_TREE_HEADER],\n    headers[NEXT_URL]\n  )\n  setCacheBustingSearchParamWithHash(url, uniqueCacheKey)\n}\n\n/**\n * Sets a cache-busting search parameter on a URL using a provided hash value.\n *\n * This function performs the same logic as `setCacheBustingSearchParam` but accepts\n * a pre-computed hash instead of computing it from headers.\n *\n * Example:\n * URL before: https://example.com/path?query=1\n * hash: \"abc123\"\n * URL after: https://example.com/path?query=1&_rsc=abc123\n *\n * If the hash is null, we will set `_rsc` search param without a value.\n * Like this: https://example.com/path?query=1&_rsc\n *\n * Note: This function mutates the input URL directly and does not return anything.\n */\nexport const setCacheBustingSearchParamWithHash = (\n  url: URL,\n  hash: string\n): void => {\n  /**\n   * Note that we intentionally do not use `url.searchParams.set` here:\n   *\n   * const url = new URL('https://example.com/search?q=custom%20spacing');\n   * url.searchParams.set('_rsc', 'abc123');\n   * console.log(url.toString()); // Outputs: https://example.com/search?q=custom+spacing&_rsc=abc123\n   *                                                                             ^ <--- this is causing confusion\n   * This is in fact intended based on https://url.spec.whatwg.org/#interface-urlsearchparams, but\n   * we want to preserve the %20 as %20 if that's what the user passed in, hence the custom\n   * logic below.\n   */\n  const existingSearch = url.search\n  const rawQuery = existingSearch.startsWith('?')\n    ? existingSearch.slice(1)\n    : existingSearch\n\n  // Always remove any existing cache busting param and add a fresh one to ensure\n  // we have the correct value based on current request headers\n  const pairs = rawQuery\n    .split('&')\n    .filter((pair) => pair && !pair.startsWith(`${NEXT_RSC_UNION_QUERY}=`))\n\n  if (hash.length > 0) {\n    pairs.push(`${NEXT_RSC_UNION_QUERY}=${hash}`)\n  } else {\n    pairs.push(`${NEXT_RSC_UNION_QUERY}`)\n  }\n  url.search = pairs.length ? `?${pairs.join('&')}` : ''\n}\n","'use client'\n\n// TODO: Explicitly import from client.browser\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport {\n  createFromReadableStream as createFromReadableStreamBrowser,\n  createFromFetch as createFromFetchBrowser,\n} from 'react-server-dom-webpack/client'\n\nimport type {\n  FlightRouterState,\n  NavigationFlightResponse,\n} from '../../../shared/lib/app-router-types'\n\nimport type { NEXT_ROUTER_SEGMENT_PREFETCH_HEADER } from '../app-router-headers'\nimport {\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_RSC_UNION_QUERY,\n  NEXT_URL,\n  RSC_HEADER,\n  RSC_CONTENT_TYPE_HEADER,\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_DID_POSTPONE_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n  NEXT_HTML_REQUEST_ID_HEADER,\n  NEXT_REQUEST_ID_HEADER,\n} from '../app-router-headers'\nimport { callServer } from '../../app-call-server'\nimport { findSourceMapURL } from '../../app-find-source-map-url'\nimport { PrefetchKind } from './router-reducer-types'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n  type NormalizedFlightData,\n} from '../../flight-data-helpers'\nimport { getAppBuildId } from '../../app-build-id'\nimport { setCacheBustingSearchParam } from './set-cache-busting-search-param'\nimport {\n  getRenderedSearch,\n  urlToUrlWithoutFlightMarker,\n} from '../../route-params'\nimport type { NormalizedSearch } from '../segment-cache/cache-key'\n\nconst createFromReadableStream =\n  createFromReadableStreamBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromReadableStream']\nconst createFromFetch =\n  createFromFetchBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromFetch']\n\nlet createDebugChannel:\n  | typeof import('../../dev/debug-channel').createDebugChannel\n  | undefined\n\nif (\n  process.env.NODE_ENV !== 'production' &&\n  process.env.__NEXT_REACT_DEBUG_CHANNEL\n) {\n  createDebugChannel = (\n    require('../../dev/debug-channel') as typeof import('../../dev/debug-channel')\n  ).createDebugChannel\n}\n\nexport interface FetchServerResponseOptions {\n  readonly flightRouterState: FlightRouterState\n  readonly nextUrl: string | null\n  readonly prefetchKind?: PrefetchKind\n  readonly isHmrRefresh?: boolean\n}\n\ntype SpaFetchServerResponseResult = {\n  flightData: NormalizedFlightData[]\n  canonicalUrl: URL\n  renderedSearch: NormalizedSearch\n  couldBeIntercepted: boolean\n  prerendered: boolean\n  postponed: boolean\n  staleTime: number\n  debugInfo: Array<any> | null\n}\n\ntype MpaFetchServerResponseResult = string\n\nexport type FetchServerResponseResult =\n  | MpaFetchServerResponseResult\n  | SpaFetchServerResponseResult\n\nexport type RequestHeaders = {\n  [RSC_HEADER]?: '1'\n  [NEXT_ROUTER_STATE_TREE_HEADER]?: string\n  [NEXT_URL]?: string\n  [NEXT_ROUTER_PREFETCH_HEADER]?: '1' | '2'\n  [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]?: string\n  'x-deployment-id'?: string\n  [NEXT_HMR_REFRESH_HEADER]?: '1'\n  // A header that is only added in test mode to assert on fetch priority\n  'Next-Test-Fetch-Priority'?: RequestInit['priority']\n  [NEXT_HTML_REQUEST_ID_HEADER]?: string // dev-only\n  [NEXT_REQUEST_ID_HEADER]?: string // dev-only\n}\n\nfunction doMpaNavigation(url: string): FetchServerResponseResult {\n  return urlToUrlWithoutFlightMarker(new URL(url, location.origin)).toString()\n}\n\nlet abortController = new AbortController()\n\nif (typeof window !== 'undefined') {\n  // Abort any in-flight requests when the page is unloaded, e.g. due to\n  // reloading the page or performing hard navigations. This allows us to ignore\n  // what would otherwise be a thrown TypeError when the browser cancels the\n  // requests.\n  window.addEventListener('pagehide', () => {\n    abortController.abort()\n  })\n\n  // Use a fresh AbortController instance on pageshow, e.g. when navigating back\n  // and the JavaScript execution context is restored by the browser.\n  window.addEventListener('pageshow', () => {\n    abortController = new AbortController()\n  })\n}\n\n/**\n * Fetch the flight data for the provided url. Takes in the current router state\n * to decide what to render server-side.\n */\nexport async function fetchServerResponse(\n  url: URL,\n  options: FetchServerResponseOptions\n): Promise<FetchServerResponseResult> {\n  const { flightRouterState, nextUrl, prefetchKind } = options\n\n  const headers: RequestHeaders = {\n    // Enable flight response\n    [RSC_HEADER]: '1',\n    // Provide the current router state\n    [NEXT_ROUTER_STATE_TREE_HEADER]: prepareFlightRouterStateForRequest(\n      flightRouterState,\n      options.isHmrRefresh\n    ),\n  }\n\n  /**\n   * Three cases:\n   * - `prefetchKind` is `undefined`, it means it's a normal navigation, so we want to prefetch the page data fully\n   * - `prefetchKind` is `full` - we want to prefetch the whole page so same as above\n   * - `prefetchKind` is `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully\n   */\n  if (prefetchKind === PrefetchKind.AUTO) {\n    headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'\n  }\n\n  if (process.env.NODE_ENV === 'development' && options.isHmrRefresh) {\n    headers[NEXT_HMR_REFRESH_HEADER] = '1'\n  }\n\n  if (nextUrl) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  // In static export mode, we need to modify the URL to request the .txt file,\n  // but we should preserve the original URL for the canonical URL and error handling.\n  const originalUrl = url\n\n  try {\n    // When creating a \"temporary\" prefetch (the \"on-demand\" prefetch that gets created on navigation, if one doesn't exist)\n    // we send the request with a \"high\" priority as it's in response to a user interaction that could be blocking a transition.\n    // Otherwise, all other prefetches are sent with a \"low\" priority.\n    // We use \"auto\" for in all other cases to match the existing default, as this function is shared outside of prefetching.\n    const fetchPriority = prefetchKind\n      ? prefetchKind === PrefetchKind.TEMPORARY\n        ? 'high'\n        : 'low'\n      : 'auto'\n\n    if (process.env.NODE_ENV === 'production') {\n      if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n        // In \"output: export\" mode, we can't rely on headers to distinguish\n        // between HTML and RSC requests. Instead, we append an extra prefix\n        // to the request.\n        url = new URL(url)\n        if (url.pathname.endsWith('/')) {\n          url.pathname += 'index.txt'\n        } else {\n          url.pathname += '.txt'\n        }\n      }\n    }\n\n    // Typically, during a navigation, we decode the response using Flight's\n    // `createFromFetch` API, which accepts a `fetch` promise.\n    // TODO: Remove this check once the old PPR flag is removed\n    const isLegacyPPR =\n      process.env.__NEXT_PPR && !process.env.__NEXT_CACHE_COMPONENTS\n    const shouldImmediatelyDecode = !isLegacyPPR\n    const res = await createFetch<NavigationFlightResponse>(\n      url,\n      headers,\n      fetchPriority,\n      shouldImmediatelyDecode,\n      abortController.signal\n    )\n\n    const responseUrl = urlToUrlWithoutFlightMarker(new URL(res.url))\n    const canonicalUrl = res.redirected ? responseUrl : originalUrl\n\n    const contentType = res.headers.get('content-type') || ''\n    const interception = !!res.headers.get('vary')?.includes(NEXT_URL)\n    const postponed = !!res.headers.get(NEXT_DID_POSTPONE_HEADER)\n    const staleTimeHeaderSeconds = res.headers.get(\n      NEXT_ROUTER_STALE_TIME_HEADER\n    )\n    const staleTime =\n      staleTimeHeaderSeconds !== null\n        ? parseInt(staleTimeHeaderSeconds, 10) * 1000\n        : -1\n    let isFlightResponse = contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n\n    if (process.env.NODE_ENV === 'production') {\n      if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n        if (!isFlightResponse) {\n          isFlightResponse = contentType.startsWith('text/plain')\n        }\n      }\n    }\n\n    // If fetch returns something different than flight response handle it like a mpa navigation\n    // If the fetch was not 200, we also handle it like a mpa navigation\n    if (!isFlightResponse || !res.ok || !res.body) {\n      // in case the original URL came with a hash, preserve it before redirecting to the new URL\n      if (url.hash) {\n        responseUrl.hash = url.hash\n      }\n\n      return doMpaNavigation(responseUrl.toString())\n    }\n\n    // We may navigate to a page that requires a different Webpack runtime.\n    // In prod, every page will have the same Webpack runtime.\n    // In dev, the Webpack runtime is minimal for each page.\n    // We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.\n    // TODO: This needs to happen in the Flight Client.\n    // Or Webpack needs to include the runtime update in the Flight response as\n    // a blocking script.\n    if (process.env.NODE_ENV !== 'production' && !process.env.TURBOPACK) {\n      await (\n        require('../../dev/hot-reloader/app/hot-reloader-app') as typeof import('../../dev/hot-reloader/app/hot-reloader-app')\n      ).waitForWebpackRuntimeHotUpdate()\n    }\n\n    let flightResponsePromise = res.flightResponse\n    if (flightResponsePromise === null) {\n      // Typically, `createFetch` would have already started decoding the\n      // Flight response. If it hasn't, though, we need to decode it now.\n      // TODO: This should only be reachable if legacy PPR is enabled (i.e. PPR\n      // without Cache Components). Remove this branch once legacy PPR\n      // is deleted.\n      const flightStream = postponed\n        ? createUnclosingPrefetchStream(res.body)\n        : res.body\n      flightResponsePromise =\n        createFromNextReadableStream<NavigationFlightResponse>(\n          flightStream,\n          headers\n        )\n    }\n\n    const flightResponse = await flightResponsePromise\n\n    if (getAppBuildId() !== flightResponse.b) {\n      return doMpaNavigation(res.url)\n    }\n\n    const normalizedFlightData = normalizeFlightData(flightResponse.f)\n    if (typeof normalizedFlightData === 'string') {\n      return doMpaNavigation(normalizedFlightData)\n    }\n\n    return {\n      flightData: normalizedFlightData,\n      canonicalUrl: canonicalUrl,\n      renderedSearch: getRenderedSearch(res),\n      couldBeIntercepted: interception,\n      prerendered: flightResponse.S,\n      postponed,\n      staleTime,\n      debugInfo: flightResponsePromise._debugInfo ?? null,\n    }\n  } catch (err) {\n    if (!abortController.signal.aborted) {\n      console.error(\n        `Failed to fetch RSC payload for ${originalUrl}. Falling back to browser navigation.`,\n        err\n      )\n    }\n\n    // If fetch fails handle it like a mpa navigation\n    // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\n    // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\n    return originalUrl.toString()\n  }\n}\n\n// This is a subset of the standard Response type. We use a custom type for\n// this so we can limit which details about the response leak into the rest of\n// the codebase. For example, there's some custom logic for manually following\n// redirects, so \"redirected\" in this type could be a composite of multiple\n// browser fetch calls; however, this fact should not leak to the caller.\nexport type RSCResponse<T> = {\n  ok: boolean\n  redirected: boolean\n  headers: Headers\n  body: ReadableStream<Uint8Array> | null\n  status: number\n  url: string\n  flightResponse: (Promise<T> & { _debugInfo?: Array<any> }) | null\n}\n\nexport async function createFetch<T>(\n  url: URL,\n  headers: RequestHeaders,\n  fetchPriority: 'auto' | 'high' | 'low' | null,\n  shouldImmediatelyDecode: boolean,\n  signal?: AbortSignal\n): Promise<RSCResponse<T>> {\n  // TODO: In output: \"export\" mode, the headers do nothing. Omit them (and the\n  // cache busting search param) from the request so they're\n  // maximally cacheable.\n\n  if (process.env.__NEXT_TEST_MODE && fetchPriority !== null) {\n    headers['Next-Test-Fetch-Priority'] = fetchPriority\n  }\n\n  if (process.env.NEXT_DEPLOYMENT_ID) {\n    headers['x-deployment-id'] = process.env.NEXT_DEPLOYMENT_ID\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (self.__next_r) {\n      headers[NEXT_HTML_REQUEST_ID_HEADER] = self.__next_r\n    }\n\n    // Create a new request ID for the server action request. The server uses\n    // this to tag debug information sent via WebSocket to the client, which\n    // then routes those chunks to the debug channel associated with this ID.\n    headers[NEXT_REQUEST_ID_HEADER] = crypto\n      .getRandomValues(new Uint32Array(1))[0]\n      .toString(16)\n  }\n\n  const fetchOptions: RequestInit = {\n    // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n    credentials: 'same-origin',\n    headers,\n    priority: fetchPriority || undefined,\n    signal,\n  }\n  // `fetchUrl` is slightly different from `url` because we add a cache-busting\n  // search param to it. This should not leak outside of this function, so we\n  // track them separately.\n  let fetchUrl = new URL(url)\n  setCacheBustingSearchParam(fetchUrl, headers)\n  let fetchPromise = fetch(fetchUrl, fetchOptions)\n  // Immediately pass the fetch promise to the Flight client so that the debug\n  // info includes the latency from the client to the server. The internal timer\n  // in React starts as soon as `createFromFetch` is called.\n  //\n  // The only case where we don't do this is during a prefetch, because we have\n  // to do some extra processing of the response stream (see\n  // `createUnclosingPrefetchStream`). But this is fine, because a top-level\n  // prefetch response never blocks a navigation; if it hasn't already been\n  // written into the cache by the time the navigation happens, the router will\n  // go straight to a dynamic request.\n  let flightResponsePromise = shouldImmediatelyDecode\n    ? createFromNextFetch<T>(fetchPromise, headers)\n    : null\n  let browserResponse = await fetchPromise\n\n  // If the server responds with a redirect (e.g. 307), and the redirected\n  // location does not contain the cache busting search param set in the\n  // original request, the response is likely invalid  when following the\n  // redirect, the browser forwards the request headers, but since the cache\n  // busting search param is missing, the server will reject the request due to\n  // a mismatch.\n  //\n  // Ideally, we would be able to intercept the redirect response and perform it\n  // manually, instead of letting the browser automatically follow it, but this\n  // is not allowed by the fetch API.\n  //\n  // So instead, we must \"replay\" the redirect by fetching the new location\n  // again, but this time we'll append the cache busting search param to prevent\n  // a mismatch.\n  //\n  // TODO: We can optimize Next.js's built-in middleware APIs by returning a\n  // custom status code, to prevent the browser from automatically following it.\n  //\n  // This does not affect Server Action-based redirects; those are encoded\n  // differently, as part of the Flight body. It only affects redirects that\n  // occur in a middleware or a third-party proxy.\n\n  let redirected = browserResponse.redirected\n  if (process.env.__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS) {\n    // This is to prevent a redirect loop. Same limit used by Chrome.\n    const MAX_REDIRECTS = 20\n    for (let n = 0; n < MAX_REDIRECTS; n++) {\n      if (!browserResponse.redirected) {\n        // The server did not perform a redirect.\n        break\n      }\n      const responseUrl = new URL(browserResponse.url, fetchUrl)\n      if (responseUrl.origin !== fetchUrl.origin) {\n        // The server redirected to an external URL. The rest of the logic below\n        // is not relevant, because it only applies to internal redirects.\n        break\n      }\n      if (\n        responseUrl.searchParams.get(NEXT_RSC_UNION_QUERY) ===\n        fetchUrl.searchParams.get(NEXT_RSC_UNION_QUERY)\n      ) {\n        // The redirected URL already includes the cache busting search param.\n        // This was probably intentional. Regardless, there's no reason to\n        // issue another request to this URL because it already has the param\n        // value that we would have added below.\n        break\n      }\n      // The RSC request was redirected. Assume the response is invalid.\n      //\n      // Append the cache busting search param to the redirected URL and\n      // fetch again.\n      // TODO: We should abort the previous request.\n      fetchUrl = new URL(responseUrl)\n      setCacheBustingSearchParam(fetchUrl, headers)\n      fetchPromise = fetch(fetchUrl, fetchOptions)\n      flightResponsePromise = shouldImmediatelyDecode\n        ? createFromNextFetch<T>(fetchPromise, headers)\n        : null\n      browserResponse = await fetchPromise\n      // We just performed a manual redirect, so this is now true.\n      redirected = true\n    }\n  }\n\n  // Remove the cache busting search param from the response URL, to prevent it\n  // from leaking outside of this function.\n  const responseUrl = new URL(browserResponse.url, fetchUrl)\n  responseUrl.searchParams.delete(NEXT_RSC_UNION_QUERY)\n\n  const rscResponse: RSCResponse<T> = {\n    url: responseUrl.href,\n\n    // This is true if any redirects occurred, either automatically by the\n    // browser, or manually by us. So it's different from\n    // `browserResponse.redirected`, which only tells us whether the browser\n    // followed a redirect, and only for the last response in the chain.\n    redirected,\n\n    // These can be copied from the last browser response we received. We\n    // intentionally only expose the subset of fields that are actually used\n    // elsewhere in the codebase.\n    ok: browserResponse.ok,\n    headers: browserResponse.headers,\n    body: browserResponse.body,\n    status: browserResponse.status,\n\n    // This is the exact promise returned by `createFromFetch`. It contains\n    // debug information that we need to transfer to any derived promises that\n    // are later rendered by React.\n    flightResponse: flightResponsePromise,\n  }\n\n  return rscResponse\n}\n\nexport function createFromNextReadableStream<T>(\n  flightStream: ReadableStream<Uint8Array>,\n  requestHeaders: RequestHeaders\n): Promise<T> {\n  return createFromReadableStream(flightStream, {\n    callServer,\n    findSourceMapURL,\n    debugChannel: createDebugChannel && createDebugChannel(requestHeaders),\n  })\n}\n\nfunction createFromNextFetch<T>(\n  promiseForResponse: Promise<Response>,\n  requestHeaders: RequestHeaders\n): Promise<T> & { _debugInfo?: Array<any> } {\n  return createFromFetch(promiseForResponse, {\n    callServer,\n    findSourceMapURL,\n    debugChannel: createDebugChannel && createDebugChannel(requestHeaders),\n  })\n}\n\nfunction createUnclosingPrefetchStream(\n  originalFlightStream: ReadableStream<Uint8Array>\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream.\n        return\n      }\n    },\n  })\n}\n","import type { Segment } from '../../../shared/lib/app-router-types'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n\nexport function createRouterCacheKey(\n  segment: Segment,\n  withoutSearchParameters: boolean = false\n) {\n  // if the segment is an array, it means it's a dynamic segment\n  // for example, ['lang', 'en', 'd']. We need to convert it to a string to store it as a cache node key.\n  if (Array.isArray(segment)) {\n    return `${segment[0]}|${segment[1]}|${segment[2]}`\n  }\n\n  // Page segments might have search parameters, ie __PAGE__?foo=bar\n  // When `withoutSearchParameters` is true, we only want to return the page segment\n  if (withoutSearchParameters && segment.startsWith(PAGE_SEGMENT_KEY)) {\n    return PAGE_SEGMENT_KEY\n  }\n\n  return segment\n}\n","'use client'\nimport React, { useEffect } from 'react'\nimport type { AppRouterInstance } from '../../shared/lib/app-router-context.shared-runtime'\nimport { useRouter } from './navigation'\nimport { getRedirectTypeFromError, getURLFromRedirectError } from './redirect'\nimport { RedirectType, isRedirectError } from './redirect-error'\n\ninterface RedirectBoundaryProps {\n  router: AppRouterInstance\n  children: React.ReactNode\n}\n\nfunction HandleRedirect({\n  redirect,\n  reset,\n  redirectType,\n}: {\n  redirect: string\n  redirectType: RedirectType\n  reset: () => void\n}) {\n  const router = useRouter()\n\n  useEffect(() => {\n    React.startTransition(() => {\n      if (redirectType === RedirectType.push) {\n        router.push(redirect, {})\n      } else {\n        router.replace(redirect, {})\n      }\n      reset()\n    })\n  }, [redirect, redirectType, reset, router])\n\n  return null\n}\n\nexport class RedirectErrorBoundary extends React.Component<\n  RedirectBoundaryProps,\n  { redirect: string | null; redirectType: RedirectType | null }\n> {\n  constructor(props: RedirectBoundaryProps) {\n    super(props)\n    this.state = { redirect: null, redirectType: null }\n  }\n\n  static getDerivedStateFromError(error: any) {\n    if (isRedirectError(error)) {\n      const url = getURLFromRedirectError(error)\n      const redirectType = getRedirectTypeFromError(error)\n      if ('handled' in error) {\n        // The redirect was already handled. We'll still catch the redirect error\n        // so that we can remount the subtree, but we don't actually need to trigger the\n        // router.push.\n        return { redirect: null, redirectType: null }\n      }\n\n      return { redirect: url, redirectType }\n    }\n    // Re-throw if error is not for redirect\n    throw error\n  }\n\n  // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.\n  render(): React.ReactNode {\n    const { redirect, redirectType } = this.state\n    if (redirect !== null && redirectType !== null) {\n      return (\n        <HandleRedirect\n          redirect={redirect}\n          redirectType={redirectType}\n          reset={() => this.setState({ redirect: null })}\n        />\n      )\n    }\n\n    return this.props.children\n  }\n}\n\nexport function RedirectBoundary({ children }: { children: React.ReactNode }) {\n  const router = useRouter()\n  return (\n    <RedirectErrorBoundary router={router}>{children}</RedirectErrorBoundary>\n  )\n}\n","/**\n * Create a \"Thenable\" that does not resolve. This is used to suspend indefinitely when data is not available yet.\n */\nexport const unresolvedThenable = {\n  then: () => {},\n} as PromiseLike<void>\n","'use client'\n\nimport type { ReactNode } from 'react'\nimport {\n  METADATA_BOUNDARY_NAME,\n  VIEWPORT_BOUNDARY_NAME,\n  OUTLET_BOUNDARY_NAME,\n  ROOT_LAYOUT_BOUNDARY_NAME,\n} from './boundary-constants'\n\n// We use a namespace object to allow us to recover the name of the function\n// at runtime even when production bundling/minification is used.\nconst NameSpace = {\n  [METADATA_BOUNDARY_NAME]: function ({ children }: { children: ReactNode }) {\n    return children\n  },\n  [VIEWPORT_BOUNDARY_NAME]: function ({ children }: { children: ReactNode }) {\n    return children\n  },\n  [OUTLET_BOUNDARY_NAME]: function ({ children }: { children: ReactNode }) {\n    return children\n  },\n  [ROOT_LAYOUT_BOUNDARY_NAME]: function ({\n    children,\n  }: {\n    children: ReactNode\n  }) {\n    return children\n  },\n}\n\nexport const MetadataBoundary =\n  // We use slice(0) to trick the bundler into not inlining/minifying the function\n  // so it retains the name inferred from the namespace object\n  NameSpace[METADATA_BOUNDARY_NAME.slice(0) as typeof METADATA_BOUNDARY_NAME]\n\nexport const ViewportBoundary =\n  // We use slice(0) to trick the bundler into not inlining/minifying the function\n  // so it retains the name inferred from the namespace object\n  NameSpace[VIEWPORT_BOUNDARY_NAME.slice(0) as typeof VIEWPORT_BOUNDARY_NAME]\n\nexport const OutletBoundary =\n  // We use slice(0) to trick the bundler into not inlining/minifying the function\n  // so it retains the name inferred from the namespace object\n  NameSpace[OUTLET_BOUNDARY_NAME.slice(0) as typeof OUTLET_BOUNDARY_NAME]\n\nexport const RootLayoutBoundary =\n  // We use slice(0) to trick the bundler into not inlining/minifying the function\n  // so it retains the name inferred from the namespace object\n  NameSpace[\n    ROOT_LAYOUT_BOUNDARY_NAME.slice(0) as typeof ROOT_LAYOUT_BOUNDARY_NAME\n  ]\n","import type { FlightRouterState } from '../../../../shared/lib/app-router-types'\nimport { isInterceptionRouteAppPath } from '../../../../shared/lib/router/utils/interception-routes'\n\nexport function hasInterceptionRouteInCurrentTree([\n  segment,\n  parallelRoutes,\n]: FlightRouterState): boolean {\n  // If we have a dynamic segment, it's marked as an interception route by the presence of the `i` suffix.\n  if (\n    Array.isArray(segment) &&\n    (segment[2] === 'di(..)(..)' ||\n      segment[2] === 'ci(..)(..)' ||\n      segment[2] === 'di(.)' ||\n      segment[2] === 'ci(.)' ||\n      segment[2] === 'di(..)' ||\n      segment[2] === 'ci(..)' ||\n      segment[2] === 'di(...)' ||\n      segment[2] === 'ci(...)')\n  ) {\n    return true\n  }\n\n  // If segment is not an array, apply the existing string-based check\n  if (typeof segment === 'string' && isInterceptionRouteAppPath(segment)) {\n    return true\n  }\n\n  // Iterate through parallelRoutes if they exist\n  if (parallelRoutes) {\n    for (const key in parallelRoutes) {\n      if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n"],"names":["useUntrackedPathname","hasFallbackRouteParams","window","workUnitAsyncStorage","require","workUnitStore","getStore","type","fallbackParams","fallbackRouteParams","size","useContext","PathnameContext","createHrefFromUrl","url","includeHash","pathname","search","hash","handleHardNavError","useNavFailureHandler","error","next","__pendingUrl","URL","location","href","console","toString","process","env","__NEXT_APP_NAV_FAIL_HANDLING","useEffect","uncaughtExceptionHandler","evt","reason","addEventListener","removeEventListener","HTML_LIMITED_BOT_UA_RE","HTML_LIMITED_BOT_UA_RE_STRING","getBotType","isBot","HEADLESS_BROWSER_BOT_UA_RE","source","isDomBotUA","userAgent","test","isHtmlLimitedBotUA","undefined","ErrorBoundary","ErrorBoundaryHandler","isBotUserAgent","navigator","React","Component","constructor","props","reset","setState","state","previousPathname","getDerivedStateFromError","isNextRouterError","getDerivedStateFromProps","render","HandleISRError","errorStyles","errorScripts","this","errorComponent","children","ensureLeadingSlash","path","startsWith","normalizeAppPath","normalizeRscURL","route","split","reduce","segment","index","segments","isGroupSegment","length","replace","INTERCEPTION_ROUTE_MARKERS","extractInterceptionRouteInformation","isInterceptionRouteAppPath","find","m","interceptingRoute","marker","interceptedRoute","Error","slice","concat","join","splitInterceptingRoute","matchSegment","existingSegment","HEAD_REQUEST_KEY","ROOT_SEGMENT_REQUEST_KEY","appendSegmentRequestKeyPart","convertSegmentPathToStaticExportFilename","createSegmentRequestKeyPart","PAGE_SEGMENT_KEY","safeName","encodeToFilesystemAndURLSafeString","name","paramType","encodedName","parentRequestKey","parallelRouteKey","childRequestKeyPart","slotKey","simpleParamValueRegex","value","base64url","btoa","segmentPath","doesStaticSegmentAppearInURL","getCacheKeyForDynamicParam","getParamValueFromCacheKey","getRenderedPathname","getRenderedSearch","parseDynamicParamFromURLPart","urlSearchParamsToParsedUrlQuery","urlToUrlWithoutFlightMarker","response","rewrittenQuery","headers","get","NEXT_REWRITTEN_QUERY_HEADER","rewrittenPath","NEXT_REWRITTEN_PATH_HEADER","pathnameParts","partIndex","map","s","encodeURIComponent","prefix","i","endsWith","DEFAULT_SEGMENT_KEY","paramValue","renderedSearch","pageSegmentWithSearchParams","addSearchParamsIfPageSegment","Object","fromEntries","URLSearchParams","urlWithoutFlightParameters","searchParams","delete","NEXT_RSC_UNION_QUERY","NODE_ENV","__NEXT_CONFIG_OUTPUT","paramCacheKey","isCatchAll","result","key","entries","Array","isArray","push","createInitialRSCPayloadFromFallbackPrerender","getFlightDataPartsFromPath","getNextFlightSegmentPath","normalizeFlightData","prepareFlightRouterStateForRequest","flightDataPath","flightDataPathLength","tree","seedData","head","isHeadPartial","pathToSegment","isRootRender","fallbackInitialRSCPayload","renderedPathname","canonicalUrl","originalFlightDataPath","f","originalFlightRouterState","b","c","q","fillInFallbackFlightRouterState","G","S","flightRouterState","filter","p","fillInFallbackFlightRouterStateImpl","pathnamePartsIndex","originalSegment","newSegment","doesAppearInURL","paramName","cacheKey","childPathnamePartsIndex","newChildren","childFlightRouterState","newState","flightSegmentPath","flightData","isHmrRefresh","JSON","stringify","stripClientOnlyDataFromFlightRouterState","parallelRoutes","_url","refreshMarker","isRootLayout","hasLoadingBoundary","cleanedSegment","stripSearchParamsFromPageSegment","cleanedParallelRoutes","childState","shouldPreserveRefreshMarker","Boolean","getAppBuildId","setAppBuildId","globalBuildId","buildId","djb2Hash","hexHash","str","char","charCodeAt","computeCacheBustingSearchParam","prefetchHeader","segmentPrefetchHeader","stateTreeHeader","nextUrlHeader","setCacheBustingSearchParam","setCacheBustingSearchParamWithHash","uniqueCacheKey","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_URL","existingSearch","rawQuery","pairs","pair","createFetch","createFromNextReadableStream","fetchServerResponse","createFromReadableStream","createFromReadableStreamBrowser","createFromFetch","createFromFetchBrowser","createDebugChannel","__NEXT_REACT_DEBUG_CHANNEL","doMpaNavigation","origin","abortController","AbortController","abort","options","nextUrl","prefetchKind","RSC_HEADER","PrefetchKind","AUTO","NEXT_HMR_REFRESH_HEADER","originalUrl","fetchPriority","TEMPORARY","isLegacyPPR","__NEXT_PPR","__NEXT_CACHE_COMPONENTS","shouldImmediatelyDecode","res","signal","responseUrl","redirected","contentType","interception","includes","postponed","NEXT_DID_POSTPONE_HEADER","staleTimeHeaderSeconds","NEXT_ROUTER_STALE_TIME_HEADER","staleTime","parseInt","isFlightResponse","RSC_CONTENT_TYPE_HEADER","ok","body","TURBOPACK","waitForWebpackRuntimeHotUpdate","flightResponsePromise","flightResponse","flightStream","createUnclosingPrefetchStream","normalizedFlightData","couldBeIntercepted","prerendered","debugInfo","_debugInfo","err","aborted","__NEXT_TEST_MODE","NEXT_DEPLOYMENT_ID","self","__next_r","NEXT_HTML_REQUEST_ID_HEADER","NEXT_REQUEST_ID_HEADER","crypto","getRandomValues","Uint32Array","fetchOptions","credentials","priority","fetchUrl","fetchPromise","fetch","createFromNextFetch","browserResponse","__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS","MAX_REDIRECTS","n","rscResponse","status","requestHeaders","callServer","findSourceMapURL","debugChannel","promiseForResponse","originalFlightStream","reader","getReader","ReadableStream","pull","controller","done","read","enqueue","createRouterCacheKey","withoutSearchParameters","RedirectBoundary","RedirectErrorBoundary","HandleRedirect","redirect","redirectType","router","useRouter","startTransition","RedirectType","isRedirectError","getURLFromRedirectError","getRedirectTypeFromError","unresolvedThenable","then","MetadataBoundary","OutletBoundary","RootLayoutBoundary","ViewportBoundary","NameSpace","METADATA_BOUNDARY_NAME","VIEWPORT_BOUNDARY_NAME","OUTLET_BOUNDARY_NAME","ROOT_LAYOUT_BOUNDARY_NAME","hasInterceptionRouteInCurrentTree"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22]}